# Yet another raylib wrapper for Ruby
#
# * https://github.com/vaiorabbit/raylib-bindings
#
# [NOTICE] Autogenerated. Do not edit.

require 'ffi'

module Raylib
  extend FFI::Library
  # Define/Macro

  PHYSAC_MAX_BODIES = 64 # Maximum number of physic bodies supported
  PHYSAC_MAX_MANIFOLDS = 4096 # Maximum number of physic bodies interactions (64x64)
  PHYSAC_MAX_VERTICES = 24 # Maximum number of vertex for polygons shapes
  PHYSAC_DEFAULT_CIRCLE_VERTICES = 24 # Default number of vertices for circle shapes
  PHYSAC_COLLISION_ITERATIONS = 100
  PHYSAC_PENETRATION_ALLOWANCE = 0.05
  PHYSAC_PENETRATION_CORRECTION = 0.4
  PHYSAC_PI = 3.14159265358979323846

  # Enum

  PHYSICS_CIRCLE = 0
  PHYSICS_POLYGON = 1

  # Typedef

  typedef :int, :PhysicsShapeType
  typedef :pointer, :PhysicsBody
  typedef :pointer, :PhysicsManifold

  # Struct

  # Matrix2x2 type (used for polygon shape rotation matrix)
  class Matrix2x2 < FFI::Struct
    layout(
      :m00, :float,
      :m01, :float,
      :m10, :float,
      :m11, :float,
    )
  end

  class PhysicsVertexData < FFI::Struct
    layout(
      :vertexCount, :uint, # Vertex count (positions and normals)
      :positions, [Vector2, 24], # Vertex positions vectors
      :normals, [Vector2, 24], # Vertex normals vectors
    )
  end

  class PhysicsShape < FFI::Struct
    layout(
      :type, :int, # Shape type (circle or polygon)
      :body, :pointer, # Shape physics body data pointer
      :vertexData, PhysicsVertexData, # Shape vertices data (used for polygon shapes)
      :radius, :float, # Shape radius (used for circle shapes)
      :transform, Matrix2x2, # Vertices transform matrix 2x2
    )
  end

  class PhysicsBodyData < FFI::Struct
    layout(
      :id, :uint, # Unique identifier
      :enabled, :bool, # Enabled dynamics state (collisions are calculated anyway)
      :position, Vector2, # Physics body shape pivot
      :velocity, Vector2, # Current linear velocity applied to position
      :force, Vector2, # Current linear force (reset to 0 every step)
      :angularVelocity, :float, # Current angular velocity applied to orient
      :torque, :float, # Current angular force (reset to 0 every step)
      :orient, :float, # Rotation in radians
      :inertia, :float, # Moment of inertia
      :inverseInertia, :float, # Inverse value of inertia
      :mass, :float, # Physics body mass
      :inverseMass, :float, # Inverse value of mass
      :staticFriction, :float, # Friction when the body has not movement (0 to 1)
      :dynamicFriction, :float, # Friction when the body has movement (0 to 1)
      :restitution, :float, # Restitution coefficient of the body (0 to 1)
      :useGravity, :bool, # Apply gravity force to dynamics
      :isGrounded, :bool, # Physics grounded on other body state
      :freezeOrient, :bool, # Physics rotation constraint
      :shape, PhysicsShape, # Physics body shape information (type, radius, vertices, transform)
    )
  end

  class PhysicsManifoldData < FFI::Struct
    layout(
      :id, :uint, # Unique identifier
      :bodyA, :pointer, # Manifold first physics body reference
      :bodyB, :pointer, # Manifold second physics body reference
      :penetration, :float, # Depth of penetration from collision
      :normal, Vector2, # Normal direction vector from 'a' to 'b'
      :contacts, [Vector2, 2], # Points of contact during collision
      :contactsCount, :uint, # Current collision number of contacts
      :restitution, :float, # Mixed restitution during collision
      :dynamicFriction, :float, # Mixed dynamic friction during collision
      :staticFriction, :float, # Mixed static friction during collision
    )
  end


  # Function

  def self.setup_physac_symbols(output_error = false)
    entries = [
      [:InitPhysics, :InitPhysics, [], :void],
      [:UpdatePhysics, :UpdatePhysics, [], :void],
      [:ResetPhysics, :ResetPhysics, [], :void],
      [:ClosePhysics, :ClosePhysics, [], :void],
      [:SetPhysicsTimeStep, :SetPhysicsTimeStep, [:double], :void],
      [:SetPhysicsGravity, :SetPhysicsGravity, [:float, :float], :void],
      [:CreatePhysicsBodyCircle, :CreatePhysicsBodyCircle, [Vector2.by_value, :float, :float], :pointer],
      [:CreatePhysicsBodyRectangle, :CreatePhysicsBodyRectangle, [Vector2.by_value, :float, :float, :float], :pointer],
      [:CreatePhysicsBodyPolygon, :CreatePhysicsBodyPolygon, [Vector2.by_value, :float, :int, :float], :pointer],
      [:DestroyPhysicsBody, :DestroyPhysicsBody, [:pointer], :void],
      [:PhysicsAddForce, :PhysicsAddForce, [:pointer, Vector2.by_value], :void],
      [:PhysicsAddTorque, :PhysicsAddTorque, [:pointer, :float], :void],
      [:PhysicsShatter, :PhysicsShatter, [:pointer, Vector2.by_value, :float], :void],
      [:SetPhysicsBodyRotation, :SetPhysicsBodyRotation, [:pointer, :float], :void],
      [:GetPhysicsBody, :GetPhysicsBody, [:int], :pointer],
      [:GetPhysicsBodiesCount, :GetPhysicsBodiesCount, [], :int],
      [:GetPhysicsShapeType, :GetPhysicsShapeType, [:int], :int],
      [:GetPhysicsShapeVerticesCount, :GetPhysicsShapeVerticesCount, [:int], :int],
      [:GetPhysicsShapeVertex, :GetPhysicsShapeVertex, [:pointer, :int], Vector2.by_value],
    ]
    entries.each do |entry|
      begin
        attach_function entry[0], entry[1], entry[2], entry[3]
      rescue FFI::NotFoundError => error
        $stderr.puts("[Warning] Failed to import #{entry[0]} (#{error}).") if output_error
      end
    end
  end

end

