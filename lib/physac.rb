# Yet another raylib wrapper for Ruby
#
# * https://github.com/vaiorabbit/raylib-bindings
#
# [NOTICE] Autogenerated. Do not edit.

require 'ffi'

module Raylib
  extend FFI::Library

  # Define/Macro

  PHYSAC_MAX_BODIES = 64              # Maximum number of physic bodies supported
  PHYSAC_MAX_MANIFOLDS = 4096         # Maximum number of physic bodies interactions (64x64)
  PHYSAC_MAX_VERTICES = 24            # Maximum number of vertex for polygons shapes
  PHYSAC_DEFAULT_CIRCLE_VERTICES = 24 # Default number of vertices for circle shapes
  PHYSAC_COLLISION_ITERATIONS = 100
  PHYSAC_PENETRATION_ALLOWANCE = 0.05
  PHYSAC_PENETRATION_CORRECTION = 0.4

  # Enum

  # enum PhysicsShapeType
  PHYSICS_CIRCLE = 0
  PHYSICS_POLYGON = 1


  # Typedef

  typedef :int, :PhysicsShapeType
  typedef :pointer, :PhysicsBody
  typedef :pointer, :PhysicsManifold

  # Struct

  # Matrix2x2 type (used for polygon shape rotation matrix)
  class Matrix2x2 < FFI::Struct
    layout(
      :m00, :float,
      :m01, :float,
      :m10, :float,
      :m11, :float,
    )
    def m00 = self[:m00]
    def m00=(v) self[:m00] = v end
    def m01 = self[:m01]
    def m01=(v) self[:m01] = v end
    def m10 = self[:m10]
    def m10=(v) self[:m10] = v end
    def m11 = self[:m11]
    def m11=(v) self[:m11] = v end
  end

  class PhysicsVertexData < FFI::Struct
    layout(
      :vertexCount, :uint,       # Vertex count (positions and normals)
      :positions, [Vector2, 24], # Vertex positions vectors
      :normals, [Vector2, 24],   # Vertex normals vectors
    )
    def vertexCount = self[:vertexCount]
    def vertexCount=(v) self[:vertexCount] = v end
    def positions = self[:positions]
    def positions=(v) self[:positions] = v end
    def normals = self[:normals]
    def normals=(v) self[:normals] = v end
  end

  class PhysicsShape < FFI::Struct
    layout(
      :type, :int,                    # Shape type (circle or polygon)
      :body, :pointer,                # Shape physics body data pointer
      :vertexData, PhysicsVertexData, # Shape vertices data (used for polygon shapes)
      :radius, :float,                # Shape radius (used for circle shapes)
      :transform, Matrix2x2,          # Vertices transform matrix 2x2
    )
    def type = self[:type]
    def type=(v) self[:type] = v end
    def body = self[:body]
    def body=(v) self[:body] = v end
    def vertexData = self[:vertexData]
    def vertexData=(v) self[:vertexData] = v end
    def radius = self[:radius]
    def radius=(v) self[:radius] = v end
    def transform = self[:transform]
    def transform=(v) self[:transform] = v end
  end

  class PhysicsBodyData < FFI::Struct
    layout(
      :id, :uint,               # Unique identifier
      :enabled, :bool,          # Enabled dynamics state (collisions are calculated anyway)
      :position, Vector2,       # Physics body shape pivot
      :velocity, Vector2,       # Current linear velocity applied to position
      :force, Vector2,          # Current linear force (reset to 0 every step)
      :angularVelocity, :float, # Current angular velocity applied to orient
      :torque, :float,          # Current angular force (reset to 0 every step)
      :orient, :float,          # Rotation in radians
      :inertia, :float,         # Moment of inertia
      :inverseInertia, :float,  # Inverse value of inertia
      :mass, :float,            # Physics body mass
      :inverseMass, :float,     # Inverse value of mass
      :staticFriction, :float,  # Friction when the body has not movement (0 to 1)
      :dynamicFriction, :float, # Friction when the body has movement (0 to 1)
      :restitution, :float,     # Restitution coefficient of the body (0 to 1)
      :useGravity, :bool,       # Apply gravity force to dynamics
      :isGrounded, :bool,       # Physics grounded on other body state
      :freezeOrient, :bool,     # Physics rotation constraint
      :shape, PhysicsShape,     # Physics body shape information (type, radius, vertices, transform)
    )
    def id = self[:id]
    def id=(v) self[:id] = v end
    def enabled = self[:enabled]
    def enabled=(v) self[:enabled] = v end
    def position = self[:position]
    def position=(v) self[:position] = v end
    def velocity = self[:velocity]
    def velocity=(v) self[:velocity] = v end
    def force = self[:force]
    def force=(v) self[:force] = v end
    def angularVelocity = self[:angularVelocity]
    def angularVelocity=(v) self[:angularVelocity] = v end
    def torque = self[:torque]
    def torque=(v) self[:torque] = v end
    def orient = self[:orient]
    def orient=(v) self[:orient] = v end
    def inertia = self[:inertia]
    def inertia=(v) self[:inertia] = v end
    def inverseInertia = self[:inverseInertia]
    def inverseInertia=(v) self[:inverseInertia] = v end
    def mass = self[:mass]
    def mass=(v) self[:mass] = v end
    def inverseMass = self[:inverseMass]
    def inverseMass=(v) self[:inverseMass] = v end
    def staticFriction = self[:staticFriction]
    def staticFriction=(v) self[:staticFriction] = v end
    def dynamicFriction = self[:dynamicFriction]
    def dynamicFriction=(v) self[:dynamicFriction] = v end
    def restitution = self[:restitution]
    def restitution=(v) self[:restitution] = v end
    def useGravity = self[:useGravity]
    def useGravity=(v) self[:useGravity] = v end
    def isGrounded = self[:isGrounded]
    def isGrounded=(v) self[:isGrounded] = v end
    def freezeOrient = self[:freezeOrient]
    def freezeOrient=(v) self[:freezeOrient] = v end
    def shape = self[:shape]
    def shape=(v) self[:shape] = v end
  end

  class PhysicsManifoldData < FFI::Struct
    layout(
      :id, :uint,               # Unique identifier
      :bodyA, :pointer,         # Manifold first physics body reference
      :bodyB, :pointer,         # Manifold second physics body reference
      :penetration, :float,     # Depth of penetration from collision
      :normal, Vector2,         # Normal direction vector from 'a' to 'b'
      :contacts, [Vector2, 2],  # Points of contact during collision
      :contactsCount, :uint,    # Current collision number of contacts
      :restitution, :float,     # Mixed restitution during collision
      :dynamicFriction, :float, # Mixed dynamic friction during collision
      :staticFriction, :float,  # Mixed static friction during collision
    )
    def id = self[:id]
    def id=(v) self[:id] = v end
    def bodyA = self[:bodyA]
    def bodyA=(v) self[:bodyA] = v end
    def bodyB = self[:bodyB]
    def bodyB=(v) self[:bodyB] = v end
    def penetration = self[:penetration]
    def penetration=(v) self[:penetration] = v end
    def normal = self[:normal]
    def normal=(v) self[:normal] = v end
    def contacts = self[:contacts]
    def contacts=(v) self[:contacts] = v end
    def contactsCount = self[:contactsCount]
    def contactsCount=(v) self[:contactsCount] = v end
    def restitution = self[:restitution]
    def restitution=(v) self[:restitution] = v end
    def dynamicFriction = self[:dynamicFriction]
    def dynamicFriction=(v) self[:dynamicFriction] = v end
    def staticFriction = self[:staticFriction]
    def staticFriction=(v) self[:staticFriction] = v end
  end


  # Function

  def self.setup_physac_symbols(method_naming: :original)
    entries = [

      # @!method InitPhysics()
      #   InitPhysics : Initializes physics system
      #   @return [void]
      [:InitPhysics, :InitPhysics, [], :void],

      # @!method UpdatePhysics()
      #   UpdatePhysics : Update physics system
      #   @return [void]
      [:UpdatePhysics, :UpdatePhysics, [], :void],

      # @!method ResetPhysics()
      #   ResetPhysics : Reset physics system (global variables)
      #   @return [void]
      [:ResetPhysics, :ResetPhysics, [], :void],

      # @!method ClosePhysics()
      #   ClosePhysics : Close physics system and unload used memory
      #   @return [void]
      [:ClosePhysics, :ClosePhysics, [], :void],

      # @!method SetPhysicsTimeStep(delta)
      #   SetPhysicsTimeStep : Sets physics fixed time step in milliseconds. 1.666666 by default
      #   @param delta [double]
      #   @return [void]
      [:SetPhysicsTimeStep, :SetPhysicsTimeStep, [:double], :void],

      # @!method SetPhysicsGravity(x, y)
      #   SetPhysicsGravity : Sets physics global gravity force
      #   @param x [float]
      #   @param y [float]
      #   @return [void]
      [:SetPhysicsGravity, :SetPhysicsGravity, [:float, :float], :void],

      # @!method CreatePhysicsBodyCircle(pos, radius, density)
      #   CreatePhysicsBodyCircle : Creates a new circle physics body with generic parameters
      #   @param pos [Vector2]
      #   @param radius [float]
      #   @param density [float]
      #   @return [PhysicsBody]
      [:CreatePhysicsBodyCircle, :CreatePhysicsBodyCircle, [Vector2.by_value, :float, :float], :pointer],

      # @!method CreatePhysicsBodyRectangle(pos, width, height, density)
      #   CreatePhysicsBodyRectangle : Creates a new rectangle physics body with generic parameters
      #   @param pos [Vector2]
      #   @param width [float]
      #   @param height [float]
      #   @param density [float]
      #   @return [PhysicsBody]
      [:CreatePhysicsBodyRectangle, :CreatePhysicsBodyRectangle, [Vector2.by_value, :float, :float, :float], :pointer],

      # @!method CreatePhysicsBodyPolygon(pos, radius, sides, density)
      #   CreatePhysicsBodyPolygon : Creates a new polygon physics body with generic parameters
      #   @param pos [Vector2]
      #   @param radius [float]
      #   @param sides [int]
      #   @param density [float]
      #   @return [PhysicsBody]
      [:CreatePhysicsBodyPolygon, :CreatePhysicsBodyPolygon, [Vector2.by_value, :float, :int, :float], :pointer],

      # @!method DestroyPhysicsBody(body)
      #   DestroyPhysicsBody : Destroy a physics body
      #   @param body [PhysicsBody]
      #   @return [void]
      [:DestroyPhysicsBody, :DestroyPhysicsBody, [:pointer], :void],

      # @!method PhysicsAddForce(body, force)
      #   PhysicsAddForce : Adds a force to a physics body
      #   @param body [PhysicsBody]
      #   @param force [Vector2]
      #   @return [void]
      [:PhysicsAddForce, :PhysicsAddForce, [:pointer, Vector2.by_value], :void],

      # @!method PhysicsAddTorque(body, amount)
      #   PhysicsAddTorque : Adds an angular force to a physics body
      #   @param body [PhysicsBody]
      #   @param amount [float]
      #   @return [void]
      [:PhysicsAddTorque, :PhysicsAddTorque, [:pointer, :float], :void],

      # @!method PhysicsShatter(body, position, force)
      #   PhysicsShatter : Shatters a polygon shape physics body to little physics bodies with explosion force
      #   @param body [PhysicsBody]
      #   @param position [Vector2]
      #   @param force [float]
      #   @return [void]
      [:PhysicsShatter, :PhysicsShatter, [:pointer, Vector2.by_value, :float], :void],

      # @!method SetPhysicsBodyRotation(body, radians)
      #   SetPhysicsBodyRotation : Sets physics body shape transform based on radians parameter
      #   @param body [PhysicsBody]
      #   @param radians [float]
      #   @return [void]
      [:SetPhysicsBodyRotation, :SetPhysicsBodyRotation, [:pointer, :float], :void],

      # @!method GetPhysicsBody(index)
      #   GetPhysicsBody : Returns a physics body of the bodies pool at a specific index
      #   @param index [int]
      #   @return [PhysicsBody]
      [:GetPhysicsBody, :GetPhysicsBody, [:int], :pointer],

      # @!method GetPhysicsBodiesCount()
      #   GetPhysicsBodiesCount : Returns the current amount of created physics bodies
      #   @return [int]
      [:GetPhysicsBodiesCount, :GetPhysicsBodiesCount, [], :int],

      # @!method GetPhysicsShapeType(index)
      #   GetPhysicsShapeType : Returns the physics body shape type (PHYSICS_CIRCLE or PHYSICS_POLYGON)
      #   @param index [int]
      #   @return [int]
      [:GetPhysicsShapeType, :GetPhysicsShapeType, [:int], :int],

      # @!method GetPhysicsShapeVerticesCount(index)
      #   GetPhysicsShapeVerticesCount : Returns the amount of vertices of a physics body shape
      #   @param index [int]
      #   @return [int]
      [:GetPhysicsShapeVerticesCount, :GetPhysicsShapeVerticesCount, [:int], :int],

      # @!method GetPhysicsShapeVertex(body, vertex)
      #   GetPhysicsShapeVertex : Returns transformed position of a body shape (body position + vertex transformed position)
      #   @param body [PhysicsBody]
      #   @param vertex [int]
      #   @return [Vector2]
      [:GetPhysicsShapeVertex, :GetPhysicsShapeVertex, [:pointer, :int], Vector2.by_value],
    ]
    entries.each do |entry|
      api_name = if method_naming == :snake_case
                   snake_case_name = entry[0].to_s.gsub(/([A-Z]+)([A-Z0-9][a-z])/, '\1_\2').gsub(/([a-z\d])([A-Z0-9])/, '\1_\2').downcase
                   snake_case_name.gsub!('vector_3', 'vector3_') if snake_case_name.include?('vector_3')
                   snake_case_name.gsub!('vector_2', 'vector2_') if snake_case_name.include?('vector_2')
                   snake_case_name.chop! if snake_case_name.end_with?('_')
                   snake_case_name.to_sym
                 else
                   entry[0]
                 end
      attach_function api_name, entry[1], entry[2], entry[3]
    rescue FFI::NotFoundError => e
      warn "[Warning] Failed to import #{entry[0]} (#{e})."
    end
  end
end
