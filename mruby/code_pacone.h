"class Game\n"
"  attr_reader :high_score, :configs, :current_score, :state_timer\n"

"  STATES = [:Ready, :Playing, :GameOver]\n"
"  DIR_R = 1.0\n"
"  DIR_L = -1.0\n"

"  StageConfig = Struct.new(:screen_width, :screen_height, :dot_count)\n"

"  STATE_READY_DURATION = 2.0\n"

"  def initialize\n"
"    @configs = {\n"
"      :stage_small  => StageConfig.new( 720, 360, 10),\n"
"      :stage_normal => StageConfig.new(1280, 480, 20),\n"
"      :stage_large  => StageConfig.new(1920, 720, 40),\n"
"    }\n"
"    reset\n"
"  end\n"

"  def reset(keep_high_score: false)\n"
"    @state = :Ready\n"
"    @current_score = 0\n"
"    @high_score = 0 unless keep_high_score\n"
"    @state_timer = STATE_READY_DURATION\n"
"  end\n"

"  def update(dt)\n"
"    case @state\n"
"    when :Ready\n"
"      @state_timer -= dt\n"
"      if @state_timer < 0\n"
"        @state_timer = 0.0\n"
"        @state = :Playing\n"
"      end\n"
"    end\n"
"  end\n"

"  def set_state(new_state)\n"
"    raise ArgumentError unless STATES.include? new_state\n"
"    @state = new_state\n"
"  end\n"
"  private :set_state\n"

"  def finish = set_state(:GameOver)\n"

"  def ready? = @state == :Ready\n"

"  def game_over? = @state == :GameOver\n"

"  def current_score=(new_score)\n"
"    @current_score = new_score\n"
"    @high_score = @current_score if @current_score > @high_score\n"
"  end\n"
"end\n"

"class Stage\n"
"  attr_reader :width, :height, :center\n"
"  attr_accessor :offset\n"

"  def initialize(width, height)\n"
"    @width = width\n"
"    @height = height\n"
"    @center = Raylib::Vector2.new(@width * 0.5, @height * 0.5)\n"
"    @offset = Raylib::Vector2.new\n"
"  end\n"

"  def render\n"
"    dark_blue = Raylib::Color.new(0, 82, 172, 255)\n"
"    Raylib.DrawRectangle(0.0, @center.y - @height * 0.5 + @offset.y - 80.0,  @width, 10.0, dark_blue)\n"
"    Raylib.DrawRectangle(0.0, @center.y - @height * 0.5 + @offset.y - 100.0, @width, 10.0, dark_blue)\n"
"    Raylib.DrawRectangle(0.0, @center.y - @height * 0.5 + @offset.y + 80.0,  @width, 10.0, dark_blue)\n"
"    Raylib.DrawRectangle(0.0, @center.y - @height * 0.5 + @offset.y + 100.0, @width, 10.0, dark_blue)\n"
"  end\n"
"end\n"

"class Dot\n"
"  attr_accessor :pos\n"
"  attr_reader :radius, :powerup\n"

"  SCORE_NORMAL = 10\n"
"  SCORE_POWERUP = 50\n"

"  RADIUS_NORMAL = 8.0\n"
"  RADIUS_POWERUP = 24.0\n"

"  def initialize\n"
"    @pos = Raylib::Vector2.new\n"
"    @size = Raylib::Vector2.new\n"
"    reset\n"
"  end\n"

"  def reset(powerup_on: false)\n"
"    @powerup = powerup_on\n"
"    @radius = powerup_on ? RADIUS_POWERUP : RADIUS_NORMAL\n"
"    @size.x = @radius; @size.y = @radius\n"
"    @active = true\n"
"  end\n"

"  def eaten? = !@active\n"

"  def hide = @active = false\n"

"  def score = @powerup ? SCORE_POWERUP : SCORE_NORMAL\n"

"  def render\n"
"    beige = Raylib::Color.new(211, 176, 131, 255)\n"
"    return unless @active\n"
"    if @powerup\n"
"      Raylib.DrawCircle(@pos.x + @radius * 0.5 - RADIUS_NORMAL, @pos.y - @radius * 0.25 + RADIUS_NORMAL, @radius, beige)\n"
"    else\n"
"      Raylib.DrawRectangleV(@pos, @size, beige)\n"
"    end\n"
"  end\n"
"end\n"

"class Enemy\n"
"  attr_accessor :pos\n"
"  attr_reader :hit_radius\n"

"  STATES = [:Alive, :Knockedout, :Stop]\n"

"  SCORE_KNOCKEDOUT = 200\n"

"  SPEED_NORMAL = 440.0\n"
"  SPEED_PANIC = SPEED_NORMAL * 0.25\n"
"  PANIC_DURATION = 3.0\n"
"  KNOCKEDOUT_DURATION = 1.5\n"

"  HIT_RADIUS = 40.0\n"

"  def initialize\n"
"    @pos = Raylib::Vector2.new\n"
"    @anim_leg_timer = 0.0\n"
"    @panic = false\n"
"    @hit_radius = HIT_RADIUS\n"
"    reset\n"
"  end\n"

"  def reset\n"
"    @pos.x = 0.0; @pos.y = 0.0\n"
"    @dir = Game::DIR_R\n"
"    @anim_leg_timer = 0.0\n"
"    @anim_knockedout_timer = 0.0\n"
"    @panic_timer = 0.0\n"
"    @state = :Alive\n"
"  end\n"

"  def score = SCORE_KNOCKEDOUT\n"

"  def set_state(new_state)\n"
"    raise ArgumentError unless STATES.include? new_state\n"
"    @state = new_state\n"
"  end\n"
"  private :set_state\n"

"  def finish = set_state(:Stop)\n"

"  def knockout\n"
"    @anim_knockedout_timer = KNOCKEDOUT_DURATION\n"
"    set_state(:Knockedout)\n"
"  end\n"

"  def knockedout? = @state == :Knockedout\n"

"  def start_panic = @panic_timer = PANIC_DURATION\n"

"  def panic? = @panic_timer > 0.0\n"

"  def speed\n"
"    case @state\n"
"    when :Alive\n"
"      panic? ? SPEED_PANIC : SPEED_NORMAL\n"
"    when :Knockedout\n"
"      (2000.0 + (rand(2000) - 1000)) * (@anim_knockedout_timer ** 2)\n"
"    else\n"
"      0.0\n"
"    end\n"
"  end\n"

"  def run_ai(player_x:, stage_width:)\n"
"    return unless @state == :Alive\n"
"    dist_r = player_x - @pos.x\n"
"    dist_r += stage_width if dist_r.negative?\n"
"    dist_l = @pos.x - player_x\n"
"    dist_l += stage_width if dist_l.negative?\n"
"    @dir = if panic?\n"
"             dist_l <= dist_r ? Game::DIR_R : Game::DIR_L\n"
"           else\n"
"             dist_l <= dist_r ? Game::DIR_L : Game::DIR_R\n"
"           end\n"
"  end\n"

"  def update(dt)\n"
"    case @state\n"
"    when :Alive\n"
"      @pos.x += @dir * speed() * dt\n"
"    when :Knockedout\n"
"      @pos.x += @dir * speed() * dt\n"
"      @anim_knockedout_timer -= dt\n"
"      if @anim_knockedout_timer < 0.0\n"
"        @anim_knockedout_timer = 0.0\n"
"        set_state(:Alive)\n"
"      end\n"
"    end\n"

"    if @panic_timer > 0.0\n"
"      @panic_timer -= dt\n"
"      @panic_timer = 0.0 if @panic_timer < 0.0\n"
"    end\n"

"    @anim_leg_timer += dt\n"
"  end\n"

"  def render\n"
"    body_radius = 50.0\n"
"    leg_radius = body_radius / 3.0\n"
"    leg_amp = 2.0\n"
"    leg_cycle = 660 * Math::PI / 180.0\n"

"    leg_yofs = leg_amp * Math.cos(leg_cycle * @anim_leg_timer)\n"

"    eye_center_ofs = @dir == Game::DIR_L ? -10.0 : 10.0\n"
"    eye_center_x = @pos.x + eye_center_ofs\n"
"    eye_center_y = @pos.y - 10.0\n"
"    eye_dist = 35\n"
"    eye_l_x = eye_center_x - eye_dist * 0.5\n"
"    eye_l_y = eye_center_y\n"
"    eye_r_x = eye_center_x + eye_dist * 0.5\n"
"    eye_r_y = eye_center_y\n"
"    eye_radius_h = 12.0\n"
"    eye_radius_v = 16.0\n"

"    pupil_center_ofs = @dir == Game::DIR_L ? -15.0 : 15.0\n"
"    pupil_center_x = @pos.x + pupil_center_ofs\n"
"    pupil_center_y = @pos.y - 10.0\n"
"    pupil_dist = 35\n"
"    pupil_l_x = pupil_center_x - pupil_dist * 0.5\n"
"    pupil_l_y = pupil_center_y\n"
"    pupil_r_x = pupil_center_x + pupil_dist * 0.5\n"
"    pupil_r_y = pupil_center_y\n"
"    pupil_radius_h = 8.0\n"
"    pupil_radius_v = 10.0\n"

"    unless knockedout?\n"
"      body_color = panic? ? Raylib::Color.new(0,0,255,255) : Raylib::Color.new(255,0,0,255)\n"
"      # Body\n"
"      Raylib.DrawCircleSector(@pos, body_radius, 150, 390, 32, body_color)\n"
"      Raylib.DrawRectangle(@pos.x - body_radius, @pos.y, body_radius * 2.0, leg_radius * 2, body_color)\n"
"      # Legs\n"
"      Raylib.DrawCircle(@pos.x - body_radius + leg_radius, @pos.y + body_radius - leg_radius + leg_yofs, leg_radius, body_color)\n"
"      Raylib.DrawCircle(@pos.x - body_radius + leg_radius + leg_radius * 1.2, @pos.y + body_radius - leg_radius + leg_yofs, leg_radius, body_color)\n"
"      Raylib.DrawCircle(@pos.x + body_radius - leg_radius - leg_radius * 1.2, @pos.y + body_radius - leg_radius + leg_yofs, leg_radius, body_color)\n"
"      Raylib.DrawCircle(@pos.x + body_radius - leg_radius, @pos.y + body_radius - leg_radius + leg_yofs, leg_radius, body_color)\n"
"    end\n"
"    # Eyes\n"
"    Raylib.DrawEllipse(eye_l_x, eye_l_y, eye_radius_h, eye_radius_v, Raylib::Color.new(255,255,255,255))\n"
"    Raylib.DrawEllipse(eye_r_x, eye_r_y, eye_radius_h, eye_radius_v, Raylib::Color.new(255,255,255,255))\n"
"    Raylib.DrawEllipse(pupil_l_x, pupil_l_y, pupil_radius_h, pupil_radius_v, Raylib::Color.new(0,0,255,255))\n"
"    Raylib.DrawEllipse(pupil_r_x, pupil_r_y, pupil_radius_h, pupil_radius_v, Raylib::Color.new(0,0,255,255))\n"
"  end\n"
"end\n"

"class Player\n"
"  attr_accessor :pos\n"

"  STATES = [:Alive, :Failed]\n"

"  SPEED_NORMAL = 360.0\n"
"  SPEED_POWERUP = SPEED_NORMAL * 1.05\n"
"  POWERUP_DURATION = 3.0\n"

"  DRAW_RADIUS = 50.0\n"
"  HIT_RADIUS = 40.0\n"
"  POWERUP_RADIUS_SCALE = 2.5\n"

"  def initialize\n"
"    @pos = Raylib::Vector2.new\n"
"    reset\n"
"  end\n"

"  def reset\n"
"    @pos.x = 0.0; @pos.y = 0.0\n"
"    @dir = Game::DIR_R\n"
"    @draw_radius = DRAW_RADIUS\n"
"    @hit_radius = HIT_RADIUS\n"
"    @powerup_timer = 0.0\n"
"    @anim_mouse_timer = 0.0\n"
"    @anim_mouse_open = true\n"
"    @anim_failed_timer = 0.0\n"
"    @anim_failed_scale = 1.0\n"
"    @state = :Alive\n"
"  end\n"

"  def set_state(new_state)\n"
"    raise ArgumentError unless STATES.include? new_state\n"
"    @state = new_state\n"
"  end\n"
"  private :set_state\n"

"  def finish = set_state(:Failed)\n"

"  def failed? = @state == :Failed\n"

"  def start_powerup = @powerup_timer = POWERUP_DURATION\n"

"  def powerup? = @powerup_timer > 0.0\n"

"  def speed = powerup? ? SPEED_POWERUP : SPEED_NORMAL\n"

"  def hit_radius = powerup? ? @hit_radius * POWERUP_RADIUS_SCALE : @hit_radius\n"

"  def update(dt)\n"
"    if Raylib.IsKeyPressed(Raylib::KEY_RIGHT)\n"
"      @dir = Game::DIR_R\n"
"    elsif Raylib.IsKeyPressed(Raylib::KEY_LEFT)\n"
"      @dir = Game::DIR_L\n"
"    end\n"

"    case @state\n"
"    when :Alive\n"
"      @pos.x += @dir * speed() * dt\n"
"      if @powerup_timer > 0.0\n"
"        @powerup_timer -= dt\n"
"        @powerup_timer = 0.0 if @powerup_timer < 0.0\n"
"      end\n"
"      @anim_mouse_open = @anim_mouse_timer <= ((1.0 / 60.0) * 4)\n"
"      @anim_mouse_timer += dt\n"
"      @anim_mouse_timer = 0.0 if @anim_mouse_timer >= ((1.0 / 60.0) * 8)\n"
"    when :Failed\n"
"      @anim_failed_scale = 1.0 - @anim_failed_timer\n"
"      @anim_failed_scale = 0.0 if @anim_failed_scale < 0.0\n"
"      @anim_failed_timer += dt\n"
"    end\n"
"  end\n"

"  def render\n"
"    radius = powerup? ? @draw_radius * POWERUP_RADIUS_SCALE : @draw_radius\n"
"    radius *= @anim_failed_scale if failed?\n"
"    yellow = Raylib::Color.new(253, 249, 0, 255)\n"
"    orange = Raylib::Color.new(255, 161, 0, 255)\n"
"    body_color = if failed?\n"
"                   Raylib.Fade(yellow, @anim_failed_scale)\n"
"                 elsif powerup?\n"
"                   if @powerup_timer <= 1.0\n"
"                     q = @powerup_timer.divmod(0.05)[0]\n"
"                     q % 2 == 0 ? orange : yellow\n"
"                   else\n"
"                     orange\n"
"                   end\n"
"                 else\n"
"                   yellow\n"
"                 end\n"
"    if @anim_mouse_open\n"
"      if @dir == Game::DIR_L\n"
"        Raylib.DrawCircleSector(@pos, radius, -150, 150, 36, body_color)\n"
"      else\n"
"        Raylib.DrawCircleSector(@pos, radius, 30, 330, 36, body_color)\n"
"      end\n"
"    else\n"
"      Raylib.DrawCircle(@pos.x, @pos.y, radius, body_color)\n"
"    end\n"
"  end\n"
"end\n"

"game = Game.new\n"
"config = game.configs[:stage_normal]\n"
"screen_width, screen_height = config.screen_width, config.screen_height\n"

"# Start raylib\n"
"# Raylib.SetTraceLogLevel(Raylib::LOG_ERROR)\n"
"Raylib.InitWindow(screen_width, screen_height, 'Yet Another Ruby-raylib bindings : 1D dot eater')\n"
"Raylib.SetTargetFPS(60)\n"

"# Initialize objects\n"
"stage_height = screen_height / 4\n"
"stage = Stage.new(screen_width, stage_height)\n"
"stage.offset.y = screen_height * 0.5\n"

"player = Player.new\n"
"enemy = Enemy.new\n"

"dot_start_offset_x = 20.0\n"
"dot_interval = stage.width / config.dot_count.to_f\n"
"dots = Array.new(config.dot_count) { Dot.new }\n"
"dots.each_with_index do |dot, i|\n"
"  dot.pos.y = stage.offset.y\n"
"  dot.pos.x = dot_start_offset_x + i * dot_interval\n"
"end\n"

"# Prepare reset functions as lambda for later use\n"
"reset_dots = lambda {\n"
"  begin\n"
"    success = true\n"
"    power_dot_index = rand(dots.length)\n"
"    dots.each_with_index do |dot, i|\n"
"      dot.reset(powerup_on: i == power_dot_index)\n"
"    end\n"
"    dots.each do |dot|\n"
"      success = false if dot.powerup and Raylib.CheckCollisionCircles(player.pos, 2 * player.hit_radius, dot.pos, dot.radius)\n"
"    end\n"
"  end until success\n"
"}\n"

"reset_game = lambda {\n"
"  game.reset(keep_high_score: true)\n"

"  player.reset\n"
"  player.pos.x = (stage.center.x - stage.width * 0.333); player.pos.y = stage.offset.y\n"

"  enemy.reset\n"
"  enemy.pos.x = (stage.center.x + stage.width * 0.333); enemy.pos.y = stage.offset.y\n"

"  reset_dots.call\n"
"}\n"
"reset_game.call\n"

"until Raylib.WindowShouldClose()\n"
"  # Press R to restart\n"
"  reset_game.call if Raylib.IsKeyPressed(Raylib::KEY_R)\n"

"  dt = Raylib.GetFrameTime()\n"

"  # Update objects\n"
"  game.update(dt)\n"

"  unless game.ready?\n"
"    # Update characters and wrap position\n"
"    enemy.run_ai(player_x: player.pos.x, stage_width: stage.width)\n"
"    [player, enemy].each do |character|\n"
"      character.update(dt)\n"
"      if character.pos.x > stage.width\n"
"        character.pos.x = 0\n"
"      elsif character.pos.x < 0\n"
"        character.pos.x = stage.width\n"
"      end\n"
"    end\n"

"    # Check collision\n"
"    # player vs dots\n"
"    dots.each do |dot|\n"
"      unless dot.eaten?\n"
"        if Raylib.CheckCollisionCircles(player.pos, player.hit_radius, dot.pos, dot.radius)\n"
"          game.current_score += dot.score\n"
"          if dot.powerup\n"
"            player.start_powerup\n"
"            enemy.start_panic\n"
"          end\n"
"          dot.hide\n"
"        end\n"
"      end\n"
"    end\n"
"    # player vs enemy\n"
"    unless enemy.knockedout?\n"
"      if Raylib.CheckCollisionCircles(player.pos, player.hit_radius, enemy.pos, enemy.hit_radius)\n"
"        if player.powerup? # Allow player to eat enemy and get bonus\n"
"          enemy.knockout\n"
"          game.current_score += enemy.score\n"
"        else # player is caught by enemy -> game over\n"
"          game.finish\n"
"          enemy.finish\n"
"          player.finish\n"
"        end\n"
"      end\n"
"    end\n"

"    # Reactivate dots\n"
"    reset_dots.call if dots.all? {|dot| dot.eaten?}\n"
"  end\n"

"  # Render scene\n"
"  Raylib.BeginDrawing()\n"
"    Raylib.ClearBackground(Raylib::Color.new(0,0,0,255))\n"

"    # Render objects\n"
"    stage.render\n"
"    dots.each(&:render)\n"
"    player.render\n"
"    enemy.render\n"

"    # Render UI\n"
"    # Event message\n"
"    msg_font_size = 35\n"
"    if game.ready?\n"
"      text_width = Raylib.MeasureText('READY?', msg_font_size)\n"
"      q = game.state_timer.divmod(0.1)[0]\n"
"      Raylib.DrawText('READY?', 0.5 * screen_width - text_width * 0.5, 70, msg_font_size, Raylib::Color.new(255,0,0,255)) if q % 2 == 0\n"
"    elsif game.game_over?\n"
"      text_widths = [\n"
"        Raylib.MeasureText('GAME OVER', msg_font_size),\n"
"        Raylib.MeasureText('Press R to restart', msg_font_size)\n"
"      ]\n"
"      Raylib.DrawText('GAME OVER', 0.5 * screen_width - text_widths[0] * 0.5, 70, msg_font_size, Raylib::Color.new(255,0,0,255))\n"
"      Raylib.DrawText('Press R to restart', 0.5 * screen_width - text_widths[1] * 0.5, 100, msg_font_size, Raylib::Color.new(255,0,0,255))\n"
"    end\n"

"    # Scores\n"
"    Raylib.DrawText('1UP', 20, 10, 25, Raylib::Color.new(255,0,0,255))\n"
"    Raylib.DrawText(\"#{game.current_score}\", 20, 35, 25, Raylib::Color.new(255,255,255,255))\n"

"    score_font_size = 25\n"
"    hiscore_header = 'HIGH SCORE'\n"
"    hiscore_header_width = Raylib.MeasureText(hiscore_header, score_font_size)\n"
"    hiscore_value = \"%10d\" % game.high_score\n"
"    hiscore_value_width = Raylib.MeasureText(hiscore_value, score_font_size)\n"
"    hiscore_value_offset = (hiscore_header_width - hiscore_value_width).abs\n"

"    hiscore_header_x = 0.5 * screen_width - hiscore_header_width * 0.5\n"
"    hiscore_value_x = hiscore_header_x + hiscore_value_offset\n"
"    Raylib.DrawText(hiscore_header, hiscore_header_x, 10, score_font_size, Raylib::Color.new(255,0,0,255))\n"
"    Raylib.DrawText(hiscore_value,  hiscore_value_x,  35, score_font_size, Raylib::Color.new(255,255,255,255))\n"

"    # Help message\n"
"    help_base_x = screen_width - 300\n"
"    help_base_y = screen_height - 100\n"
"    help_msg_x = help_base_x + 10\n"
"    help_msg_base_y = help_base_y + 10\n"
"    Raylib.DrawRectangle(help_base_x, help_base_y, 280, 80, Raylib.Fade(Raylib::Color.new(190, 33, 55, 255), 0.25))\n"
"    Raylib.DrawRectangleLines(help_base_x, help_base_y, 280, 80, Raylib::Color.new(130, 130, 130, 255))\n"
"    Raylib.DrawText('Left/Right : move player', help_msg_x, help_msg_base_y + 0, 20, Raylib::Color.new(255,255,255,255))\n"
"    Raylib.DrawText('R : restart game', help_msg_x, help_msg_base_y + 20, 20, Raylib::Color.new(255,255,255,255))\n"
"    Raylib.DrawText('ESC : exit', help_msg_x, help_msg_base_y + 40, 20, Raylib::Color.new(255,255,255,255))\n"
"    # FPS\n"
"    Raylib.DrawFPS(screen_width - 100, 16)\n"
"  Raylib.EndDrawing()\n"
"end\n"

"Raylib.CloseWindow()\n"

