// Copyright (c) 2023 vaiorabbit <http://twitter.com/vaiorabbit>
// Autogenerated. Do NOT edit.


#include <mruby.h>
#include <mruby/class.h>
#include <mruby/compile.h>
#include <mruby/data.h>
#include <mruby/string.h>

#include <raylib.h>

#include <string.h>

struct RClass* mRaylib;


// Struct

struct RClass* cRaylibVector2;
static const struct mrb_data_type mrb_raylib_struct_Vector2 = {
    "Vector2", mrb_free
};

struct RClass* cRaylibVector3;
static const struct mrb_data_type mrb_raylib_struct_Vector3 = {
    "Vector3", mrb_free
};

struct RClass* cRaylibVector4;
static const struct mrb_data_type mrb_raylib_struct_Vector4 = {
    "Vector4", mrb_free
};

struct RClass* cRaylibMatrix;
static const struct mrb_data_type mrb_raylib_struct_Matrix = {
    "Matrix", mrb_free
};

struct RClass* cRaylibColor;
static const struct mrb_data_type mrb_raylib_struct_Color = {
    "Color", mrb_free
};

struct RClass* cRaylibRectangle;
static const struct mrb_data_type mrb_raylib_struct_Rectangle = {
    "Rectangle", mrb_free
};

struct RClass* cRaylibImage;
static const struct mrb_data_type mrb_raylib_struct_Image = {
    "Image", mrb_free
};

struct RClass* cRaylibTexture;
static const struct mrb_data_type mrb_raylib_struct_Texture = {
    "Texture", mrb_free
};

struct RClass* cRaylibRenderTexture;
static const struct mrb_data_type mrb_raylib_struct_RenderTexture = {
    "RenderTexture", mrb_free
};

struct RClass* cRaylibNPatchInfo;
static const struct mrb_data_type mrb_raylib_struct_NPatchInfo = {
    "NPatchInfo", mrb_free
};

struct RClass* cRaylibGlyphInfo;
static const struct mrb_data_type mrb_raylib_struct_GlyphInfo = {
    "GlyphInfo", mrb_free
};

struct RClass* cRaylibFont;
static const struct mrb_data_type mrb_raylib_struct_Font = {
    "Font", mrb_free
};

struct RClass* cRaylibCamera3D;
static const struct mrb_data_type mrb_raylib_struct_Camera3D = {
    "Camera3D", mrb_free
};

struct RClass* cRaylibCamera2D;
static const struct mrb_data_type mrb_raylib_struct_Camera2D = {
    "Camera2D", mrb_free
};

struct RClass* cRaylibMesh;
static const struct mrb_data_type mrb_raylib_struct_Mesh = {
    "Mesh", mrb_free
};

struct RClass* cRaylibShader;
static const struct mrb_data_type mrb_raylib_struct_Shader = {
    "Shader", mrb_free
};

struct RClass* cRaylibMaterialMap;
static const struct mrb_data_type mrb_raylib_struct_MaterialMap = {
    "MaterialMap", mrb_free
};

struct RClass* cRaylibMaterial;
static const struct mrb_data_type mrb_raylib_struct_Material = {
    "Material", mrb_free
};

struct RClass* cRaylibTransform;
static const struct mrb_data_type mrb_raylib_struct_Transform = {
    "Transform", mrb_free
};

struct RClass* cRaylibBoneInfo;
static const struct mrb_data_type mrb_raylib_struct_BoneInfo = {
    "BoneInfo", mrb_free
};

struct RClass* cRaylibModel;
static const struct mrb_data_type mrb_raylib_struct_Model = {
    "Model", mrb_free
};

struct RClass* cRaylibModelAnimation;
static const struct mrb_data_type mrb_raylib_struct_ModelAnimation = {
    "ModelAnimation", mrb_free
};

struct RClass* cRaylibRay;
static const struct mrb_data_type mrb_raylib_struct_Ray = {
    "Ray", mrb_free
};

struct RClass* cRaylibRayCollision;
static const struct mrb_data_type mrb_raylib_struct_RayCollision = {
    "RayCollision", mrb_free
};

struct RClass* cRaylibBoundingBox;
static const struct mrb_data_type mrb_raylib_struct_BoundingBox = {
    "BoundingBox", mrb_free
};

struct RClass* cRaylibWave;
static const struct mrb_data_type mrb_raylib_struct_Wave = {
    "Wave", mrb_free
};

struct RClass* cRaylibAudioStream;
static const struct mrb_data_type mrb_raylib_struct_AudioStream = {
    "AudioStream", mrb_free
};

struct RClass* cRaylibSound;
static const struct mrb_data_type mrb_raylib_struct_Sound = {
    "Sound", mrb_free
};

struct RClass* cRaylibMusic;
static const struct mrb_data_type mrb_raylib_struct_Music = {
    "Music", mrb_free
};

struct RClass* cRaylibVrDeviceInfo;
static const struct mrb_data_type mrb_raylib_struct_VrDeviceInfo = {
    "VrDeviceInfo", mrb_free
};

struct RClass* cRaylibVrStereoConfig;
static const struct mrb_data_type mrb_raylib_struct_VrStereoConfig = {
    "VrStereoConfig", mrb_free
};

struct RClass* cRaylibFilePathList;
static const struct mrb_data_type mrb_raylib_struct_FilePathList = {
    "FilePathList", mrb_free
};

struct RClass* cRaylibAutomationEvent;
static const struct mrb_data_type mrb_raylib_struct_AutomationEvent = {
    "AutomationEvent", mrb_free
};

struct RClass* cRaylibAutomationEventList;
static const struct mrb_data_type mrb_raylib_struct_AutomationEventList = {
    "AutomationEventList", mrb_free
};


// Struct

static mrb_value mrb_raylib_Vector2_initialize(mrb_state* mrb, mrb_value self)
{
    Vector2* instance = (Vector2*)mrb_malloc(mrb, sizeof(Vector2));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(Vector2));
        break;
    }
    case 2:
    {
        mrb_value argv[2];
        void* ptrs[2] = { &argv[0], &argv[1], };
        mrb_get_args_a(mrb, "oo", ptrs);
        instance->x = mrb_as_float(mrb, argv[0]);
        instance->y = mrb_as_float(mrb, argv[1]);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_Vector2);
    return self;
}

static mrb_value mrb_raylib_Vector2_x_get(mrb_state* mrb, mrb_value self)
{
    Vector2* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Vector2, Vector2);
    return mrb_float_value(mrb, instance->x);
}

static mrb_value mrb_raylib_Vector2_x_set(mrb_state* mrb, mrb_value self)
{
    Vector2* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Vector2, Vector2);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->x = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Vector2_y_get(mrb_state* mrb, mrb_value self)
{
    Vector2* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Vector2, Vector2);
    return mrb_float_value(mrb, instance->y);
}

static mrb_value mrb_raylib_Vector2_y_set(mrb_state* mrb, mrb_value self)
{
    Vector2* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Vector2, Vector2);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->y = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Vector3_initialize(mrb_state* mrb, mrb_value self)
{
    Vector3* instance = (Vector3*)mrb_malloc(mrb, sizeof(Vector3));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(Vector3));
        break;
    }
    case 3:
    {
        mrb_value argv[3];
        void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
        mrb_get_args_a(mrb, "ooo", ptrs);
        instance->x = mrb_as_float(mrb, argv[0]);
        instance->y = mrb_as_float(mrb, argv[1]);
        instance->z = mrb_as_float(mrb, argv[2]);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_Vector3);
    return self;
}

static mrb_value mrb_raylib_Vector3_x_get(mrb_state* mrb, mrb_value self)
{
    Vector3* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Vector3, Vector3);
    return mrb_float_value(mrb, instance->x);
}

static mrb_value mrb_raylib_Vector3_x_set(mrb_state* mrb, mrb_value self)
{
    Vector3* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Vector3, Vector3);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->x = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Vector3_y_get(mrb_state* mrb, mrb_value self)
{
    Vector3* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Vector3, Vector3);
    return mrb_float_value(mrb, instance->y);
}

static mrb_value mrb_raylib_Vector3_y_set(mrb_state* mrb, mrb_value self)
{
    Vector3* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Vector3, Vector3);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->y = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Vector3_z_get(mrb_state* mrb, mrb_value self)
{
    Vector3* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Vector3, Vector3);
    return mrb_float_value(mrb, instance->z);
}

static mrb_value mrb_raylib_Vector3_z_set(mrb_state* mrb, mrb_value self)
{
    Vector3* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Vector3, Vector3);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->z = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Vector4_initialize(mrb_state* mrb, mrb_value self)
{
    Vector4* instance = (Vector4*)mrb_malloc(mrb, sizeof(Vector4));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(Vector4));
        break;
    }
    case 4:
    {
        mrb_value argv[4];
        void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
        mrb_get_args_a(mrb, "oooo", ptrs);
        instance->x = mrb_as_float(mrb, argv[0]);
        instance->y = mrb_as_float(mrb, argv[1]);
        instance->z = mrb_as_float(mrb, argv[2]);
        instance->w = mrb_as_float(mrb, argv[3]);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_Vector4);
    return self;
}

static mrb_value mrb_raylib_Vector4_x_get(mrb_state* mrb, mrb_value self)
{
    Vector4* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Vector4, Vector4);
    return mrb_float_value(mrb, instance->x);
}

static mrb_value mrb_raylib_Vector4_x_set(mrb_state* mrb, mrb_value self)
{
    Vector4* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Vector4, Vector4);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->x = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Vector4_y_get(mrb_state* mrb, mrb_value self)
{
    Vector4* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Vector4, Vector4);
    return mrb_float_value(mrb, instance->y);
}

static mrb_value mrb_raylib_Vector4_y_set(mrb_state* mrb, mrb_value self)
{
    Vector4* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Vector4, Vector4);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->y = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Vector4_z_get(mrb_state* mrb, mrb_value self)
{
    Vector4* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Vector4, Vector4);
    return mrb_float_value(mrb, instance->z);
}

static mrb_value mrb_raylib_Vector4_z_set(mrb_state* mrb, mrb_value self)
{
    Vector4* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Vector4, Vector4);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->z = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Vector4_w_get(mrb_state* mrb, mrb_value self)
{
    Vector4* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Vector4, Vector4);
    return mrb_float_value(mrb, instance->w);
}

static mrb_value mrb_raylib_Vector4_w_set(mrb_state* mrb, mrb_value self)
{
    Vector4* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Vector4, Vector4);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->w = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Matrix_initialize(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = (Matrix*)mrb_malloc(mrb, sizeof(Matrix));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(Matrix));
        break;
    }
    case 16:
    {
        mrb_value argv[16];
        void* ptrs[16] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], &argv[6], &argv[7], &argv[8], &argv[9], &argv[10], &argv[11], &argv[12], &argv[13], &argv[14], &argv[15], };
        mrb_get_args_a(mrb, "oooooooooooooooo", ptrs);
        instance->m0 = mrb_as_float(mrb, argv[0]);
        instance->m4 = mrb_as_float(mrb, argv[1]);
        instance->m8 = mrb_as_float(mrb, argv[2]);
        instance->m12 = mrb_as_float(mrb, argv[3]);
        instance->m1 = mrb_as_float(mrb, argv[4]);
        instance->m5 = mrb_as_float(mrb, argv[5]);
        instance->m9 = mrb_as_float(mrb, argv[6]);
        instance->m13 = mrb_as_float(mrb, argv[7]);
        instance->m2 = mrb_as_float(mrb, argv[8]);
        instance->m6 = mrb_as_float(mrb, argv[9]);
        instance->m10 = mrb_as_float(mrb, argv[10]);
        instance->m14 = mrb_as_float(mrb, argv[11]);
        instance->m3 = mrb_as_float(mrb, argv[12]);
        instance->m7 = mrb_as_float(mrb, argv[13]);
        instance->m11 = mrb_as_float(mrb, argv[14]);
        instance->m15 = mrb_as_float(mrb, argv[15]);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_Matrix);
    return self;
}

static mrb_value mrb_raylib_Matrix_m0_get(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    return mrb_float_value(mrb, instance->m0);
}

static mrb_value mrb_raylib_Matrix_m0_set(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->m0 = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Matrix_m4_get(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    return mrb_float_value(mrb, instance->m4);
}

static mrb_value mrb_raylib_Matrix_m4_set(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->m4 = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Matrix_m8_get(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    return mrb_float_value(mrb, instance->m8);
}

static mrb_value mrb_raylib_Matrix_m8_set(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->m8 = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Matrix_m12_get(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    return mrb_float_value(mrb, instance->m12);
}

static mrb_value mrb_raylib_Matrix_m12_set(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->m12 = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Matrix_m1_get(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    return mrb_float_value(mrb, instance->m1);
}

static mrb_value mrb_raylib_Matrix_m1_set(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->m1 = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Matrix_m5_get(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    return mrb_float_value(mrb, instance->m5);
}

static mrb_value mrb_raylib_Matrix_m5_set(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->m5 = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Matrix_m9_get(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    return mrb_float_value(mrb, instance->m9);
}

static mrb_value mrb_raylib_Matrix_m9_set(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->m9 = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Matrix_m13_get(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    return mrb_float_value(mrb, instance->m13);
}

static mrb_value mrb_raylib_Matrix_m13_set(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->m13 = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Matrix_m2_get(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    return mrb_float_value(mrb, instance->m2);
}

static mrb_value mrb_raylib_Matrix_m2_set(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->m2 = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Matrix_m6_get(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    return mrb_float_value(mrb, instance->m6);
}

static mrb_value mrb_raylib_Matrix_m6_set(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->m6 = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Matrix_m10_get(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    return mrb_float_value(mrb, instance->m10);
}

static mrb_value mrb_raylib_Matrix_m10_set(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->m10 = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Matrix_m14_get(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    return mrb_float_value(mrb, instance->m14);
}

static mrb_value mrb_raylib_Matrix_m14_set(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->m14 = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Matrix_m3_get(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    return mrb_float_value(mrb, instance->m3);
}

static mrb_value mrb_raylib_Matrix_m3_set(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->m3 = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Matrix_m7_get(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    return mrb_float_value(mrb, instance->m7);
}

static mrb_value mrb_raylib_Matrix_m7_set(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->m7 = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Matrix_m11_get(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    return mrb_float_value(mrb, instance->m11);
}

static mrb_value mrb_raylib_Matrix_m11_set(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->m11 = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Matrix_m15_get(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    return mrb_float_value(mrb, instance->m15);
}

static mrb_value mrb_raylib_Matrix_m15_set(mrb_state* mrb, mrb_value self)
{
    Matrix* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Matrix, Matrix);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->m15 = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Color_initialize(mrb_state* mrb, mrb_value self)
{
    Color* instance = (Color*)mrb_malloc(mrb, sizeof(Color));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(Color));
        break;
    }
    case 4:
    {
        mrb_value argv[4];
        void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
        mrb_get_args_a(mrb, "oooo", ptrs);
        instance->r = mrb_as_int(mrb, argv[0]);
        instance->g = mrb_as_int(mrb, argv[1]);
        instance->b = mrb_as_int(mrb, argv[2]);
        instance->a = mrb_as_int(mrb, argv[3]);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_Color);
    return self;
}

static mrb_value mrb_raylib_Color_r_get(mrb_state* mrb, mrb_value self)
{
    Color* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Color, Color);
    return mrb_int_value(mrb, instance->r);
}

static mrb_value mrb_raylib_Color_r_set(mrb_state* mrb, mrb_value self)
{
    Color* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Color, Color);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->r = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Color_g_get(mrb_state* mrb, mrb_value self)
{
    Color* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Color, Color);
    return mrb_int_value(mrb, instance->g);
}

static mrb_value mrb_raylib_Color_g_set(mrb_state* mrb, mrb_value self)
{
    Color* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Color, Color);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->g = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Color_b_get(mrb_state* mrb, mrb_value self)
{
    Color* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Color, Color);
    return mrb_int_value(mrb, instance->b);
}

static mrb_value mrb_raylib_Color_b_set(mrb_state* mrb, mrb_value self)
{
    Color* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Color, Color);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->b = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Color_a_get(mrb_state* mrb, mrb_value self)
{
    Color* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Color, Color);
    return mrb_int_value(mrb, instance->a);
}

static mrb_value mrb_raylib_Color_a_set(mrb_state* mrb, mrb_value self)
{
    Color* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Color, Color);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->a = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Rectangle_initialize(mrb_state* mrb, mrb_value self)
{
    Rectangle* instance = (Rectangle*)mrb_malloc(mrb, sizeof(Rectangle));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(Rectangle));
        break;
    }
    case 4:
    {
        mrb_value argv[4];
        void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
        mrb_get_args_a(mrb, "oooo", ptrs);
        instance->x = mrb_as_float(mrb, argv[0]);
        instance->y = mrb_as_float(mrb, argv[1]);
        instance->width = mrb_as_float(mrb, argv[2]);
        instance->height = mrb_as_float(mrb, argv[3]);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_Rectangle);
    return self;
}

static mrb_value mrb_raylib_Rectangle_x_get(mrb_state* mrb, mrb_value self)
{
    Rectangle* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Rectangle, Rectangle);
    return mrb_float_value(mrb, instance->x);
}

static mrb_value mrb_raylib_Rectangle_x_set(mrb_state* mrb, mrb_value self)
{
    Rectangle* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Rectangle, Rectangle);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->x = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Rectangle_y_get(mrb_state* mrb, mrb_value self)
{
    Rectangle* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Rectangle, Rectangle);
    return mrb_float_value(mrb, instance->y);
}

static mrb_value mrb_raylib_Rectangle_y_set(mrb_state* mrb, mrb_value self)
{
    Rectangle* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Rectangle, Rectangle);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->y = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Rectangle_width_get(mrb_state* mrb, mrb_value self)
{
    Rectangle* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Rectangle, Rectangle);
    return mrb_float_value(mrb, instance->width);
}

static mrb_value mrb_raylib_Rectangle_width_set(mrb_state* mrb, mrb_value self)
{
    Rectangle* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Rectangle, Rectangle);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->width = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Rectangle_height_get(mrb_state* mrb, mrb_value self)
{
    Rectangle* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Rectangle, Rectangle);
    return mrb_float_value(mrb, instance->height);
}

static mrb_value mrb_raylib_Rectangle_height_set(mrb_state* mrb, mrb_value self)
{
    Rectangle* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Rectangle, Rectangle);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->height = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Image_initialize(mrb_state* mrb, mrb_value self)
{
    Image* instance = (Image*)mrb_malloc(mrb, sizeof(Image));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(Image));
        break;
    }
    case 5:
    {
        mrb_value argv[5];
        void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
        mrb_get_args_a(mrb, "ooooo", ptrs);
        instance->data = DATA_PTR(argv[0]);
        instance->width = mrb_as_int(mrb, argv[1]);
        instance->height = mrb_as_int(mrb, argv[2]);
        instance->mipmaps = mrb_as_int(mrb, argv[3]);
        instance->format = mrb_as_int(mrb, argv[4]);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_Image);
    return self;
}

// static mrb_value mrb_raylib_Image_data_get(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes
// static mrb_value mrb_raylib_Image_data_set(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes

static mrb_value mrb_raylib_Image_width_get(mrb_state* mrb, mrb_value self)
{
    Image* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Image, Image);
    return mrb_int_value(mrb, instance->width);
}

static mrb_value mrb_raylib_Image_width_set(mrb_state* mrb, mrb_value self)
{
    Image* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Image, Image);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->width = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Image_height_get(mrb_state* mrb, mrb_value self)
{
    Image* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Image, Image);
    return mrb_int_value(mrb, instance->height);
}

static mrb_value mrb_raylib_Image_height_set(mrb_state* mrb, mrb_value self)
{
    Image* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Image, Image);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->height = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Image_mipmaps_get(mrb_state* mrb, mrb_value self)
{
    Image* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Image, Image);
    return mrb_int_value(mrb, instance->mipmaps);
}

static mrb_value mrb_raylib_Image_mipmaps_set(mrb_state* mrb, mrb_value self)
{
    Image* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Image, Image);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->mipmaps = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Image_format_get(mrb_state* mrb, mrb_value self)
{
    Image* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Image, Image);
    return mrb_int_value(mrb, instance->format);
}

static mrb_value mrb_raylib_Image_format_set(mrb_state* mrb, mrb_value self)
{
    Image* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Image, Image);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->format = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Texture_initialize(mrb_state* mrb, mrb_value self)
{
    Texture* instance = (Texture*)mrb_malloc(mrb, sizeof(Texture));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(Texture));
        break;
    }
    case 5:
    {
        mrb_value argv[5];
        void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
        mrb_get_args_a(mrb, "ooooo", ptrs);
        instance->id = mrb_as_int(mrb, argv[0]);
        instance->width = mrb_as_int(mrb, argv[1]);
        instance->height = mrb_as_int(mrb, argv[2]);
        instance->mipmaps = mrb_as_int(mrb, argv[3]);
        instance->format = mrb_as_int(mrb, argv[4]);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_Texture);
    return self;
}

static mrb_value mrb_raylib_Texture_id_get(mrb_state* mrb, mrb_value self)
{
    Texture* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Texture, Texture);
    return mrb_int_value(mrb, instance->id);
}

static mrb_value mrb_raylib_Texture_id_set(mrb_state* mrb, mrb_value self)
{
    Texture* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Texture, Texture);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->id = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Texture_width_get(mrb_state* mrb, mrb_value self)
{
    Texture* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Texture, Texture);
    return mrb_int_value(mrb, instance->width);
}

static mrb_value mrb_raylib_Texture_width_set(mrb_state* mrb, mrb_value self)
{
    Texture* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Texture, Texture);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->width = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Texture_height_get(mrb_state* mrb, mrb_value self)
{
    Texture* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Texture, Texture);
    return mrb_int_value(mrb, instance->height);
}

static mrb_value mrb_raylib_Texture_height_set(mrb_state* mrb, mrb_value self)
{
    Texture* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Texture, Texture);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->height = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Texture_mipmaps_get(mrb_state* mrb, mrb_value self)
{
    Texture* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Texture, Texture);
    return mrb_int_value(mrb, instance->mipmaps);
}

static mrb_value mrb_raylib_Texture_mipmaps_set(mrb_state* mrb, mrb_value self)
{
    Texture* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Texture, Texture);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->mipmaps = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Texture_format_get(mrb_state* mrb, mrb_value self)
{
    Texture* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Texture, Texture);
    return mrb_int_value(mrb, instance->format);
}

static mrb_value mrb_raylib_Texture_format_set(mrb_state* mrb, mrb_value self)
{
    Texture* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Texture, Texture);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->format = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_RenderTexture_initialize(mrb_state* mrb, mrb_value self)
{
    RenderTexture* instance = (RenderTexture*)mrb_malloc(mrb, sizeof(RenderTexture));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(RenderTexture));
        break;
    }
    case 3:
    {
        mrb_value argv[3];
        void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
        mrb_get_args_a(mrb, "ooo", ptrs);
        instance->id = mrb_as_int(mrb, argv[0]);
        instance->texture = *(Texture*)DATA_PTR(argv[1]);
        instance->depth = *(Texture*)DATA_PTR(argv[2]);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_RenderTexture);
    return self;
}

static mrb_value mrb_raylib_RenderTexture_id_get(mrb_state* mrb, mrb_value self)
{
    RenderTexture* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_RenderTexture, RenderTexture);
    return mrb_int_value(mrb, instance->id);
}

static mrb_value mrb_raylib_RenderTexture_id_set(mrb_state* mrb, mrb_value self)
{
    RenderTexture* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_RenderTexture, RenderTexture);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->id = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_RenderTexture_texture_get(mrb_state* mrb, mrb_value self)
{
    RenderTexture* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_RenderTexture, RenderTexture);
    return mrb_obj_value(&instance->texture);
}

static mrb_value mrb_raylib_RenderTexture_texture_set(mrb_state* mrb, mrb_value self)
{
    RenderTexture* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_RenderTexture, RenderTexture);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->texture = *(Texture*)DATA_PTR(argv);
    return self;
}

static mrb_value mrb_raylib_RenderTexture_depth_get(mrb_state* mrb, mrb_value self)
{
    RenderTexture* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_RenderTexture, RenderTexture);
    return mrb_obj_value(&instance->depth);
}

static mrb_value mrb_raylib_RenderTexture_depth_set(mrb_state* mrb, mrb_value self)
{
    RenderTexture* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_RenderTexture, RenderTexture);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->depth = *(Texture*)DATA_PTR(argv);
    return self;
}

static mrb_value mrb_raylib_NPatchInfo_initialize(mrb_state* mrb, mrb_value self)
{
    NPatchInfo* instance = (NPatchInfo*)mrb_malloc(mrb, sizeof(NPatchInfo));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(NPatchInfo));
        break;
    }
    case 6:
    {
        mrb_value argv[6];
        void* ptrs[6] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], };
        mrb_get_args_a(mrb, "oooooo", ptrs);
        instance->source = *(Rectangle*)DATA_PTR(argv[0]);
        instance->left = mrb_as_int(mrb, argv[1]);
        instance->top = mrb_as_int(mrb, argv[2]);
        instance->right = mrb_as_int(mrb, argv[3]);
        instance->bottom = mrb_as_int(mrb, argv[4]);
        instance->layout = mrb_as_int(mrb, argv[5]);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_NPatchInfo);
    return self;
}

static mrb_value mrb_raylib_NPatchInfo_source_get(mrb_state* mrb, mrb_value self)
{
    NPatchInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_NPatchInfo, NPatchInfo);
    return mrb_obj_value(&instance->source);
}

static mrb_value mrb_raylib_NPatchInfo_source_set(mrb_state* mrb, mrb_value self)
{
    NPatchInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_NPatchInfo, NPatchInfo);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->source = *(Rectangle*)DATA_PTR(argv);
    return self;
}

static mrb_value mrb_raylib_NPatchInfo_left_get(mrb_state* mrb, mrb_value self)
{
    NPatchInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_NPatchInfo, NPatchInfo);
    return mrb_int_value(mrb, instance->left);
}

static mrb_value mrb_raylib_NPatchInfo_left_set(mrb_state* mrb, mrb_value self)
{
    NPatchInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_NPatchInfo, NPatchInfo);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->left = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_NPatchInfo_top_get(mrb_state* mrb, mrb_value self)
{
    NPatchInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_NPatchInfo, NPatchInfo);
    return mrb_int_value(mrb, instance->top);
}

static mrb_value mrb_raylib_NPatchInfo_top_set(mrb_state* mrb, mrb_value self)
{
    NPatchInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_NPatchInfo, NPatchInfo);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->top = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_NPatchInfo_right_get(mrb_state* mrb, mrb_value self)
{
    NPatchInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_NPatchInfo, NPatchInfo);
    return mrb_int_value(mrb, instance->right);
}

static mrb_value mrb_raylib_NPatchInfo_right_set(mrb_state* mrb, mrb_value self)
{
    NPatchInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_NPatchInfo, NPatchInfo);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->right = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_NPatchInfo_bottom_get(mrb_state* mrb, mrb_value self)
{
    NPatchInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_NPatchInfo, NPatchInfo);
    return mrb_int_value(mrb, instance->bottom);
}

static mrb_value mrb_raylib_NPatchInfo_bottom_set(mrb_state* mrb, mrb_value self)
{
    NPatchInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_NPatchInfo, NPatchInfo);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->bottom = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_NPatchInfo_layout_get(mrb_state* mrb, mrb_value self)
{
    NPatchInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_NPatchInfo, NPatchInfo);
    return mrb_int_value(mrb, instance->layout);
}

static mrb_value mrb_raylib_NPatchInfo_layout_set(mrb_state* mrb, mrb_value self)
{
    NPatchInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_NPatchInfo, NPatchInfo);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->layout = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_GlyphInfo_initialize(mrb_state* mrb, mrb_value self)
{
    GlyphInfo* instance = (GlyphInfo*)mrb_malloc(mrb, sizeof(GlyphInfo));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(GlyphInfo));
        break;
    }
    case 5:
    {
        mrb_value argv[5];
        void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
        mrb_get_args_a(mrb, "ooooo", ptrs);
        instance->value = mrb_as_int(mrb, argv[0]);
        instance->offsetX = mrb_as_int(mrb, argv[1]);
        instance->offsetY = mrb_as_int(mrb, argv[2]);
        instance->advanceX = mrb_as_int(mrb, argv[3]);
        instance->image = *(Image*)DATA_PTR(argv[4]);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_GlyphInfo);
    return self;
}

static mrb_value mrb_raylib_GlyphInfo_value_get(mrb_state* mrb, mrb_value self)
{
    GlyphInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_GlyphInfo, GlyphInfo);
    return mrb_int_value(mrb, instance->value);
}

static mrb_value mrb_raylib_GlyphInfo_value_set(mrb_state* mrb, mrb_value self)
{
    GlyphInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_GlyphInfo, GlyphInfo);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->value = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_GlyphInfo_offsetX_get(mrb_state* mrb, mrb_value self)
{
    GlyphInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_GlyphInfo, GlyphInfo);
    return mrb_int_value(mrb, instance->offsetX);
}

static mrb_value mrb_raylib_GlyphInfo_offsetX_set(mrb_state* mrb, mrb_value self)
{
    GlyphInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_GlyphInfo, GlyphInfo);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->offsetX = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_GlyphInfo_offsetY_get(mrb_state* mrb, mrb_value self)
{
    GlyphInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_GlyphInfo, GlyphInfo);
    return mrb_int_value(mrb, instance->offsetY);
}

static mrb_value mrb_raylib_GlyphInfo_offsetY_set(mrb_state* mrb, mrb_value self)
{
    GlyphInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_GlyphInfo, GlyphInfo);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->offsetY = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_GlyphInfo_advanceX_get(mrb_state* mrb, mrb_value self)
{
    GlyphInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_GlyphInfo, GlyphInfo);
    return mrb_int_value(mrb, instance->advanceX);
}

static mrb_value mrb_raylib_GlyphInfo_advanceX_set(mrb_state* mrb, mrb_value self)
{
    GlyphInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_GlyphInfo, GlyphInfo);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->advanceX = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_GlyphInfo_image_get(mrb_state* mrb, mrb_value self)
{
    GlyphInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_GlyphInfo, GlyphInfo);
    return mrb_obj_value(&instance->image);
}

static mrb_value mrb_raylib_GlyphInfo_image_set(mrb_state* mrb, mrb_value self)
{
    GlyphInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_GlyphInfo, GlyphInfo);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->image = *(Image*)DATA_PTR(argv);
    return self;
}

static mrb_value mrb_raylib_Font_initialize(mrb_state* mrb, mrb_value self)
{
    Font* instance = (Font*)mrb_malloc(mrb, sizeof(Font));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(Font));
        break;
    }
    case 6:
    {
        mrb_value argv[6];
        void* ptrs[6] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], };
        mrb_get_args_a(mrb, "oooooo", ptrs);
        instance->baseSize = mrb_as_int(mrb, argv[0]);
        instance->glyphCount = mrb_as_int(mrb, argv[1]);
        instance->glyphPadding = mrb_as_int(mrb, argv[2]);
        instance->texture = *(Texture2D*)DATA_PTR(argv[3]);
        instance->recs = DATA_PTR(argv[4]);
        instance->glyphs = DATA_PTR(argv[5]);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_Font);
    return self;
}

static mrb_value mrb_raylib_Font_baseSize_get(mrb_state* mrb, mrb_value self)
{
    Font* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Font, Font);
    return mrb_int_value(mrb, instance->baseSize);
}

static mrb_value mrb_raylib_Font_baseSize_set(mrb_state* mrb, mrb_value self)
{
    Font* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Font, Font);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->baseSize = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Font_glyphCount_get(mrb_state* mrb, mrb_value self)
{
    Font* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Font, Font);
    return mrb_int_value(mrb, instance->glyphCount);
}

static mrb_value mrb_raylib_Font_glyphCount_set(mrb_state* mrb, mrb_value self)
{
    Font* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Font, Font);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->glyphCount = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Font_glyphPadding_get(mrb_state* mrb, mrb_value self)
{
    Font* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Font, Font);
    return mrb_int_value(mrb, instance->glyphPadding);
}

static mrb_value mrb_raylib_Font_glyphPadding_set(mrb_state* mrb, mrb_value self)
{
    Font* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Font, Font);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->glyphPadding = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Font_texture_get(mrb_state* mrb, mrb_value self)
{
    Font* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Font, Font);
    return mrb_obj_value(&instance->texture);
}

static mrb_value mrb_raylib_Font_texture_set(mrb_state* mrb, mrb_value self)
{
    Font* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Font, Font);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->texture = *(Texture2D*)DATA_PTR(argv);
    return self;
}

// static mrb_value mrb_raylib_Font_recs_get(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes
// static mrb_value mrb_raylib_Font_recs_set(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes

// static mrb_value mrb_raylib_Font_glyphs_get(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes
// static mrb_value mrb_raylib_Font_glyphs_set(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes

static mrb_value mrb_raylib_Camera3D_initialize(mrb_state* mrb, mrb_value self)
{
    Camera3D* instance = (Camera3D*)mrb_malloc(mrb, sizeof(Camera3D));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(Camera3D));
        break;
    }
    case 5:
    {
        mrb_value argv[5];
        void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
        mrb_get_args_a(mrb, "ooooo", ptrs);
        instance->position = *(Vector3*)DATA_PTR(argv[0]);
        instance->target = *(Vector3*)DATA_PTR(argv[1]);
        instance->up = *(Vector3*)DATA_PTR(argv[2]);
        instance->fovy = mrb_as_float(mrb, argv[3]);
        instance->projection = mrb_as_int(mrb, argv[4]);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_Camera3D);
    return self;
}

static mrb_value mrb_raylib_Camera3D_position_get(mrb_state* mrb, mrb_value self)
{
    Camera3D* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Camera3D, Camera3D);
    return mrb_obj_value(&instance->position);
}

static mrb_value mrb_raylib_Camera3D_position_set(mrb_state* mrb, mrb_value self)
{
    Camera3D* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Camera3D, Camera3D);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->position = *(Vector3*)DATA_PTR(argv);
    return self;
}

static mrb_value mrb_raylib_Camera3D_target_get(mrb_state* mrb, mrb_value self)
{
    Camera3D* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Camera3D, Camera3D);
    return mrb_obj_value(&instance->target);
}

static mrb_value mrb_raylib_Camera3D_target_set(mrb_state* mrb, mrb_value self)
{
    Camera3D* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Camera3D, Camera3D);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->target = *(Vector3*)DATA_PTR(argv);
    return self;
}

static mrb_value mrb_raylib_Camera3D_up_get(mrb_state* mrb, mrb_value self)
{
    Camera3D* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Camera3D, Camera3D);
    return mrb_obj_value(&instance->up);
}

static mrb_value mrb_raylib_Camera3D_up_set(mrb_state* mrb, mrb_value self)
{
    Camera3D* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Camera3D, Camera3D);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->up = *(Vector3*)DATA_PTR(argv);
    return self;
}

static mrb_value mrb_raylib_Camera3D_fovy_get(mrb_state* mrb, mrb_value self)
{
    Camera3D* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Camera3D, Camera3D);
    return mrb_float_value(mrb, instance->fovy);
}

static mrb_value mrb_raylib_Camera3D_fovy_set(mrb_state* mrb, mrb_value self)
{
    Camera3D* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Camera3D, Camera3D);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->fovy = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Camera3D_projection_get(mrb_state* mrb, mrb_value self)
{
    Camera3D* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Camera3D, Camera3D);
    return mrb_int_value(mrb, instance->projection);
}

static mrb_value mrb_raylib_Camera3D_projection_set(mrb_state* mrb, mrb_value self)
{
    Camera3D* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Camera3D, Camera3D);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->projection = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Camera2D_initialize(mrb_state* mrb, mrb_value self)
{
    Camera2D* instance = (Camera2D*)mrb_malloc(mrb, sizeof(Camera2D));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(Camera2D));
        break;
    }
    case 4:
    {
        mrb_value argv[4];
        void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
        mrb_get_args_a(mrb, "oooo", ptrs);
        instance->offset = *(Vector2*)DATA_PTR(argv[0]);
        instance->target = *(Vector2*)DATA_PTR(argv[1]);
        instance->rotation = mrb_as_float(mrb, argv[2]);
        instance->zoom = mrb_as_float(mrb, argv[3]);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_Camera2D);
    return self;
}

static mrb_value mrb_raylib_Camera2D_offset_get(mrb_state* mrb, mrb_value self)
{
    Camera2D* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Camera2D, Camera2D);
    return mrb_obj_value(&instance->offset);
}

static mrb_value mrb_raylib_Camera2D_offset_set(mrb_state* mrb, mrb_value self)
{
    Camera2D* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Camera2D, Camera2D);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->offset = *(Vector2*)DATA_PTR(argv);
    return self;
}

static mrb_value mrb_raylib_Camera2D_target_get(mrb_state* mrb, mrb_value self)
{
    Camera2D* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Camera2D, Camera2D);
    return mrb_obj_value(&instance->target);
}

static mrb_value mrb_raylib_Camera2D_target_set(mrb_state* mrb, mrb_value self)
{
    Camera2D* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Camera2D, Camera2D);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->target = *(Vector2*)DATA_PTR(argv);
    return self;
}

static mrb_value mrb_raylib_Camera2D_rotation_get(mrb_state* mrb, mrb_value self)
{
    Camera2D* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Camera2D, Camera2D);
    return mrb_float_value(mrb, instance->rotation);
}

static mrb_value mrb_raylib_Camera2D_rotation_set(mrb_state* mrb, mrb_value self)
{
    Camera2D* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Camera2D, Camera2D);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->rotation = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Camera2D_zoom_get(mrb_state* mrb, mrb_value self)
{
    Camera2D* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Camera2D, Camera2D);
    return mrb_float_value(mrb, instance->zoom);
}

static mrb_value mrb_raylib_Camera2D_zoom_set(mrb_state* mrb, mrb_value self)
{
    Camera2D* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Camera2D, Camera2D);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->zoom = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Mesh_initialize(mrb_state* mrb, mrb_value self)
{
    Mesh* instance = (Mesh*)mrb_malloc(mrb, sizeof(Mesh));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(Mesh));
        break;
    }
    case 15:
    {
        mrb_value argv[15];
        void* ptrs[15] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], &argv[6], &argv[7], &argv[8], &argv[9], &argv[10], &argv[11], &argv[12], &argv[13], &argv[14], };
        mrb_get_args_a(mrb, "ooooooooooooooo", ptrs);
        instance->vertexCount = mrb_as_int(mrb, argv[0]);
        instance->triangleCount = mrb_as_int(mrb, argv[1]);
        instance->vertices = DATA_PTR(argv[2]);
        instance->texcoords = DATA_PTR(argv[3]);
        instance->texcoords2 = DATA_PTR(argv[4]);
        instance->normals = DATA_PTR(argv[5]);
        instance->tangents = DATA_PTR(argv[6]);
        instance->colors = DATA_PTR(argv[7]);
        instance->indices = DATA_PTR(argv[8]);
        instance->animVertices = DATA_PTR(argv[9]);
        instance->animNormals = DATA_PTR(argv[10]);
        instance->boneIds = DATA_PTR(argv[11]);
        instance->boneWeights = DATA_PTR(argv[12]);
        instance->vaoId = mrb_as_int(mrb, argv[13]);
        instance->vboId = DATA_PTR(argv[14]);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_Mesh);
    return self;
}

static mrb_value mrb_raylib_Mesh_vertexCount_get(mrb_state* mrb, mrb_value self)
{
    Mesh* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Mesh, Mesh);
    return mrb_int_value(mrb, instance->vertexCount);
}

static mrb_value mrb_raylib_Mesh_vertexCount_set(mrb_state* mrb, mrb_value self)
{
    Mesh* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Mesh, Mesh);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->vertexCount = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Mesh_triangleCount_get(mrb_state* mrb, mrb_value self)
{
    Mesh* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Mesh, Mesh);
    return mrb_int_value(mrb, instance->triangleCount);
}

static mrb_value mrb_raylib_Mesh_triangleCount_set(mrb_state* mrb, mrb_value self)
{
    Mesh* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Mesh, Mesh);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->triangleCount = mrb_as_int(mrb, argv);
    return self;
}

// static mrb_value mrb_raylib_Mesh_vertices_get(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes
// static mrb_value mrb_raylib_Mesh_vertices_set(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes

// static mrb_value mrb_raylib_Mesh_texcoords_get(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes
// static mrb_value mrb_raylib_Mesh_texcoords_set(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes

// static mrb_value mrb_raylib_Mesh_texcoords2_get(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes
// static mrb_value mrb_raylib_Mesh_texcoords2_set(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes

// static mrb_value mrb_raylib_Mesh_normals_get(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes
// static mrb_value mrb_raylib_Mesh_normals_set(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes

// static mrb_value mrb_raylib_Mesh_tangents_get(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes
// static mrb_value mrb_raylib_Mesh_tangents_set(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes

// static mrb_value mrb_raylib_Mesh_colors_get(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes
// static mrb_value mrb_raylib_Mesh_colors_set(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes

// static mrb_value mrb_raylib_Mesh_indices_get(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes
// static mrb_value mrb_raylib_Mesh_indices_set(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes

// static mrb_value mrb_raylib_Mesh_animVertices_get(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes
// static mrb_value mrb_raylib_Mesh_animVertices_set(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes

// static mrb_value mrb_raylib_Mesh_animNormals_get(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes
// static mrb_value mrb_raylib_Mesh_animNormals_set(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes

// static mrb_value mrb_raylib_Mesh_boneIds_get(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes
// static mrb_value mrb_raylib_Mesh_boneIds_set(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes

// static mrb_value mrb_raylib_Mesh_boneWeights_get(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes
// static mrb_value mrb_raylib_Mesh_boneWeights_set(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes

static mrb_value mrb_raylib_Mesh_vaoId_get(mrb_state* mrb, mrb_value self)
{
    Mesh* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Mesh, Mesh);
    return mrb_int_value(mrb, instance->vaoId);
}

static mrb_value mrb_raylib_Mesh_vaoId_set(mrb_state* mrb, mrb_value self)
{
    Mesh* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Mesh, Mesh);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->vaoId = mrb_as_int(mrb, argv);
    return self;
}

// static mrb_value mrb_raylib_Mesh_vboId_get(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes
// static mrb_value mrb_raylib_Mesh_vboId_set(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes

static mrb_value mrb_raylib_Shader_initialize(mrb_state* mrb, mrb_value self)
{
    Shader* instance = (Shader*)mrb_malloc(mrb, sizeof(Shader));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(Shader));
        break;
    }
    case 2:
    {
        mrb_value argv[2];
        void* ptrs[2] = { &argv[0], &argv[1], };
        mrb_get_args_a(mrb, "oo", ptrs);
        instance->id = mrb_as_int(mrb, argv[0]);
        instance->locs = DATA_PTR(argv[1]);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_Shader);
    return self;
}

static mrb_value mrb_raylib_Shader_id_get(mrb_state* mrb, mrb_value self)
{
    Shader* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Shader, Shader);
    return mrb_int_value(mrb, instance->id);
}

static mrb_value mrb_raylib_Shader_id_set(mrb_state* mrb, mrb_value self)
{
    Shader* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Shader, Shader);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->id = mrb_as_int(mrb, argv);
    return self;
}

// static mrb_value mrb_raylib_Shader_locs_get(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes
// static mrb_value mrb_raylib_Shader_locs_set(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes

static mrb_value mrb_raylib_MaterialMap_initialize(mrb_state* mrb, mrb_value self)
{
    MaterialMap* instance = (MaterialMap*)mrb_malloc(mrb, sizeof(MaterialMap));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(MaterialMap));
        break;
    }
    case 3:
    {
        mrb_value argv[3];
        void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
        mrb_get_args_a(mrb, "ooo", ptrs);
        instance->texture = *(Texture2D*)DATA_PTR(argv[0]);
        instance->color = *(Color*)DATA_PTR(argv[1]);
        instance->value = mrb_as_float(mrb, argv[2]);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_MaterialMap);
    return self;
}

static mrb_value mrb_raylib_MaterialMap_texture_get(mrb_state* mrb, mrb_value self)
{
    MaterialMap* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_MaterialMap, MaterialMap);
    return mrb_obj_value(&instance->texture);
}

static mrb_value mrb_raylib_MaterialMap_texture_set(mrb_state* mrb, mrb_value self)
{
    MaterialMap* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_MaterialMap, MaterialMap);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->texture = *(Texture2D*)DATA_PTR(argv);
    return self;
}

static mrb_value mrb_raylib_MaterialMap_color_get(mrb_state* mrb, mrb_value self)
{
    MaterialMap* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_MaterialMap, MaterialMap);
    return mrb_obj_value(&instance->color);
}

static mrb_value mrb_raylib_MaterialMap_color_set(mrb_state* mrb, mrb_value self)
{
    MaterialMap* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_MaterialMap, MaterialMap);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->color = *(Color*)DATA_PTR(argv);
    return self;
}

static mrb_value mrb_raylib_MaterialMap_value_get(mrb_state* mrb, mrb_value self)
{
    MaterialMap* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_MaterialMap, MaterialMap);
    return mrb_float_value(mrb, instance->value);
}

static mrb_value mrb_raylib_MaterialMap_value_set(mrb_state* mrb, mrb_value self)
{
    MaterialMap* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_MaterialMap, MaterialMap);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->value = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Material_initialize(mrb_state* mrb, mrb_value self)
{
    Material* instance = (Material*)mrb_malloc(mrb, sizeof(Material));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(Material));
        break;
    }
    case 3:
    {
        mrb_value argv[3];
        void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
        mrb_get_args_a(mrb, "ooo", ptrs);
        instance->shader = *(Shader*)DATA_PTR(argv[0]);
        instance->maps = DATA_PTR(argv[1]);
        memcpy(instance->params, DATA_PTR(argv[2]), sizeof(float) * 4);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_Material);
    return self;
}

static mrb_value mrb_raylib_Material_shader_get(mrb_state* mrb, mrb_value self)
{
    Material* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Material, Material);
    return mrb_obj_value(&instance->shader);
}

static mrb_value mrb_raylib_Material_shader_set(mrb_state* mrb, mrb_value self)
{
    Material* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Material, Material);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->shader = *(Shader*)DATA_PTR(argv);
    return self;
}

// static mrb_value mrb_raylib_Material_maps_get(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes
// static mrb_value mrb_raylib_Material_maps_set(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes

// static mrb_value mrb_raylib_Material_params_get(mrb_state* mrb, mrb_value self); // TODO add accessor which can handle array
// static mrb_value mrb_raylib_Material_params_set(mrb_state* mrb, mrb_value self); // TODO add accessor which can handle array

static mrb_value mrb_raylib_Transform_initialize(mrb_state* mrb, mrb_value self)
{
    Transform* instance = (Transform*)mrb_malloc(mrb, sizeof(Transform));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(Transform));
        break;
    }
    case 3:
    {
        mrb_value argv[3];
        void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
        mrb_get_args_a(mrb, "ooo", ptrs);
        instance->translation = *(Vector3*)DATA_PTR(argv[0]);
        instance->rotation = *(Quaternion*)DATA_PTR(argv[1]);
        instance->scale = *(Vector3*)DATA_PTR(argv[2]);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_Transform);
    return self;
}

static mrb_value mrb_raylib_Transform_translation_get(mrb_state* mrb, mrb_value self)
{
    Transform* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Transform, Transform);
    return mrb_obj_value(&instance->translation);
}

static mrb_value mrb_raylib_Transform_translation_set(mrb_state* mrb, mrb_value self)
{
    Transform* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Transform, Transform);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->translation = *(Vector3*)DATA_PTR(argv);
    return self;
}

static mrb_value mrb_raylib_Transform_rotation_get(mrb_state* mrb, mrb_value self)
{
    Transform* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Transform, Transform);
    return mrb_obj_value(&instance->rotation);
}

static mrb_value mrb_raylib_Transform_rotation_set(mrb_state* mrb, mrb_value self)
{
    Transform* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Transform, Transform);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->rotation = *(Quaternion*)DATA_PTR(argv);
    return self;
}

static mrb_value mrb_raylib_Transform_scale_get(mrb_state* mrb, mrb_value self)
{
    Transform* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Transform, Transform);
    return mrb_obj_value(&instance->scale);
}

static mrb_value mrb_raylib_Transform_scale_set(mrb_state* mrb, mrb_value self)
{
    Transform* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Transform, Transform);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->scale = *(Vector3*)DATA_PTR(argv);
    return self;
}

static mrb_value mrb_raylib_BoneInfo_initialize(mrb_state* mrb, mrb_value self)
{
    BoneInfo* instance = (BoneInfo*)mrb_malloc(mrb, sizeof(BoneInfo));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(BoneInfo));
        break;
    }
    case 2:
    {
        mrb_value argv[2];
        void* ptrs[2] = { &argv[0], &argv[1], };
        mrb_get_args_a(mrb, "oo", ptrs);
        strncpy(instance->name, mrb_string_cstr(mrb, argv[0]), sizeof(char) * 32);
        instance->parent = mrb_as_int(mrb, argv[1]);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_BoneInfo);
    return self;
}

static mrb_value mrb_raylib_BoneInfo_name_get(mrb_state* mrb, mrb_value self)
{
    BoneInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_BoneInfo, BoneInfo);
    return mrb_str_new_cstr(mrb, (const char*)&instance->name);
}

static mrb_value mrb_raylib_BoneInfo_name_set(mrb_state* mrb, mrb_value self)
{
    BoneInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_BoneInfo, BoneInfo);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    strncpy(instance->name, mrb_string_cstr(mrb, argv), sizeof(char) * 32);
    return self;
}

static mrb_value mrb_raylib_BoneInfo_parent_get(mrb_state* mrb, mrb_value self)
{
    BoneInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_BoneInfo, BoneInfo);
    return mrb_int_value(mrb, instance->parent);
}

static mrb_value mrb_raylib_BoneInfo_parent_set(mrb_state* mrb, mrb_value self)
{
    BoneInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_BoneInfo, BoneInfo);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->parent = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Model_initialize(mrb_state* mrb, mrb_value self)
{
    Model* instance = (Model*)mrb_malloc(mrb, sizeof(Model));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(Model));
        break;
    }
    case 9:
    {
        mrb_value argv[9];
        void* ptrs[9] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], &argv[6], &argv[7], &argv[8], };
        mrb_get_args_a(mrb, "ooooooooo", ptrs);
        instance->transform = *(Matrix*)DATA_PTR(argv[0]);
        instance->meshCount = mrb_as_int(mrb, argv[1]);
        instance->materialCount = mrb_as_int(mrb, argv[2]);
        instance->meshes = DATA_PTR(argv[3]);
        instance->materials = DATA_PTR(argv[4]);
        instance->meshMaterial = DATA_PTR(argv[5]);
        instance->boneCount = mrb_as_int(mrb, argv[6]);
        instance->bones = DATA_PTR(argv[7]);
        instance->bindPose = DATA_PTR(argv[8]);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_Model);
    return self;
}

static mrb_value mrb_raylib_Model_transform_get(mrb_state* mrb, mrb_value self)
{
    Model* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Model, Model);
    return mrb_obj_value(&instance->transform);
}

static mrb_value mrb_raylib_Model_transform_set(mrb_state* mrb, mrb_value self)
{
    Model* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Model, Model);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->transform = *(Matrix*)DATA_PTR(argv);
    return self;
}

static mrb_value mrb_raylib_Model_meshCount_get(mrb_state* mrb, mrb_value self)
{
    Model* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Model, Model);
    return mrb_int_value(mrb, instance->meshCount);
}

static mrb_value mrb_raylib_Model_meshCount_set(mrb_state* mrb, mrb_value self)
{
    Model* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Model, Model);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->meshCount = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Model_materialCount_get(mrb_state* mrb, mrb_value self)
{
    Model* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Model, Model);
    return mrb_int_value(mrb, instance->materialCount);
}

static mrb_value mrb_raylib_Model_materialCount_set(mrb_state* mrb, mrb_value self)
{
    Model* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Model, Model);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->materialCount = mrb_as_int(mrb, argv);
    return self;
}

// static mrb_value mrb_raylib_Model_meshes_get(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes
// static mrb_value mrb_raylib_Model_meshes_set(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes

// static mrb_value mrb_raylib_Model_materials_get(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes
// static mrb_value mrb_raylib_Model_materials_set(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes

// static mrb_value mrb_raylib_Model_meshMaterial_get(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes
// static mrb_value mrb_raylib_Model_meshMaterial_set(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes

static mrb_value mrb_raylib_Model_boneCount_get(mrb_state* mrb, mrb_value self)
{
    Model* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Model, Model);
    return mrb_int_value(mrb, instance->boneCount);
}

static mrb_value mrb_raylib_Model_boneCount_set(mrb_state* mrb, mrb_value self)
{
    Model* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Model, Model);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->boneCount = mrb_as_int(mrb, argv);
    return self;
}

// static mrb_value mrb_raylib_Model_bones_get(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes
// static mrb_value mrb_raylib_Model_bones_set(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes

// static mrb_value mrb_raylib_Model_bindPose_get(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes
// static mrb_value mrb_raylib_Model_bindPose_set(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes

static mrb_value mrb_raylib_ModelAnimation_initialize(mrb_state* mrb, mrb_value self)
{
    ModelAnimation* instance = (ModelAnimation*)mrb_malloc(mrb, sizeof(ModelAnimation));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(ModelAnimation));
        break;
    }
    case 5:
    {
        mrb_value argv[5];
        void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
        mrb_get_args_a(mrb, "ooooo", ptrs);
        instance->boneCount = mrb_as_int(mrb, argv[0]);
        instance->frameCount = mrb_as_int(mrb, argv[1]);
        instance->bones = DATA_PTR(argv[2]);
        instance->framePoses = DATA_PTR(argv[3]);
        strncpy(instance->name, mrb_string_cstr(mrb, argv[4]), sizeof(char) * 32);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_ModelAnimation);
    return self;
}

static mrb_value mrb_raylib_ModelAnimation_boneCount_get(mrb_state* mrb, mrb_value self)
{
    ModelAnimation* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_ModelAnimation, ModelAnimation);
    return mrb_int_value(mrb, instance->boneCount);
}

static mrb_value mrb_raylib_ModelAnimation_boneCount_set(mrb_state* mrb, mrb_value self)
{
    ModelAnimation* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_ModelAnimation, ModelAnimation);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->boneCount = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_ModelAnimation_frameCount_get(mrb_state* mrb, mrb_value self)
{
    ModelAnimation* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_ModelAnimation, ModelAnimation);
    return mrb_int_value(mrb, instance->frameCount);
}

static mrb_value mrb_raylib_ModelAnimation_frameCount_set(mrb_state* mrb, mrb_value self)
{
    ModelAnimation* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_ModelAnimation, ModelAnimation);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->frameCount = mrb_as_int(mrb, argv);
    return self;
}

// static mrb_value mrb_raylib_ModelAnimation_bones_get(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes
// static mrb_value mrb_raylib_ModelAnimation_bones_set(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes

// static mrb_value mrb_raylib_ModelAnimation_framePoses_get(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes
// static mrb_value mrb_raylib_ModelAnimation_framePoses_set(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes

static mrb_value mrb_raylib_ModelAnimation_name_get(mrb_state* mrb, mrb_value self)
{
    ModelAnimation* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_ModelAnimation, ModelAnimation);
    return mrb_str_new_cstr(mrb, (const char*)&instance->name);
}

static mrb_value mrb_raylib_ModelAnimation_name_set(mrb_state* mrb, mrb_value self)
{
    ModelAnimation* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_ModelAnimation, ModelAnimation);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    strncpy(instance->name, mrb_string_cstr(mrb, argv), sizeof(char) * 32);
    return self;
}

static mrb_value mrb_raylib_Ray_initialize(mrb_state* mrb, mrb_value self)
{
    Ray* instance = (Ray*)mrb_malloc(mrb, sizeof(Ray));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(Ray));
        break;
    }
    case 2:
    {
        mrb_value argv[2];
        void* ptrs[2] = { &argv[0], &argv[1], };
        mrb_get_args_a(mrb, "oo", ptrs);
        instance->position = *(Vector3*)DATA_PTR(argv[0]);
        instance->direction = *(Vector3*)DATA_PTR(argv[1]);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_Ray);
    return self;
}

static mrb_value mrb_raylib_Ray_position_get(mrb_state* mrb, mrb_value self)
{
    Ray* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Ray, Ray);
    return mrb_obj_value(&instance->position);
}

static mrb_value mrb_raylib_Ray_position_set(mrb_state* mrb, mrb_value self)
{
    Ray* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Ray, Ray);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->position = *(Vector3*)DATA_PTR(argv);
    return self;
}

static mrb_value mrb_raylib_Ray_direction_get(mrb_state* mrb, mrb_value self)
{
    Ray* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Ray, Ray);
    return mrb_obj_value(&instance->direction);
}

static mrb_value mrb_raylib_Ray_direction_set(mrb_state* mrb, mrb_value self)
{
    Ray* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Ray, Ray);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->direction = *(Vector3*)DATA_PTR(argv);
    return self;
}

static mrb_value mrb_raylib_RayCollision_initialize(mrb_state* mrb, mrb_value self)
{
    RayCollision* instance = (RayCollision*)mrb_malloc(mrb, sizeof(RayCollision));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(RayCollision));
        break;
    }
    case 4:
    {
        mrb_value argv[4];
        void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
        mrb_get_args_a(mrb, "oooo", ptrs);
        instance->hit = mrb_as_int(mrb, argv[0]);
        instance->distance = mrb_as_float(mrb, argv[1]);
        instance->point = *(Vector3*)DATA_PTR(argv[2]);
        instance->normal = *(Vector3*)DATA_PTR(argv[3]);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_RayCollision);
    return self;
}

static mrb_value mrb_raylib_RayCollision_hit_get(mrb_state* mrb, mrb_value self)
{
    RayCollision* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_RayCollision, RayCollision);
    return mrb_int_value(mrb, instance->hit);
}

static mrb_value mrb_raylib_RayCollision_hit_set(mrb_state* mrb, mrb_value self)
{
    RayCollision* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_RayCollision, RayCollision);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->hit = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_RayCollision_distance_get(mrb_state* mrb, mrb_value self)
{
    RayCollision* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_RayCollision, RayCollision);
    return mrb_float_value(mrb, instance->distance);
}

static mrb_value mrb_raylib_RayCollision_distance_set(mrb_state* mrb, mrb_value self)
{
    RayCollision* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_RayCollision, RayCollision);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->distance = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_RayCollision_point_get(mrb_state* mrb, mrb_value self)
{
    RayCollision* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_RayCollision, RayCollision);
    return mrb_obj_value(&instance->point);
}

static mrb_value mrb_raylib_RayCollision_point_set(mrb_state* mrb, mrb_value self)
{
    RayCollision* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_RayCollision, RayCollision);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->point = *(Vector3*)DATA_PTR(argv);
    return self;
}

static mrb_value mrb_raylib_RayCollision_normal_get(mrb_state* mrb, mrb_value self)
{
    RayCollision* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_RayCollision, RayCollision);
    return mrb_obj_value(&instance->normal);
}

static mrb_value mrb_raylib_RayCollision_normal_set(mrb_state* mrb, mrb_value self)
{
    RayCollision* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_RayCollision, RayCollision);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->normal = *(Vector3*)DATA_PTR(argv);
    return self;
}

static mrb_value mrb_raylib_BoundingBox_initialize(mrb_state* mrb, mrb_value self)
{
    BoundingBox* instance = (BoundingBox*)mrb_malloc(mrb, sizeof(BoundingBox));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(BoundingBox));
        break;
    }
    case 2:
    {
        mrb_value argv[2];
        void* ptrs[2] = { &argv[0], &argv[1], };
        mrb_get_args_a(mrb, "oo", ptrs);
        instance->min = *(Vector3*)DATA_PTR(argv[0]);
        instance->max = *(Vector3*)DATA_PTR(argv[1]);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_BoundingBox);
    return self;
}

static mrb_value mrb_raylib_BoundingBox_min_get(mrb_state* mrb, mrb_value self)
{
    BoundingBox* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_BoundingBox, BoundingBox);
    return mrb_obj_value(&instance->min);
}

static mrb_value mrb_raylib_BoundingBox_min_set(mrb_state* mrb, mrb_value self)
{
    BoundingBox* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_BoundingBox, BoundingBox);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->min = *(Vector3*)DATA_PTR(argv);
    return self;
}

static mrb_value mrb_raylib_BoundingBox_max_get(mrb_state* mrb, mrb_value self)
{
    BoundingBox* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_BoundingBox, BoundingBox);
    return mrb_obj_value(&instance->max);
}

static mrb_value mrb_raylib_BoundingBox_max_set(mrb_state* mrb, mrb_value self)
{
    BoundingBox* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_BoundingBox, BoundingBox);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->max = *(Vector3*)DATA_PTR(argv);
    return self;
}

static mrb_value mrb_raylib_Wave_initialize(mrb_state* mrb, mrb_value self)
{
    Wave* instance = (Wave*)mrb_malloc(mrb, sizeof(Wave));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(Wave));
        break;
    }
    case 5:
    {
        mrb_value argv[5];
        void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
        mrb_get_args_a(mrb, "ooooo", ptrs);
        instance->frameCount = mrb_as_int(mrb, argv[0]);
        instance->sampleRate = mrb_as_int(mrb, argv[1]);
        instance->sampleSize = mrb_as_int(mrb, argv[2]);
        instance->channels = mrb_as_int(mrb, argv[3]);
        instance->data = DATA_PTR(argv[4]);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_Wave);
    return self;
}

static mrb_value mrb_raylib_Wave_frameCount_get(mrb_state* mrb, mrb_value self)
{
    Wave* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Wave, Wave);
    return mrb_int_value(mrb, instance->frameCount);
}

static mrb_value mrb_raylib_Wave_frameCount_set(mrb_state* mrb, mrb_value self)
{
    Wave* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Wave, Wave);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->frameCount = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Wave_sampleRate_get(mrb_state* mrb, mrb_value self)
{
    Wave* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Wave, Wave);
    return mrb_int_value(mrb, instance->sampleRate);
}

static mrb_value mrb_raylib_Wave_sampleRate_set(mrb_state* mrb, mrb_value self)
{
    Wave* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Wave, Wave);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->sampleRate = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Wave_sampleSize_get(mrb_state* mrb, mrb_value self)
{
    Wave* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Wave, Wave);
    return mrb_int_value(mrb, instance->sampleSize);
}

static mrb_value mrb_raylib_Wave_sampleSize_set(mrb_state* mrb, mrb_value self)
{
    Wave* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Wave, Wave);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->sampleSize = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Wave_channels_get(mrb_state* mrb, mrb_value self)
{
    Wave* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Wave, Wave);
    return mrb_int_value(mrb, instance->channels);
}

static mrb_value mrb_raylib_Wave_channels_set(mrb_state* mrb, mrb_value self)
{
    Wave* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Wave, Wave);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->channels = mrb_as_int(mrb, argv);
    return self;
}

// static mrb_value mrb_raylib_Wave_data_get(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes
// static mrb_value mrb_raylib_Wave_data_set(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes

static mrb_value mrb_raylib_AudioStream_initialize(mrb_state* mrb, mrb_value self)
{
    AudioStream* instance = (AudioStream*)mrb_malloc(mrb, sizeof(AudioStream));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(AudioStream));
        break;
    }
    case 5:
    {
        mrb_value argv[5];
        void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
        mrb_get_args_a(mrb, "ooooo", ptrs);
        instance->buffer = DATA_PTR(argv[0]);
        instance->processor = DATA_PTR(argv[1]);
        instance->sampleRate = mrb_as_int(mrb, argv[2]);
        instance->sampleSize = mrb_as_int(mrb, argv[3]);
        instance->channels = mrb_as_int(mrb, argv[4]);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_AudioStream);
    return self;
}

// static mrb_value mrb_raylib_AudioStream_buffer_get(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes
// static mrb_value mrb_raylib_AudioStream_buffer_set(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes

// static mrb_value mrb_raylib_AudioStream_processor_get(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes
// static mrb_value mrb_raylib_AudioStream_processor_set(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes

static mrb_value mrb_raylib_AudioStream_sampleRate_get(mrb_state* mrb, mrb_value self)
{
    AudioStream* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_AudioStream, AudioStream);
    return mrb_int_value(mrb, instance->sampleRate);
}

static mrb_value mrb_raylib_AudioStream_sampleRate_set(mrb_state* mrb, mrb_value self)
{
    AudioStream* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_AudioStream, AudioStream);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->sampleRate = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_AudioStream_sampleSize_get(mrb_state* mrb, mrb_value self)
{
    AudioStream* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_AudioStream, AudioStream);
    return mrb_int_value(mrb, instance->sampleSize);
}

static mrb_value mrb_raylib_AudioStream_sampleSize_set(mrb_state* mrb, mrb_value self)
{
    AudioStream* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_AudioStream, AudioStream);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->sampleSize = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_AudioStream_channels_get(mrb_state* mrb, mrb_value self)
{
    AudioStream* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_AudioStream, AudioStream);
    return mrb_int_value(mrb, instance->channels);
}

static mrb_value mrb_raylib_AudioStream_channels_set(mrb_state* mrb, mrb_value self)
{
    AudioStream* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_AudioStream, AudioStream);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->channels = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Sound_initialize(mrb_state* mrb, mrb_value self)
{
    Sound* instance = (Sound*)mrb_malloc(mrb, sizeof(Sound));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(Sound));
        break;
    }
    case 2:
    {
        mrb_value argv[2];
        void* ptrs[2] = { &argv[0], &argv[1], };
        mrb_get_args_a(mrb, "oo", ptrs);
        instance->stream = *(AudioStream*)DATA_PTR(argv[0]);
        instance->frameCount = mrb_as_int(mrb, argv[1]);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_Sound);
    return self;
}

static mrb_value mrb_raylib_Sound_stream_get(mrb_state* mrb, mrb_value self)
{
    Sound* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Sound, Sound);
    return mrb_obj_value(&instance->stream);
}

static mrb_value mrb_raylib_Sound_stream_set(mrb_state* mrb, mrb_value self)
{
    Sound* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Sound, Sound);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->stream = *(AudioStream*)DATA_PTR(argv);
    return self;
}

static mrb_value mrb_raylib_Sound_frameCount_get(mrb_state* mrb, mrb_value self)
{
    Sound* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Sound, Sound);
    return mrb_int_value(mrb, instance->frameCount);
}

static mrb_value mrb_raylib_Sound_frameCount_set(mrb_state* mrb, mrb_value self)
{
    Sound* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Sound, Sound);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->frameCount = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Music_initialize(mrb_state* mrb, mrb_value self)
{
    Music* instance = (Music*)mrb_malloc(mrb, sizeof(Music));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(Music));
        break;
    }
    case 5:
    {
        mrb_value argv[5];
        void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
        mrb_get_args_a(mrb, "ooooo", ptrs);
        instance->stream = *(AudioStream*)DATA_PTR(argv[0]);
        instance->frameCount = mrb_as_int(mrb, argv[1]);
        instance->looping = mrb_as_int(mrb, argv[2]);
        instance->ctxType = mrb_as_int(mrb, argv[3]);
        instance->ctxData = DATA_PTR(argv[4]);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_Music);
    return self;
}

static mrb_value mrb_raylib_Music_stream_get(mrb_state* mrb, mrb_value self)
{
    Music* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Music, Music);
    return mrb_obj_value(&instance->stream);
}

static mrb_value mrb_raylib_Music_stream_set(mrb_state* mrb, mrb_value self)
{
    Music* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Music, Music);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->stream = *(AudioStream*)DATA_PTR(argv);
    return self;
}

static mrb_value mrb_raylib_Music_frameCount_get(mrb_state* mrb, mrb_value self)
{
    Music* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Music, Music);
    return mrb_int_value(mrb, instance->frameCount);
}

static mrb_value mrb_raylib_Music_frameCount_set(mrb_state* mrb, mrb_value self)
{
    Music* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Music, Music);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->frameCount = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Music_looping_get(mrb_state* mrb, mrb_value self)
{
    Music* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Music, Music);
    return mrb_int_value(mrb, instance->looping);
}

static mrb_value mrb_raylib_Music_looping_set(mrb_state* mrb, mrb_value self)
{
    Music* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Music, Music);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->looping = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_Music_ctxType_get(mrb_state* mrb, mrb_value self)
{
    Music* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Music, Music);
    return mrb_int_value(mrb, instance->ctxType);
}

static mrb_value mrb_raylib_Music_ctxType_set(mrb_state* mrb, mrb_value self)
{
    Music* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_Music, Music);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->ctxType = mrb_as_int(mrb, argv);
    return self;
}

// static mrb_value mrb_raylib_Music_ctxData_get(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes
// static mrb_value mrb_raylib_Music_ctxData_set(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes

static mrb_value mrb_raylib_VrDeviceInfo_initialize(mrb_state* mrb, mrb_value self)
{
    VrDeviceInfo* instance = (VrDeviceInfo*)mrb_malloc(mrb, sizeof(VrDeviceInfo));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(VrDeviceInfo));
        break;
    }
    case 10:
    {
        mrb_value argv[10];
        void* ptrs[10] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], &argv[6], &argv[7], &argv[8], &argv[9], };
        mrb_get_args_a(mrb, "oooooooooo", ptrs);
        instance->hResolution = mrb_as_int(mrb, argv[0]);
        instance->vResolution = mrb_as_int(mrb, argv[1]);
        instance->hScreenSize = mrb_as_float(mrb, argv[2]);
        instance->vScreenSize = mrb_as_float(mrb, argv[3]);
        instance->vScreenCenter = mrb_as_float(mrb, argv[4]);
        instance->eyeToScreenDistance = mrb_as_float(mrb, argv[5]);
        instance->lensSeparationDistance = mrb_as_float(mrb, argv[6]);
        instance->interpupillaryDistance = mrb_as_float(mrb, argv[7]);
        memcpy(instance->lensDistortionValues, DATA_PTR(argv[8]), sizeof(float) * 4);
        memcpy(instance->chromaAbCorrection, DATA_PTR(argv[9]), sizeof(float) * 4);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_VrDeviceInfo);
    return self;
}

static mrb_value mrb_raylib_VrDeviceInfo_hResolution_get(mrb_state* mrb, mrb_value self)
{
    VrDeviceInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_VrDeviceInfo, VrDeviceInfo);
    return mrb_int_value(mrb, instance->hResolution);
}

static mrb_value mrb_raylib_VrDeviceInfo_hResolution_set(mrb_state* mrb, mrb_value self)
{
    VrDeviceInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_VrDeviceInfo, VrDeviceInfo);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->hResolution = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_VrDeviceInfo_vResolution_get(mrb_state* mrb, mrb_value self)
{
    VrDeviceInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_VrDeviceInfo, VrDeviceInfo);
    return mrb_int_value(mrb, instance->vResolution);
}

static mrb_value mrb_raylib_VrDeviceInfo_vResolution_set(mrb_state* mrb, mrb_value self)
{
    VrDeviceInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_VrDeviceInfo, VrDeviceInfo);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->vResolution = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_VrDeviceInfo_hScreenSize_get(mrb_state* mrb, mrb_value self)
{
    VrDeviceInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_VrDeviceInfo, VrDeviceInfo);
    return mrb_float_value(mrb, instance->hScreenSize);
}

static mrb_value mrb_raylib_VrDeviceInfo_hScreenSize_set(mrb_state* mrb, mrb_value self)
{
    VrDeviceInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_VrDeviceInfo, VrDeviceInfo);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->hScreenSize = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_VrDeviceInfo_vScreenSize_get(mrb_state* mrb, mrb_value self)
{
    VrDeviceInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_VrDeviceInfo, VrDeviceInfo);
    return mrb_float_value(mrb, instance->vScreenSize);
}

static mrb_value mrb_raylib_VrDeviceInfo_vScreenSize_set(mrb_state* mrb, mrb_value self)
{
    VrDeviceInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_VrDeviceInfo, VrDeviceInfo);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->vScreenSize = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_VrDeviceInfo_vScreenCenter_get(mrb_state* mrb, mrb_value self)
{
    VrDeviceInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_VrDeviceInfo, VrDeviceInfo);
    return mrb_float_value(mrb, instance->vScreenCenter);
}

static mrb_value mrb_raylib_VrDeviceInfo_vScreenCenter_set(mrb_state* mrb, mrb_value self)
{
    VrDeviceInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_VrDeviceInfo, VrDeviceInfo);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->vScreenCenter = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_VrDeviceInfo_eyeToScreenDistance_get(mrb_state* mrb, mrb_value self)
{
    VrDeviceInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_VrDeviceInfo, VrDeviceInfo);
    return mrb_float_value(mrb, instance->eyeToScreenDistance);
}

static mrb_value mrb_raylib_VrDeviceInfo_eyeToScreenDistance_set(mrb_state* mrb, mrb_value self)
{
    VrDeviceInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_VrDeviceInfo, VrDeviceInfo);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->eyeToScreenDistance = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_VrDeviceInfo_lensSeparationDistance_get(mrb_state* mrb, mrb_value self)
{
    VrDeviceInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_VrDeviceInfo, VrDeviceInfo);
    return mrb_float_value(mrb, instance->lensSeparationDistance);
}

static mrb_value mrb_raylib_VrDeviceInfo_lensSeparationDistance_set(mrb_state* mrb, mrb_value self)
{
    VrDeviceInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_VrDeviceInfo, VrDeviceInfo);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->lensSeparationDistance = mrb_as_float(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_VrDeviceInfo_interpupillaryDistance_get(mrb_state* mrb, mrb_value self)
{
    VrDeviceInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_VrDeviceInfo, VrDeviceInfo);
    return mrb_float_value(mrb, instance->interpupillaryDistance);
}

static mrb_value mrb_raylib_VrDeviceInfo_interpupillaryDistance_set(mrb_state* mrb, mrb_value self)
{
    VrDeviceInfo* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_VrDeviceInfo, VrDeviceInfo);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->interpupillaryDistance = mrb_as_float(mrb, argv);
    return self;
}

// static mrb_value mrb_raylib_VrDeviceInfo_lensDistortionValues_get(mrb_state* mrb, mrb_value self); // TODO add accessor which can handle array
// static mrb_value mrb_raylib_VrDeviceInfo_lensDistortionValues_set(mrb_state* mrb, mrb_value self); // TODO add accessor which can handle array

// static mrb_value mrb_raylib_VrDeviceInfo_chromaAbCorrection_get(mrb_state* mrb, mrb_value self); // TODO add accessor which can handle array
// static mrb_value mrb_raylib_VrDeviceInfo_chromaAbCorrection_set(mrb_state* mrb, mrb_value self); // TODO add accessor which can handle array

static mrb_value mrb_raylib_VrStereoConfig_initialize(mrb_state* mrb, mrb_value self)
{
    VrStereoConfig* instance = (VrStereoConfig*)mrb_malloc(mrb, sizeof(VrStereoConfig));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(VrStereoConfig));
        break;
    }
    case 8:
    {
        mrb_value argv[8];
        void* ptrs[8] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], &argv[6], &argv[7], };
        mrb_get_args_a(mrb, "oooooooo", ptrs);
        memcpy(instance->projection, DATA_PTR(argv[0]), sizeof(Matrix) * 2);
        memcpy(instance->viewOffset, DATA_PTR(argv[1]), sizeof(Matrix) * 2);
        memcpy(instance->leftLensCenter, DATA_PTR(argv[2]), sizeof(float) * 2);
        memcpy(instance->rightLensCenter, DATA_PTR(argv[3]), sizeof(float) * 2);
        memcpy(instance->leftScreenCenter, DATA_PTR(argv[4]), sizeof(float) * 2);
        memcpy(instance->rightScreenCenter, DATA_PTR(argv[5]), sizeof(float) * 2);
        memcpy(instance->scale, DATA_PTR(argv[6]), sizeof(float) * 2);
        memcpy(instance->scaleIn, DATA_PTR(argv[7]), sizeof(float) * 2);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_VrStereoConfig);
    return self;
}

// static mrb_value mrb_raylib_VrStereoConfig_projection_get(mrb_state* mrb, mrb_value self); // TODO add accessor which can handle array
// static mrb_value mrb_raylib_VrStereoConfig_projection_set(mrb_state* mrb, mrb_value self); // TODO add accessor which can handle array

// static mrb_value mrb_raylib_VrStereoConfig_viewOffset_get(mrb_state* mrb, mrb_value self); // TODO add accessor which can handle array
// static mrb_value mrb_raylib_VrStereoConfig_viewOffset_set(mrb_state* mrb, mrb_value self); // TODO add accessor which can handle array

// static mrb_value mrb_raylib_VrStereoConfig_leftLensCenter_get(mrb_state* mrb, mrb_value self); // TODO add accessor which can handle array
// static mrb_value mrb_raylib_VrStereoConfig_leftLensCenter_set(mrb_state* mrb, mrb_value self); // TODO add accessor which can handle array

// static mrb_value mrb_raylib_VrStereoConfig_rightLensCenter_get(mrb_state* mrb, mrb_value self); // TODO add accessor which can handle array
// static mrb_value mrb_raylib_VrStereoConfig_rightLensCenter_set(mrb_state* mrb, mrb_value self); // TODO add accessor which can handle array

// static mrb_value mrb_raylib_VrStereoConfig_leftScreenCenter_get(mrb_state* mrb, mrb_value self); // TODO add accessor which can handle array
// static mrb_value mrb_raylib_VrStereoConfig_leftScreenCenter_set(mrb_state* mrb, mrb_value self); // TODO add accessor which can handle array

// static mrb_value mrb_raylib_VrStereoConfig_rightScreenCenter_get(mrb_state* mrb, mrb_value self); // TODO add accessor which can handle array
// static mrb_value mrb_raylib_VrStereoConfig_rightScreenCenter_set(mrb_state* mrb, mrb_value self); // TODO add accessor which can handle array

// static mrb_value mrb_raylib_VrStereoConfig_scale_get(mrb_state* mrb, mrb_value self); // TODO add accessor which can handle array
// static mrb_value mrb_raylib_VrStereoConfig_scale_set(mrb_state* mrb, mrb_value self); // TODO add accessor which can handle array

// static mrb_value mrb_raylib_VrStereoConfig_scaleIn_get(mrb_state* mrb, mrb_value self); // TODO add accessor which can handle array
// static mrb_value mrb_raylib_VrStereoConfig_scaleIn_set(mrb_state* mrb, mrb_value self); // TODO add accessor which can handle array

static mrb_value mrb_raylib_FilePathList_initialize(mrb_state* mrb, mrb_value self)
{
    FilePathList* instance = (FilePathList*)mrb_malloc(mrb, sizeof(FilePathList));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(FilePathList));
        break;
    }
    case 3:
    {
        mrb_value argv[3];
        void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
        mrb_get_args_a(mrb, "ooo", ptrs);
        instance->capacity = mrb_as_int(mrb, argv[0]);
        instance->count = mrb_as_int(mrb, argv[1]);
        instance->paths = DATA_PTR(argv[2]);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_FilePathList);
    return self;
}

static mrb_value mrb_raylib_FilePathList_capacity_get(mrb_state* mrb, mrb_value self)
{
    FilePathList* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_FilePathList, FilePathList);
    return mrb_int_value(mrb, instance->capacity);
}

static mrb_value mrb_raylib_FilePathList_capacity_set(mrb_state* mrb, mrb_value self)
{
    FilePathList* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_FilePathList, FilePathList);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->capacity = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_FilePathList_count_get(mrb_state* mrb, mrb_value self)
{
    FilePathList* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_FilePathList, FilePathList);
    return mrb_int_value(mrb, instance->count);
}

static mrb_value mrb_raylib_FilePathList_count_set(mrb_state* mrb, mrb_value self)
{
    FilePathList* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_FilePathList, FilePathList);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->count = mrb_as_int(mrb, argv);
    return self;
}

// static mrb_value mrb_raylib_FilePathList_paths_get(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes
// static mrb_value mrb_raylib_FilePathList_paths_set(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes

static mrb_value mrb_raylib_AutomationEvent_initialize(mrb_state* mrb, mrb_value self)
{
    AutomationEvent* instance = (AutomationEvent*)mrb_malloc(mrb, sizeof(AutomationEvent));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(AutomationEvent));
        break;
    }
    case 3:
    {
        mrb_value argv[3];
        void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
        mrb_get_args_a(mrb, "ooo", ptrs);
        instance->frame = mrb_as_int(mrb, argv[0]);
        instance->type = mrb_as_int(mrb, argv[1]);
        memcpy(instance->params, DATA_PTR(argv[2]), sizeof(int) * 4);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_AutomationEvent);
    return self;
}

static mrb_value mrb_raylib_AutomationEvent_frame_get(mrb_state* mrb, mrb_value self)
{
    AutomationEvent* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_AutomationEvent, AutomationEvent);
    return mrb_int_value(mrb, instance->frame);
}

static mrb_value mrb_raylib_AutomationEvent_frame_set(mrb_state* mrb, mrb_value self)
{
    AutomationEvent* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_AutomationEvent, AutomationEvent);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->frame = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_AutomationEvent_type_get(mrb_state* mrb, mrb_value self)
{
    AutomationEvent* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_AutomationEvent, AutomationEvent);
    return mrb_int_value(mrb, instance->type);
}

static mrb_value mrb_raylib_AutomationEvent_type_set(mrb_state* mrb, mrb_value self)
{
    AutomationEvent* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_AutomationEvent, AutomationEvent);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->type = mrb_as_int(mrb, argv);
    return self;
}

// static mrb_value mrb_raylib_AutomationEvent_params_get(mrb_state* mrb, mrb_value self); // TODO add accessor which can handle array
// static mrb_value mrb_raylib_AutomationEvent_params_set(mrb_state* mrb, mrb_value self); // TODO add accessor which can handle array

static mrb_value mrb_raylib_AutomationEventList_initialize(mrb_state* mrb, mrb_value self)
{
    AutomationEventList* instance = (AutomationEventList*)mrb_malloc(mrb, sizeof(AutomationEventList));
    mrb_int argc = mrb_get_argc(mrb);
    switch (argc) {
    case 0:
    {
        memset(instance, 0, sizeof(AutomationEventList));
        break;
    }
    case 3:
    {
        mrb_value argv[3];
        void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
        mrb_get_args_a(mrb, "ooo", ptrs);
        instance->capacity = mrb_as_int(mrb, argv[0]);
        instance->count = mrb_as_int(mrb, argv[1]);
        instance->events = DATA_PTR(argv[2]);
    }
    break;
    }
    mrb_data_init(self, instance, &mrb_raylib_struct_AutomationEventList);
    return self;
}

static mrb_value mrb_raylib_AutomationEventList_capacity_get(mrb_state* mrb, mrb_value self)
{
    AutomationEventList* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_AutomationEventList, AutomationEventList);
    return mrb_int_value(mrb, instance->capacity);
}

static mrb_value mrb_raylib_AutomationEventList_capacity_set(mrb_state* mrb, mrb_value self)
{
    AutomationEventList* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_AutomationEventList, AutomationEventList);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->capacity = mrb_as_int(mrb, argv);
    return self;
}

static mrb_value mrb_raylib_AutomationEventList_count_get(mrb_state* mrb, mrb_value self)
{
    AutomationEventList* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_AutomationEventList, AutomationEventList);
    return mrb_int_value(mrb, instance->count);
}

static mrb_value mrb_raylib_AutomationEventList_count_set(mrb_state* mrb, mrb_value self)
{
    AutomationEventList* instance = DATA_GET_PTR(mrb, self, &mrb_raylib_struct_AutomationEventList, AutomationEventList);
    mrb_value argv;
    mrb_get_args(mrb, "o", &argv);
    instance->count = mrb_as_int(mrb, argv);
    return self;
}

// static mrb_value mrb_raylib_AutomationEventList_events_get(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes
// static mrb_value mrb_raylib_AutomationEventList_events_set(mrb_state* mrb, mrb_value self); // TODO prepare Buffer version of classes


// Function

static mrb_value mrb_raylib_InitWindow(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    int width = mrb_as_int(mrb, argv[0]);
    int height = mrb_as_int(mrb, argv[1]);
    const char * title = DATA_PTR(argv[2]);

    InitWindow(width, height, title);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_CloseWindow(mrb_state* mrb, mrb_value self)
{
    CloseWindow();

    return mrb_nil_value();
}

static mrb_value mrb_raylib_WindowShouldClose(mrb_state* mrb, mrb_value self)
{
    bool retval = WindowShouldClose();

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_IsWindowReady(mrb_state* mrb, mrb_value self)
{
    bool retval = IsWindowReady();

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_IsWindowFullscreen(mrb_state* mrb, mrb_value self)
{
    bool retval = IsWindowFullscreen();

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_IsWindowHidden(mrb_state* mrb, mrb_value self)
{
    bool retval = IsWindowHidden();

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_IsWindowMinimized(mrb_state* mrb, mrb_value self)
{
    bool retval = IsWindowMinimized();

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_IsWindowMaximized(mrb_state* mrb, mrb_value self)
{
    bool retval = IsWindowMaximized();

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_IsWindowFocused(mrb_state* mrb, mrb_value self)
{
    bool retval = IsWindowFocused();

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_IsWindowResized(mrb_state* mrb, mrb_value self)
{
    bool retval = IsWindowResized();

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_IsWindowState(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    unsigned int flag = mrb_as_int(mrb, argv[0]);

    bool retval = IsWindowState(flag);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_SetWindowState(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    unsigned int flags = mrb_as_int(mrb, argv[0]);

    SetWindowState(flags);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ClearWindowState(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    unsigned int flags = mrb_as_int(mrb, argv[0]);

    ClearWindowState(flags);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ToggleFullscreen(mrb_state* mrb, mrb_value self)
{
    ToggleFullscreen();

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ToggleBorderlessWindowed(mrb_state* mrb, mrb_value self)
{
    ToggleBorderlessWindowed();

    return mrb_nil_value();
}

static mrb_value mrb_raylib_MaximizeWindow(mrb_state* mrb, mrb_value self)
{
    MaximizeWindow();

    return mrb_nil_value();
}

static mrb_value mrb_raylib_MinimizeWindow(mrb_state* mrb, mrb_value self)
{
    MinimizeWindow();

    return mrb_nil_value();
}

static mrb_value mrb_raylib_RestoreWindow(mrb_state* mrb, mrb_value self)
{
    RestoreWindow();

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetWindowIcon(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Image image = *(Image*)DATA_PTR(argv[0]);

    SetWindowIcon(image);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetWindowIcons(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Image * images = DATA_PTR(argv[0]);
    int count = mrb_as_int(mrb, argv[1]);

    SetWindowIcons(images, count);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetWindowTitle(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * title = DATA_PTR(argv[0]);

    SetWindowTitle(title);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetWindowPosition(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    int x = mrb_as_int(mrb, argv[0]);
    int y = mrb_as_int(mrb, argv[1]);

    SetWindowPosition(x, y);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetWindowMonitor(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    int monitor = mrb_as_int(mrb, argv[0]);

    SetWindowMonitor(monitor);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetWindowMinSize(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    int width = mrb_as_int(mrb, argv[0]);
    int height = mrb_as_int(mrb, argv[1]);

    SetWindowMinSize(width, height);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetWindowMaxSize(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    int width = mrb_as_int(mrb, argv[0]);
    int height = mrb_as_int(mrb, argv[1]);

    SetWindowMaxSize(width, height);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetWindowSize(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    int width = mrb_as_int(mrb, argv[0]);
    int height = mrb_as_int(mrb, argv[1]);

    SetWindowSize(width, height);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetWindowOpacity(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    float opacity = mrb_as_float(mrb, argv[0]);

    SetWindowOpacity(opacity);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetWindowFocused(mrb_state* mrb, mrb_value self)
{
    SetWindowFocused();

    return mrb_nil_value();
}

static mrb_value mrb_raylib_GetWindowHandle(mrb_state* mrb, mrb_value self)
{
    void * retval = GetWindowHandle();

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_GetScreenWidth(mrb_state* mrb, mrb_value self)
{
    int retval = GetScreenWidth();

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_GetScreenHeight(mrb_state* mrb, mrb_value self)
{
    int retval = GetScreenHeight();

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_GetRenderWidth(mrb_state* mrb, mrb_value self)
{
    int retval = GetRenderWidth();

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_GetRenderHeight(mrb_state* mrb, mrb_value self)
{
    int retval = GetRenderHeight();

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_GetMonitorCount(mrb_state* mrb, mrb_value self)
{
    int retval = GetMonitorCount();

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_GetCurrentMonitor(mrb_state* mrb, mrb_value self)
{
    int retval = GetCurrentMonitor();

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_GetMonitorPosition(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    int monitor = mrb_as_int(mrb, argv[0]);

    Vector2* retval = (Vector2*)mrb_malloc(mrb, sizeof(Vector2));
    *retval = GetMonitorPosition(monitor); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibVector2, &mrb_raylib_struct_Vector2, retval));
}

static mrb_value mrb_raylib_GetMonitorWidth(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    int monitor = mrb_as_int(mrb, argv[0]);

    int retval = GetMonitorWidth(monitor);

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_GetMonitorHeight(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    int monitor = mrb_as_int(mrb, argv[0]);

    int retval = GetMonitorHeight(monitor);

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_GetMonitorPhysicalWidth(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    int monitor = mrb_as_int(mrb, argv[0]);

    int retval = GetMonitorPhysicalWidth(monitor);

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_GetMonitorPhysicalHeight(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    int monitor = mrb_as_int(mrb, argv[0]);

    int retval = GetMonitorPhysicalHeight(monitor);

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_GetMonitorRefreshRate(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    int monitor = mrb_as_int(mrb, argv[0]);

    int retval = GetMonitorRefreshRate(monitor);

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_GetWindowPosition(mrb_state* mrb, mrb_value self)
{
    Vector2* retval = (Vector2*)mrb_malloc(mrb, sizeof(Vector2));
    *retval = GetWindowPosition(); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibVector2, &mrb_raylib_struct_Vector2, retval));
}

static mrb_value mrb_raylib_GetWindowScaleDPI(mrb_state* mrb, mrb_value self)
{
    Vector2* retval = (Vector2*)mrb_malloc(mrb, sizeof(Vector2));
    *retval = GetWindowScaleDPI(); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibVector2, &mrb_raylib_struct_Vector2, retval));
}

static mrb_value mrb_raylib_GetMonitorName(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    int monitor = mrb_as_int(mrb, argv[0]);

    const char * retval = GetMonitorName(monitor);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_SetClipboardText(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * text = DATA_PTR(argv[0]);

    SetClipboardText(text);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_GetClipboardText(mrb_state* mrb, mrb_value self)
{
    const char * retval = GetClipboardText();

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_EnableEventWaiting(mrb_state* mrb, mrb_value self)
{
    EnableEventWaiting();

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DisableEventWaiting(mrb_state* mrb, mrb_value self)
{
    DisableEventWaiting();

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ShowCursor(mrb_state* mrb, mrb_value self)
{
    ShowCursor();

    return mrb_nil_value();
}

static mrb_value mrb_raylib_HideCursor(mrb_state* mrb, mrb_value self)
{
    HideCursor();

    return mrb_nil_value();
}

static mrb_value mrb_raylib_IsCursorHidden(mrb_state* mrb, mrb_value self)
{
    bool retval = IsCursorHidden();

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_EnableCursor(mrb_state* mrb, mrb_value self)
{
    EnableCursor();

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DisableCursor(mrb_state* mrb, mrb_value self)
{
    DisableCursor();

    return mrb_nil_value();
}

static mrb_value mrb_raylib_IsCursorOnScreen(mrb_state* mrb, mrb_value self)
{
    bool retval = IsCursorOnScreen();

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_ClearBackground(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Color color = *(Color*)DATA_PTR(argv[0]);

    ClearBackground(color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_BeginDrawing(mrb_state* mrb, mrb_value self)
{
    BeginDrawing();

    return mrb_nil_value();
}

static mrb_value mrb_raylib_EndDrawing(mrb_state* mrb, mrb_value self)
{
    EndDrawing();

    return mrb_nil_value();
}

static mrb_value mrb_raylib_BeginMode2D(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Camera2D camera = *(Camera2D*)DATA_PTR(argv[0]);

    BeginMode2D(camera);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_EndMode2D(mrb_state* mrb, mrb_value self)
{
    EndMode2D();

    return mrb_nil_value();
}

static mrb_value mrb_raylib_BeginMode3D(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Camera3D camera = *(Camera3D*)DATA_PTR(argv[0]);

    BeginMode3D(camera);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_EndMode3D(mrb_state* mrb, mrb_value self)
{
    EndMode3D();

    return mrb_nil_value();
}

static mrb_value mrb_raylib_BeginTextureMode(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    RenderTexture2D target = *(RenderTexture2D*)DATA_PTR(argv[0]);

    BeginTextureMode(target);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_EndTextureMode(mrb_state* mrb, mrb_value self)
{
    EndTextureMode();

    return mrb_nil_value();
}

static mrb_value mrb_raylib_BeginShaderMode(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Shader shader = *(Shader*)DATA_PTR(argv[0]);

    BeginShaderMode(shader);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_EndShaderMode(mrb_state* mrb, mrb_value self)
{
    EndShaderMode();

    return mrb_nil_value();
}

static mrb_value mrb_raylib_BeginBlendMode(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    int mode = mrb_as_int(mrb, argv[0]);

    BeginBlendMode(mode);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_EndBlendMode(mrb_state* mrb, mrb_value self)
{
    EndBlendMode();

    return mrb_nil_value();
}

static mrb_value mrb_raylib_BeginScissorMode(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    int x = mrb_as_int(mrb, argv[0]);
    int y = mrb_as_int(mrb, argv[1]);
    int width = mrb_as_int(mrb, argv[2]);
    int height = mrb_as_int(mrb, argv[3]);

    BeginScissorMode(x, y, width, height);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_EndScissorMode(mrb_state* mrb, mrb_value self)
{
    EndScissorMode();

    return mrb_nil_value();
}

static mrb_value mrb_raylib_BeginVrStereoMode(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    VrStereoConfig config = *(VrStereoConfig*)DATA_PTR(argv[0]);

    BeginVrStereoMode(config);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_EndVrStereoMode(mrb_state* mrb, mrb_value self)
{
    EndVrStereoMode();

    return mrb_nil_value();
}

static mrb_value mrb_raylib_LoadVrStereoConfig(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    VrDeviceInfo device = *(VrDeviceInfo*)DATA_PTR(argv[0]);

    VrStereoConfig* retval = (VrStereoConfig*)mrb_malloc(mrb, sizeof(VrStereoConfig));
    *retval = LoadVrStereoConfig(device); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibVrStereoConfig, &mrb_raylib_struct_VrStereoConfig, retval));
}

static mrb_value mrb_raylib_UnloadVrStereoConfig(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    VrStereoConfig config = *(VrStereoConfig*)DATA_PTR(argv[0]);

    UnloadVrStereoConfig(config);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_LoadShader(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    const char * vsFileName = DATA_PTR(argv[0]);
    const char * fsFileName = DATA_PTR(argv[1]);

    Shader* retval = (Shader*)mrb_malloc(mrb, sizeof(Shader));
    *retval = LoadShader(vsFileName, fsFileName); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibShader, &mrb_raylib_struct_Shader, retval));
}

static mrb_value mrb_raylib_LoadShaderFromMemory(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    const char * vsCode = DATA_PTR(argv[0]);
    const char * fsCode = DATA_PTR(argv[1]);

    Shader* retval = (Shader*)mrb_malloc(mrb, sizeof(Shader));
    *retval = LoadShaderFromMemory(vsCode, fsCode); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibShader, &mrb_raylib_struct_Shader, retval));
}

static mrb_value mrb_raylib_IsShaderReady(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Shader shader = *(Shader*)DATA_PTR(argv[0]);

    bool retval = IsShaderReady(shader);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_GetShaderLocation(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Shader shader = *(Shader*)DATA_PTR(argv[0]);
    const char * uniformName = DATA_PTR(argv[1]);

    int retval = GetShaderLocation(shader, uniformName);

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_GetShaderLocationAttrib(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Shader shader = *(Shader*)DATA_PTR(argv[0]);
    const char * attribName = DATA_PTR(argv[1]);

    int retval = GetShaderLocationAttrib(shader, attribName);

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_SetShaderValue(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    Shader shader = *(Shader*)DATA_PTR(argv[0]);
    int locIndex = mrb_as_int(mrb, argv[1]);
    const void * value = DATA_PTR(argv[2]);
    int uniformType = mrb_as_int(mrb, argv[3]);

    SetShaderValue(shader, locIndex, value, uniformType);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetShaderValueV(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    Shader shader = *(Shader*)DATA_PTR(argv[0]);
    int locIndex = mrb_as_int(mrb, argv[1]);
    const void * value = DATA_PTR(argv[2]);
    int uniformType = mrb_as_int(mrb, argv[3]);
    int count = mrb_as_int(mrb, argv[4]);

    SetShaderValueV(shader, locIndex, value, uniformType, count);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetShaderValueMatrix(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Shader shader = *(Shader*)DATA_PTR(argv[0]);
    int locIndex = mrb_as_int(mrb, argv[1]);
    Matrix mat = *(Matrix*)DATA_PTR(argv[2]);

    SetShaderValueMatrix(shader, locIndex, mat);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetShaderValueTexture(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Shader shader = *(Shader*)DATA_PTR(argv[0]);
    int locIndex = mrb_as_int(mrb, argv[1]);
    Texture2D texture = *(Texture2D*)DATA_PTR(argv[2]);

    SetShaderValueTexture(shader, locIndex, texture);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_UnloadShader(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Shader shader = *(Shader*)DATA_PTR(argv[0]);

    UnloadShader(shader);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_GetMouseRay(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Vector2 mousePosition = *(Vector2*)DATA_PTR(argv[0]);
    Camera camera = *(Camera*)DATA_PTR(argv[1]);

    Ray* retval = (Ray*)mrb_malloc(mrb, sizeof(Ray));
    *retval = GetMouseRay(mousePosition, camera); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibRay, &mrb_raylib_struct_Ray, retval));
}

static mrb_value mrb_raylib_GetCameraMatrix(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Camera camera = *(Camera*)DATA_PTR(argv[0]);

    Matrix* retval = (Matrix*)mrb_malloc(mrb, sizeof(Matrix));
    *retval = GetCameraMatrix(camera); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibMatrix, &mrb_raylib_struct_Matrix, retval));
}

static mrb_value mrb_raylib_GetCameraMatrix2D(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Camera2D camera = *(Camera2D*)DATA_PTR(argv[0]);

    Matrix* retval = (Matrix*)mrb_malloc(mrb, sizeof(Matrix));
    *retval = GetCameraMatrix2D(camera); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibMatrix, &mrb_raylib_struct_Matrix, retval));
}

static mrb_value mrb_raylib_GetWorldToScreen(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Vector3 position = *(Vector3*)DATA_PTR(argv[0]);
    Camera camera = *(Camera*)DATA_PTR(argv[1]);

    Vector2* retval = (Vector2*)mrb_malloc(mrb, sizeof(Vector2));
    *retval = GetWorldToScreen(position, camera); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibVector2, &mrb_raylib_struct_Vector2, retval));
}

static mrb_value mrb_raylib_GetScreenToWorld2D(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Vector2 position = *(Vector2*)DATA_PTR(argv[0]);
    Camera2D camera = *(Camera2D*)DATA_PTR(argv[1]);

    Vector2* retval = (Vector2*)mrb_malloc(mrb, sizeof(Vector2));
    *retval = GetScreenToWorld2D(position, camera); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibVector2, &mrb_raylib_struct_Vector2, retval));
}

static mrb_value mrb_raylib_GetWorldToScreenEx(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    Vector3 position = *(Vector3*)DATA_PTR(argv[0]);
    Camera camera = *(Camera*)DATA_PTR(argv[1]);
    int width = mrb_as_int(mrb, argv[2]);
    int height = mrb_as_int(mrb, argv[3]);

    Vector2* retval = (Vector2*)mrb_malloc(mrb, sizeof(Vector2));
    *retval = GetWorldToScreenEx(position, camera, width, height); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibVector2, &mrb_raylib_struct_Vector2, retval));
}

static mrb_value mrb_raylib_GetWorldToScreen2D(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Vector2 position = *(Vector2*)DATA_PTR(argv[0]);
    Camera2D camera = *(Camera2D*)DATA_PTR(argv[1]);

    Vector2* retval = (Vector2*)mrb_malloc(mrb, sizeof(Vector2));
    *retval = GetWorldToScreen2D(position, camera); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibVector2, &mrb_raylib_struct_Vector2, retval));
}

static mrb_value mrb_raylib_SetTargetFPS(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    int fps = mrb_as_int(mrb, argv[0]);

    SetTargetFPS(fps);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_GetFrameTime(mrb_state* mrb, mrb_value self)
{
    float retval = GetFrameTime();

    return mrb_float_value(mrb, retval);
}

static mrb_value mrb_raylib_GetTime(mrb_state* mrb, mrb_value self)
{
    double retval = GetTime();

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_GetFPS(mrb_state* mrb, mrb_value self)
{
    int retval = GetFPS();

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_SwapScreenBuffer(mrb_state* mrb, mrb_value self)
{
    SwapScreenBuffer();

    return mrb_nil_value();
}

static mrb_value mrb_raylib_PollInputEvents(mrb_state* mrb, mrb_value self)
{
    PollInputEvents();

    return mrb_nil_value();
}

static mrb_value mrb_raylib_WaitTime(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    double seconds = mrb_as_int(mrb, argv[0]);

    WaitTime(seconds);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_GetRandomValue(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    int min = mrb_as_int(mrb, argv[0]);
    int max = mrb_as_int(mrb, argv[1]);

    int retval = GetRandomValue(min, max);

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_SetRandomSeed(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    unsigned int seed = mrb_as_int(mrb, argv[0]);

    SetRandomSeed(seed);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_TakeScreenshot(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * fileName = DATA_PTR(argv[0]);

    TakeScreenshot(fileName);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetConfigFlags(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    unsigned int flags = mrb_as_int(mrb, argv[0]);

    SetConfigFlags(flags);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_OpenURL(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * url = DATA_PTR(argv[0]);

    OpenURL(url);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetTraceLogLevel(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    int logLevel = mrb_as_int(mrb, argv[0]);

    SetTraceLogLevel(logLevel);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_MemAlloc(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    unsigned int size = mrb_as_int(mrb, argv[0]);

    void * retval = MemAlloc(size);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_MemRealloc(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    void * ptr = DATA_PTR(argv[0]);
    unsigned int size = mrb_as_int(mrb, argv[1]);

    void * retval = MemRealloc(ptr, size);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_MemFree(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    void * ptr = DATA_PTR(argv[0]);

    MemFree(ptr);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetTraceLogCallback(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    TraceLogCallback callback = *(TraceLogCallback*)DATA_PTR(argv[0]);

    SetTraceLogCallback(callback);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetLoadFileDataCallback(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    LoadFileDataCallback callback = *(LoadFileDataCallback*)DATA_PTR(argv[0]);

    SetLoadFileDataCallback(callback);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetSaveFileDataCallback(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    SaveFileDataCallback callback = *(SaveFileDataCallback*)DATA_PTR(argv[0]);

    SetSaveFileDataCallback(callback);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetLoadFileTextCallback(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    LoadFileTextCallback callback = *(LoadFileTextCallback*)DATA_PTR(argv[0]);

    SetLoadFileTextCallback(callback);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetSaveFileTextCallback(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    SaveFileTextCallback callback = *(SaveFileTextCallback*)DATA_PTR(argv[0]);

    SetSaveFileTextCallback(callback);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_LoadFileData(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    const char * fileName = DATA_PTR(argv[0]);
    int * dataSize = DATA_PTR(argv[1]);

    unsigned char * retval = LoadFileData(fileName, dataSize);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_UnloadFileData(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    unsigned char * data = DATA_PTR(argv[0]);

    UnloadFileData(data);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SaveFileData(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    const char * fileName = DATA_PTR(argv[0]);
    void * data = DATA_PTR(argv[1]);
    int dataSize = mrb_as_int(mrb, argv[2]);

    bool retval = SaveFileData(fileName, data, dataSize);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_ExportDataAsCode(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    const unsigned char * data = DATA_PTR(argv[0]);
    int dataSize = mrb_as_int(mrb, argv[1]);
    const char * fileName = DATA_PTR(argv[2]);

    bool retval = ExportDataAsCode(data, dataSize, fileName);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_LoadFileText(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * fileName = DATA_PTR(argv[0]);

    char * retval = LoadFileText(fileName);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_UnloadFileText(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    char * text = DATA_PTR(argv[0]);

    UnloadFileText(text);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SaveFileText(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    const char * fileName = DATA_PTR(argv[0]);
    char * text = DATA_PTR(argv[1]);

    bool retval = SaveFileText(fileName, text);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_FileExists(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * fileName = DATA_PTR(argv[0]);

    bool retval = FileExists(fileName);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_DirectoryExists(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * dirPath = DATA_PTR(argv[0]);

    bool retval = DirectoryExists(dirPath);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_IsFileExtension(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    const char * fileName = DATA_PTR(argv[0]);
    const char * ext = DATA_PTR(argv[1]);

    bool retval = IsFileExtension(fileName, ext);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_GetFileLength(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * fileName = DATA_PTR(argv[0]);

    int retval = GetFileLength(fileName);

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_GetFileExtension(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * fileName = DATA_PTR(argv[0]);

    const char * retval = GetFileExtension(fileName);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_GetFileName(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * filePath = DATA_PTR(argv[0]);

    const char * retval = GetFileName(filePath);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_GetFileNameWithoutExt(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * filePath = DATA_PTR(argv[0]);

    const char * retval = GetFileNameWithoutExt(filePath);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_GetDirectoryPath(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * filePath = DATA_PTR(argv[0]);

    const char * retval = GetDirectoryPath(filePath);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_GetPrevDirectoryPath(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * dirPath = DATA_PTR(argv[0]);

    const char * retval = GetPrevDirectoryPath(dirPath);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_GetWorkingDirectory(mrb_state* mrb, mrb_value self)
{
    const char * retval = GetWorkingDirectory();

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_GetApplicationDirectory(mrb_state* mrb, mrb_value self)
{
    const char * retval = GetApplicationDirectory();

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_ChangeDirectory(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * dir = DATA_PTR(argv[0]);

    bool retval = ChangeDirectory(dir);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_IsPathFile(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * path = DATA_PTR(argv[0]);

    bool retval = IsPathFile(path);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_LoadDirectoryFiles(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * dirPath = DATA_PTR(argv[0]);

    FilePathList* retval = (FilePathList*)mrb_malloc(mrb, sizeof(FilePathList));
    *retval = LoadDirectoryFiles(dirPath); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibFilePathList, &mrb_raylib_struct_FilePathList, retval));
}

static mrb_value mrb_raylib_LoadDirectoryFilesEx(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    const char * basePath = DATA_PTR(argv[0]);
    const char * filter = DATA_PTR(argv[1]);
    bool scanSubdirs = mrb_as_int(mrb, argv[2]);

    FilePathList* retval = (FilePathList*)mrb_malloc(mrb, sizeof(FilePathList));
    *retval = LoadDirectoryFilesEx(basePath, filter, scanSubdirs); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibFilePathList, &mrb_raylib_struct_FilePathList, retval));
}

static mrb_value mrb_raylib_UnloadDirectoryFiles(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    FilePathList files = *(FilePathList*)DATA_PTR(argv[0]);

    UnloadDirectoryFiles(files);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_IsFileDropped(mrb_state* mrb, mrb_value self)
{
    bool retval = IsFileDropped();

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_LoadDroppedFiles(mrb_state* mrb, mrb_value self)
{
    FilePathList* retval = (FilePathList*)mrb_malloc(mrb, sizeof(FilePathList));
    *retval = LoadDroppedFiles(); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibFilePathList, &mrb_raylib_struct_FilePathList, retval));
}

static mrb_value mrb_raylib_UnloadDroppedFiles(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    FilePathList files = *(FilePathList*)DATA_PTR(argv[0]);

    UnloadDroppedFiles(files);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_GetFileModTime(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * fileName = DATA_PTR(argv[0]);

    long retval = GetFileModTime(fileName);

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_CompressData(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    const unsigned char * data = DATA_PTR(argv[0]);
    int dataSize = mrb_as_int(mrb, argv[1]);
    int * compDataSize = DATA_PTR(argv[2]);

    unsigned char * retval = CompressData(data, dataSize, compDataSize);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_DecompressData(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    const unsigned char * compData = DATA_PTR(argv[0]);
    int compDataSize = mrb_as_int(mrb, argv[1]);
    int * dataSize = DATA_PTR(argv[2]);

    unsigned char * retval = DecompressData(compData, compDataSize, dataSize);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_EncodeDataBase64(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    const unsigned char * data = DATA_PTR(argv[0]);
    int dataSize = mrb_as_int(mrb, argv[1]);
    int * outputSize = DATA_PTR(argv[2]);

    char * retval = EncodeDataBase64(data, dataSize, outputSize);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_DecodeDataBase64(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    const unsigned char * data = DATA_PTR(argv[0]);
    int * outputSize = DATA_PTR(argv[1]);

    unsigned char * retval = DecodeDataBase64(data, outputSize);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_LoadAutomationEventList(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * fileName = DATA_PTR(argv[0]);

    AutomationEventList* retval = (AutomationEventList*)mrb_malloc(mrb, sizeof(AutomationEventList));
    *retval = LoadAutomationEventList(fileName); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibAutomationEventList, &mrb_raylib_struct_AutomationEventList, retval));
}

static mrb_value mrb_raylib_UnloadAutomationEventList(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    AutomationEventList * list = DATA_PTR(argv[0]);

    UnloadAutomationEventList(list);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ExportAutomationEventList(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    AutomationEventList list = *(AutomationEventList*)DATA_PTR(argv[0]);
    const char * fileName = DATA_PTR(argv[1]);

    bool retval = ExportAutomationEventList(list, fileName);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_SetAutomationEventList(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    AutomationEventList * list = DATA_PTR(argv[0]);

    SetAutomationEventList(list);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetAutomationEventBaseFrame(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    int frame = mrb_as_int(mrb, argv[0]);

    SetAutomationEventBaseFrame(frame);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_StartAutomationEventRecording(mrb_state* mrb, mrb_value self)
{
    StartAutomationEventRecording();

    return mrb_nil_value();
}

static mrb_value mrb_raylib_StopAutomationEventRecording(mrb_state* mrb, mrb_value self)
{
    StopAutomationEventRecording();

    return mrb_nil_value();
}

static mrb_value mrb_raylib_PlayAutomationEvent(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    AutomationEvent event = *(AutomationEvent*)DATA_PTR(argv[0]);

    PlayAutomationEvent(event);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_IsKeyPressed(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    int key = mrb_as_int(mrb, argv[0]);

    bool retval = IsKeyPressed(key);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_IsKeyPressedRepeat(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    int key = mrb_as_int(mrb, argv[0]);

    bool retval = IsKeyPressedRepeat(key);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_IsKeyDown(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    int key = mrb_as_int(mrb, argv[0]);

    bool retval = IsKeyDown(key);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_IsKeyReleased(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    int key = mrb_as_int(mrb, argv[0]);

    bool retval = IsKeyReleased(key);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_IsKeyUp(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    int key = mrb_as_int(mrb, argv[0]);

    bool retval = IsKeyUp(key);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_GetKeyPressed(mrb_state* mrb, mrb_value self)
{
    int retval = GetKeyPressed();

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_GetCharPressed(mrb_state* mrb, mrb_value self)
{
    int retval = GetCharPressed();

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_SetExitKey(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    int key = mrb_as_int(mrb, argv[0]);

    SetExitKey(key);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_IsGamepadAvailable(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    int gamepad = mrb_as_int(mrb, argv[0]);

    bool retval = IsGamepadAvailable(gamepad);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_GetGamepadName(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    int gamepad = mrb_as_int(mrb, argv[0]);

    const char * retval = GetGamepadName(gamepad);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_IsGamepadButtonPressed(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    int gamepad = mrb_as_int(mrb, argv[0]);
    int button = mrb_as_int(mrb, argv[1]);

    bool retval = IsGamepadButtonPressed(gamepad, button);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_IsGamepadButtonDown(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    int gamepad = mrb_as_int(mrb, argv[0]);
    int button = mrb_as_int(mrb, argv[1]);

    bool retval = IsGamepadButtonDown(gamepad, button);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_IsGamepadButtonReleased(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    int gamepad = mrb_as_int(mrb, argv[0]);
    int button = mrb_as_int(mrb, argv[1]);

    bool retval = IsGamepadButtonReleased(gamepad, button);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_IsGamepadButtonUp(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    int gamepad = mrb_as_int(mrb, argv[0]);
    int button = mrb_as_int(mrb, argv[1]);

    bool retval = IsGamepadButtonUp(gamepad, button);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_GetGamepadButtonPressed(mrb_state* mrb, mrb_value self)
{
    int retval = GetGamepadButtonPressed();

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_GetGamepadAxisCount(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    int gamepad = mrb_as_int(mrb, argv[0]);

    int retval = GetGamepadAxisCount(gamepad);

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_GetGamepadAxisMovement(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    int gamepad = mrb_as_int(mrb, argv[0]);
    int axis = mrb_as_int(mrb, argv[1]);

    float retval = GetGamepadAxisMovement(gamepad, axis);

    return mrb_float_value(mrb, retval);
}

static mrb_value mrb_raylib_SetGamepadMappings(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * mappings = DATA_PTR(argv[0]);

    int retval = SetGamepadMappings(mappings);

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_IsMouseButtonPressed(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    int button = mrb_as_int(mrb, argv[0]);

    bool retval = IsMouseButtonPressed(button);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_IsMouseButtonDown(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    int button = mrb_as_int(mrb, argv[0]);

    bool retval = IsMouseButtonDown(button);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_IsMouseButtonReleased(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    int button = mrb_as_int(mrb, argv[0]);

    bool retval = IsMouseButtonReleased(button);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_IsMouseButtonUp(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    int button = mrb_as_int(mrb, argv[0]);

    bool retval = IsMouseButtonUp(button);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_GetMouseX(mrb_state* mrb, mrb_value self)
{
    int retval = GetMouseX();

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_GetMouseY(mrb_state* mrb, mrb_value self)
{
    int retval = GetMouseY();

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_GetMousePosition(mrb_state* mrb, mrb_value self)
{
    Vector2* retval = (Vector2*)mrb_malloc(mrb, sizeof(Vector2));
    *retval = GetMousePosition(); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibVector2, &mrb_raylib_struct_Vector2, retval));
}

static mrb_value mrb_raylib_GetMouseDelta(mrb_state* mrb, mrb_value self)
{
    Vector2* retval = (Vector2*)mrb_malloc(mrb, sizeof(Vector2));
    *retval = GetMouseDelta(); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibVector2, &mrb_raylib_struct_Vector2, retval));
}

static mrb_value mrb_raylib_SetMousePosition(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    int x = mrb_as_int(mrb, argv[0]);
    int y = mrb_as_int(mrb, argv[1]);

    SetMousePosition(x, y);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetMouseOffset(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    int offsetX = mrb_as_int(mrb, argv[0]);
    int offsetY = mrb_as_int(mrb, argv[1]);

    SetMouseOffset(offsetX, offsetY);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetMouseScale(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    float scaleX = mrb_as_float(mrb, argv[0]);
    float scaleY = mrb_as_float(mrb, argv[1]);

    SetMouseScale(scaleX, scaleY);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_GetMouseWheelMove(mrb_state* mrb, mrb_value self)
{
    float retval = GetMouseWheelMove();

    return mrb_float_value(mrb, retval);
}

static mrb_value mrb_raylib_GetMouseWheelMoveV(mrb_state* mrb, mrb_value self)
{
    Vector2* retval = (Vector2*)mrb_malloc(mrb, sizeof(Vector2));
    *retval = GetMouseWheelMoveV(); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibVector2, &mrb_raylib_struct_Vector2, retval));
}

static mrb_value mrb_raylib_SetMouseCursor(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    int cursor = mrb_as_int(mrb, argv[0]);

    SetMouseCursor(cursor);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_GetTouchX(mrb_state* mrb, mrb_value self)
{
    int retval = GetTouchX();

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_GetTouchY(mrb_state* mrb, mrb_value self)
{
    int retval = GetTouchY();

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_GetTouchPosition(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    int index = mrb_as_int(mrb, argv[0]);

    Vector2* retval = (Vector2*)mrb_malloc(mrb, sizeof(Vector2));
    *retval = GetTouchPosition(index); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibVector2, &mrb_raylib_struct_Vector2, retval));
}

static mrb_value mrb_raylib_GetTouchPointId(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    int index = mrb_as_int(mrb, argv[0]);

    int retval = GetTouchPointId(index);

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_GetTouchPointCount(mrb_state* mrb, mrb_value self)
{
    int retval = GetTouchPointCount();

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_SetGesturesEnabled(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    unsigned int flags = mrb_as_int(mrb, argv[0]);

    SetGesturesEnabled(flags);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_IsGestureDetected(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    unsigned int gesture = mrb_as_int(mrb, argv[0]);

    bool retval = IsGestureDetected(gesture);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_GetGestureDetected(mrb_state* mrb, mrb_value self)
{
    int retval = GetGestureDetected();

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_GetGestureHoldDuration(mrb_state* mrb, mrb_value self)
{
    float retval = GetGestureHoldDuration();

    return mrb_float_value(mrb, retval);
}

static mrb_value mrb_raylib_GetGestureDragVector(mrb_state* mrb, mrb_value self)
{
    Vector2* retval = (Vector2*)mrb_malloc(mrb, sizeof(Vector2));
    *retval = GetGestureDragVector(); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibVector2, &mrb_raylib_struct_Vector2, retval));
}

static mrb_value mrb_raylib_GetGestureDragAngle(mrb_state* mrb, mrb_value self)
{
    float retval = GetGestureDragAngle();

    return mrb_float_value(mrb, retval);
}

static mrb_value mrb_raylib_GetGesturePinchVector(mrb_state* mrb, mrb_value self)
{
    Vector2* retval = (Vector2*)mrb_malloc(mrb, sizeof(Vector2));
    *retval = GetGesturePinchVector(); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibVector2, &mrb_raylib_struct_Vector2, retval));
}

static mrb_value mrb_raylib_GetGesturePinchAngle(mrb_state* mrb, mrb_value self)
{
    float retval = GetGesturePinchAngle();

    return mrb_float_value(mrb, retval);
}

static mrb_value mrb_raylib_UpdateCamera(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Camera * camera = DATA_PTR(argv[0]);
    int mode = mrb_as_int(mrb, argv[1]);

    UpdateCamera(camera, mode);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_UpdateCameraPro(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    Camera * camera = DATA_PTR(argv[0]);
    Vector3 movement = *(Vector3*)DATA_PTR(argv[1]);
    Vector3 rotation = *(Vector3*)DATA_PTR(argv[2]);
    float zoom = mrb_as_float(mrb, argv[3]);

    UpdateCameraPro(camera, movement, rotation, zoom);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetShapesTexture(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Texture2D texture = *(Texture2D*)DATA_PTR(argv[0]);
    Rectangle source = *(Rectangle*)DATA_PTR(argv[1]);

    SetShapesTexture(texture, source);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawPixel(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    int posX = mrb_as_int(mrb, argv[0]);
    int posY = mrb_as_int(mrb, argv[1]);
    Color color = *(Color*)DATA_PTR(argv[2]);

    DrawPixel(posX, posY, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawPixelV(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Vector2 position = *(Vector2*)DATA_PTR(argv[0]);
    Color color = *(Color*)DATA_PTR(argv[1]);

    DrawPixelV(position, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawLine(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    int startPosX = mrb_as_int(mrb, argv[0]);
    int startPosY = mrb_as_int(mrb, argv[1]);
    int endPosX = mrb_as_int(mrb, argv[2]);
    int endPosY = mrb_as_int(mrb, argv[3]);
    Color color = *(Color*)DATA_PTR(argv[4]);

    DrawLine(startPosX, startPosY, endPosX, endPosY, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawLineV(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Vector2 startPos = *(Vector2*)DATA_PTR(argv[0]);
    Vector2 endPos = *(Vector2*)DATA_PTR(argv[1]);
    Color color = *(Color*)DATA_PTR(argv[2]);

    DrawLineV(startPos, endPos, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawLineEx(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    Vector2 startPos = *(Vector2*)DATA_PTR(argv[0]);
    Vector2 endPos = *(Vector2*)DATA_PTR(argv[1]);
    float thick = mrb_as_float(mrb, argv[2]);
    Color color = *(Color*)DATA_PTR(argv[3]);

    DrawLineEx(startPos, endPos, thick, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawLineBezier(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    Vector2 startPos = *(Vector2*)DATA_PTR(argv[0]);
    Vector2 endPos = *(Vector2*)DATA_PTR(argv[1]);
    float thick = mrb_as_float(mrb, argv[2]);
    Color color = *(Color*)DATA_PTR(argv[3]);

    DrawLineBezier(startPos, endPos, thick, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawLineBezierQuad(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    Vector2 startPos = *(Vector2*)DATA_PTR(argv[0]);
    Vector2 endPos = *(Vector2*)DATA_PTR(argv[1]);
    Vector2 controlPos = *(Vector2*)DATA_PTR(argv[2]);
    float thick = mrb_as_float(mrb, argv[3]);
    Color color = *(Color*)DATA_PTR(argv[4]);

    DrawLineBezierQuad(startPos, endPos, controlPos, thick, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawLineBezierCubic(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[6];
    void* ptrs[6] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], };
    mrb_get_args_a(mrb, "oooooo", ptrs);
    Vector2 startPos = *(Vector2*)DATA_PTR(argv[0]);
    Vector2 endPos = *(Vector2*)DATA_PTR(argv[1]);
    Vector2 startControlPos = *(Vector2*)DATA_PTR(argv[2]);
    Vector2 endControlPos = *(Vector2*)DATA_PTR(argv[3]);
    float thick = mrb_as_float(mrb, argv[4]);
    Color color = *(Color*)DATA_PTR(argv[5]);

    DrawLineBezierCubic(startPos, endPos, startControlPos, endControlPos, thick, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawLineBSpline(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    Vector2 * points = DATA_PTR(argv[0]);
    int pointCount = mrb_as_int(mrb, argv[1]);
    float thick = mrb_as_float(mrb, argv[2]);
    Color color = *(Color*)DATA_PTR(argv[3]);

    DrawLineBSpline(points, pointCount, thick, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawLineCatmullRom(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    Vector2 * points = DATA_PTR(argv[0]);
    int pointCount = mrb_as_int(mrb, argv[1]);
    float thick = mrb_as_float(mrb, argv[2]);
    Color color = *(Color*)DATA_PTR(argv[3]);

    DrawLineCatmullRom(points, pointCount, thick, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawLineStrip(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Vector2 * points = DATA_PTR(argv[0]);
    int pointCount = mrb_as_int(mrb, argv[1]);
    Color color = *(Color*)DATA_PTR(argv[2]);

    DrawLineStrip(points, pointCount, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawCircle(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    int centerX = mrb_as_int(mrb, argv[0]);
    int centerY = mrb_as_int(mrb, argv[1]);
    float radius = mrb_as_float(mrb, argv[2]);
    Color color = *(Color*)DATA_PTR(argv[3]);

    DrawCircle(centerX, centerY, radius, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawCircleSector(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[6];
    void* ptrs[6] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], };
    mrb_get_args_a(mrb, "oooooo", ptrs);
    Vector2 center = *(Vector2*)DATA_PTR(argv[0]);
    float radius = mrb_as_float(mrb, argv[1]);
    float startAngle = mrb_as_float(mrb, argv[2]);
    float endAngle = mrb_as_float(mrb, argv[3]);
    int segments = mrb_as_int(mrb, argv[4]);
    Color color = *(Color*)DATA_PTR(argv[5]);

    DrawCircleSector(center, radius, startAngle, endAngle, segments, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawCircleSectorLines(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[6];
    void* ptrs[6] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], };
    mrb_get_args_a(mrb, "oooooo", ptrs);
    Vector2 center = *(Vector2*)DATA_PTR(argv[0]);
    float radius = mrb_as_float(mrb, argv[1]);
    float startAngle = mrb_as_float(mrb, argv[2]);
    float endAngle = mrb_as_float(mrb, argv[3]);
    int segments = mrb_as_int(mrb, argv[4]);
    Color color = *(Color*)DATA_PTR(argv[5]);

    DrawCircleSectorLines(center, radius, startAngle, endAngle, segments, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawCircleGradient(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    int centerX = mrb_as_int(mrb, argv[0]);
    int centerY = mrb_as_int(mrb, argv[1]);
    float radius = mrb_as_float(mrb, argv[2]);
    Color color1 = *(Color*)DATA_PTR(argv[3]);
    Color color2 = *(Color*)DATA_PTR(argv[4]);

    DrawCircleGradient(centerX, centerY, radius, color1, color2);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawCircleV(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Vector2 center = *(Vector2*)DATA_PTR(argv[0]);
    float radius = mrb_as_float(mrb, argv[1]);
    Color color = *(Color*)DATA_PTR(argv[2]);

    DrawCircleV(center, radius, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawCircleLines(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    int centerX = mrb_as_int(mrb, argv[0]);
    int centerY = mrb_as_int(mrb, argv[1]);
    float radius = mrb_as_float(mrb, argv[2]);
    Color color = *(Color*)DATA_PTR(argv[3]);

    DrawCircleLines(centerX, centerY, radius, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawCircleLinesV(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Vector2 center = *(Vector2*)DATA_PTR(argv[0]);
    float radius = mrb_as_float(mrb, argv[1]);
    Color color = *(Color*)DATA_PTR(argv[2]);

    DrawCircleLinesV(center, radius, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawEllipse(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    int centerX = mrb_as_int(mrb, argv[0]);
    int centerY = mrb_as_int(mrb, argv[1]);
    float radiusH = mrb_as_float(mrb, argv[2]);
    float radiusV = mrb_as_float(mrb, argv[3]);
    Color color = *(Color*)DATA_PTR(argv[4]);

    DrawEllipse(centerX, centerY, radiusH, radiusV, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawEllipseLines(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    int centerX = mrb_as_int(mrb, argv[0]);
    int centerY = mrb_as_int(mrb, argv[1]);
    float radiusH = mrb_as_float(mrb, argv[2]);
    float radiusV = mrb_as_float(mrb, argv[3]);
    Color color = *(Color*)DATA_PTR(argv[4]);

    DrawEllipseLines(centerX, centerY, radiusH, radiusV, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawRing(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[7];
    void* ptrs[7] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], &argv[6], };
    mrb_get_args_a(mrb, "ooooooo", ptrs);
    Vector2 center = *(Vector2*)DATA_PTR(argv[0]);
    float innerRadius = mrb_as_float(mrb, argv[1]);
    float outerRadius = mrb_as_float(mrb, argv[2]);
    float startAngle = mrb_as_float(mrb, argv[3]);
    float endAngle = mrb_as_float(mrb, argv[4]);
    int segments = mrb_as_int(mrb, argv[5]);
    Color color = *(Color*)DATA_PTR(argv[6]);

    DrawRing(center, innerRadius, outerRadius, startAngle, endAngle, segments, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawRingLines(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[7];
    void* ptrs[7] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], &argv[6], };
    mrb_get_args_a(mrb, "ooooooo", ptrs);
    Vector2 center = *(Vector2*)DATA_PTR(argv[0]);
    float innerRadius = mrb_as_float(mrb, argv[1]);
    float outerRadius = mrb_as_float(mrb, argv[2]);
    float startAngle = mrb_as_float(mrb, argv[3]);
    float endAngle = mrb_as_float(mrb, argv[4]);
    int segments = mrb_as_int(mrb, argv[5]);
    Color color = *(Color*)DATA_PTR(argv[6]);

    DrawRingLines(center, innerRadius, outerRadius, startAngle, endAngle, segments, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawRectangle(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    int posX = mrb_as_int(mrb, argv[0]);
    int posY = mrb_as_int(mrb, argv[1]);
    int width = mrb_as_int(mrb, argv[2]);
    int height = mrb_as_int(mrb, argv[3]);
    Color color = *(Color*)DATA_PTR(argv[4]);

    DrawRectangle(posX, posY, width, height, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawRectangleV(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Vector2 position = *(Vector2*)DATA_PTR(argv[0]);
    Vector2 size = *(Vector2*)DATA_PTR(argv[1]);
    Color color = *(Color*)DATA_PTR(argv[2]);

    DrawRectangleV(position, size, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawRectangleRec(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Rectangle rec = *(Rectangle*)DATA_PTR(argv[0]);
    Color color = *(Color*)DATA_PTR(argv[1]);

    DrawRectangleRec(rec, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawRectanglePro(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    Rectangle rec = *(Rectangle*)DATA_PTR(argv[0]);
    Vector2 origin = *(Vector2*)DATA_PTR(argv[1]);
    float rotation = mrb_as_float(mrb, argv[2]);
    Color color = *(Color*)DATA_PTR(argv[3]);

    DrawRectanglePro(rec, origin, rotation, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawRectangleGradientV(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[6];
    void* ptrs[6] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], };
    mrb_get_args_a(mrb, "oooooo", ptrs);
    int posX = mrb_as_int(mrb, argv[0]);
    int posY = mrb_as_int(mrb, argv[1]);
    int width = mrb_as_int(mrb, argv[2]);
    int height = mrb_as_int(mrb, argv[3]);
    Color color1 = *(Color*)DATA_PTR(argv[4]);
    Color color2 = *(Color*)DATA_PTR(argv[5]);

    DrawRectangleGradientV(posX, posY, width, height, color1, color2);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawRectangleGradientH(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[6];
    void* ptrs[6] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], };
    mrb_get_args_a(mrb, "oooooo", ptrs);
    int posX = mrb_as_int(mrb, argv[0]);
    int posY = mrb_as_int(mrb, argv[1]);
    int width = mrb_as_int(mrb, argv[2]);
    int height = mrb_as_int(mrb, argv[3]);
    Color color1 = *(Color*)DATA_PTR(argv[4]);
    Color color2 = *(Color*)DATA_PTR(argv[5]);

    DrawRectangleGradientH(posX, posY, width, height, color1, color2);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawRectangleGradientEx(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    Rectangle rec = *(Rectangle*)DATA_PTR(argv[0]);
    Color col1 = *(Color*)DATA_PTR(argv[1]);
    Color col2 = *(Color*)DATA_PTR(argv[2]);
    Color col3 = *(Color*)DATA_PTR(argv[3]);
    Color col4 = *(Color*)DATA_PTR(argv[4]);

    DrawRectangleGradientEx(rec, col1, col2, col3, col4);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawRectangleLines(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    int posX = mrb_as_int(mrb, argv[0]);
    int posY = mrb_as_int(mrb, argv[1]);
    int width = mrb_as_int(mrb, argv[2]);
    int height = mrb_as_int(mrb, argv[3]);
    Color color = *(Color*)DATA_PTR(argv[4]);

    DrawRectangleLines(posX, posY, width, height, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawRectangleLinesEx(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Rectangle rec = *(Rectangle*)DATA_PTR(argv[0]);
    float lineThick = mrb_as_float(mrb, argv[1]);
    Color color = *(Color*)DATA_PTR(argv[2]);

    DrawRectangleLinesEx(rec, lineThick, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawRectangleRounded(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    Rectangle rec = *(Rectangle*)DATA_PTR(argv[0]);
    float roundness = mrb_as_float(mrb, argv[1]);
    int segments = mrb_as_int(mrb, argv[2]);
    Color color = *(Color*)DATA_PTR(argv[3]);

    DrawRectangleRounded(rec, roundness, segments, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawRectangleRoundedLines(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    Rectangle rec = *(Rectangle*)DATA_PTR(argv[0]);
    float roundness = mrb_as_float(mrb, argv[1]);
    int segments = mrb_as_int(mrb, argv[2]);
    float lineThick = mrb_as_float(mrb, argv[3]);
    Color color = *(Color*)DATA_PTR(argv[4]);

    DrawRectangleRoundedLines(rec, roundness, segments, lineThick, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawTriangle(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    Vector2 v1 = *(Vector2*)DATA_PTR(argv[0]);
    Vector2 v2 = *(Vector2*)DATA_PTR(argv[1]);
    Vector2 v3 = *(Vector2*)DATA_PTR(argv[2]);
    Color color = *(Color*)DATA_PTR(argv[3]);

    DrawTriangle(v1, v2, v3, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawTriangleLines(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    Vector2 v1 = *(Vector2*)DATA_PTR(argv[0]);
    Vector2 v2 = *(Vector2*)DATA_PTR(argv[1]);
    Vector2 v3 = *(Vector2*)DATA_PTR(argv[2]);
    Color color = *(Color*)DATA_PTR(argv[3]);

    DrawTriangleLines(v1, v2, v3, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawTriangleFan(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Vector2 * points = DATA_PTR(argv[0]);
    int pointCount = mrb_as_int(mrb, argv[1]);
    Color color = *(Color*)DATA_PTR(argv[2]);

    DrawTriangleFan(points, pointCount, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawTriangleStrip(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Vector2 * points = DATA_PTR(argv[0]);
    int pointCount = mrb_as_int(mrb, argv[1]);
    Color color = *(Color*)DATA_PTR(argv[2]);

    DrawTriangleStrip(points, pointCount, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawPoly(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    Vector2 center = *(Vector2*)DATA_PTR(argv[0]);
    int sides = mrb_as_int(mrb, argv[1]);
    float radius = mrb_as_float(mrb, argv[2]);
    float rotation = mrb_as_float(mrb, argv[3]);
    Color color = *(Color*)DATA_PTR(argv[4]);

    DrawPoly(center, sides, radius, rotation, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawPolyLines(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    Vector2 center = *(Vector2*)DATA_PTR(argv[0]);
    int sides = mrb_as_int(mrb, argv[1]);
    float radius = mrb_as_float(mrb, argv[2]);
    float rotation = mrb_as_float(mrb, argv[3]);
    Color color = *(Color*)DATA_PTR(argv[4]);

    DrawPolyLines(center, sides, radius, rotation, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawPolyLinesEx(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[6];
    void* ptrs[6] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], };
    mrb_get_args_a(mrb, "oooooo", ptrs);
    Vector2 center = *(Vector2*)DATA_PTR(argv[0]);
    int sides = mrb_as_int(mrb, argv[1]);
    float radius = mrb_as_float(mrb, argv[2]);
    float rotation = mrb_as_float(mrb, argv[3]);
    float lineThick = mrb_as_float(mrb, argv[4]);
    Color color = *(Color*)DATA_PTR(argv[5]);

    DrawPolyLinesEx(center, sides, radius, rotation, lineThick, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_CheckCollisionRecs(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Rectangle rec1 = *(Rectangle*)DATA_PTR(argv[0]);
    Rectangle rec2 = *(Rectangle*)DATA_PTR(argv[1]);

    bool retval = CheckCollisionRecs(rec1, rec2);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_CheckCollisionCircles(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    Vector2 center1 = *(Vector2*)DATA_PTR(argv[0]);
    float radius1 = mrb_as_float(mrb, argv[1]);
    Vector2 center2 = *(Vector2*)DATA_PTR(argv[2]);
    float radius2 = mrb_as_float(mrb, argv[3]);

    bool retval = CheckCollisionCircles(center1, radius1, center2, radius2);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_CheckCollisionCircleRec(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Vector2 center = *(Vector2*)DATA_PTR(argv[0]);
    float radius = mrb_as_float(mrb, argv[1]);
    Rectangle rec = *(Rectangle*)DATA_PTR(argv[2]);

    bool retval = CheckCollisionCircleRec(center, radius, rec);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_CheckCollisionPointRec(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Vector2 point = *(Vector2*)DATA_PTR(argv[0]);
    Rectangle rec = *(Rectangle*)DATA_PTR(argv[1]);

    bool retval = CheckCollisionPointRec(point, rec);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_CheckCollisionPointCircle(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Vector2 point = *(Vector2*)DATA_PTR(argv[0]);
    Vector2 center = *(Vector2*)DATA_PTR(argv[1]);
    float radius = mrb_as_float(mrb, argv[2]);

    bool retval = CheckCollisionPointCircle(point, center, radius);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_CheckCollisionPointTriangle(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    Vector2 point = *(Vector2*)DATA_PTR(argv[0]);
    Vector2 p1 = *(Vector2*)DATA_PTR(argv[1]);
    Vector2 p2 = *(Vector2*)DATA_PTR(argv[2]);
    Vector2 p3 = *(Vector2*)DATA_PTR(argv[3]);

    bool retval = CheckCollisionPointTriangle(point, p1, p2, p3);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_CheckCollisionPointPoly(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Vector2 point = *(Vector2*)DATA_PTR(argv[0]);
    Vector2 * points = DATA_PTR(argv[1]);
    int pointCount = mrb_as_int(mrb, argv[2]);

    bool retval = CheckCollisionPointPoly(point, points, pointCount);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_CheckCollisionLines(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    Vector2 startPos1 = *(Vector2*)DATA_PTR(argv[0]);
    Vector2 endPos1 = *(Vector2*)DATA_PTR(argv[1]);
    Vector2 startPos2 = *(Vector2*)DATA_PTR(argv[2]);
    Vector2 endPos2 = *(Vector2*)DATA_PTR(argv[3]);
    Vector2 * collisionPoint = DATA_PTR(argv[4]);

    bool retval = CheckCollisionLines(startPos1, endPos1, startPos2, endPos2, collisionPoint);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_CheckCollisionPointLine(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    Vector2 point = *(Vector2*)DATA_PTR(argv[0]);
    Vector2 p1 = *(Vector2*)DATA_PTR(argv[1]);
    Vector2 p2 = *(Vector2*)DATA_PTR(argv[2]);
    int threshold = mrb_as_int(mrb, argv[3]);

    bool retval = CheckCollisionPointLine(point, p1, p2, threshold);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_GetCollisionRec(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Rectangle rec1 = *(Rectangle*)DATA_PTR(argv[0]);
    Rectangle rec2 = *(Rectangle*)DATA_PTR(argv[1]);

    Rectangle* retval = (Rectangle*)mrb_malloc(mrb, sizeof(Rectangle));
    *retval = GetCollisionRec(rec1, rec2); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibRectangle, &mrb_raylib_struct_Rectangle, retval));
}

static mrb_value mrb_raylib_LoadImage(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * fileName = DATA_PTR(argv[0]);

    Image* retval = (Image*)mrb_malloc(mrb, sizeof(Image));
    *retval = LoadImage(fileName); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibImage, &mrb_raylib_struct_Image, retval));
}

static mrb_value mrb_raylib_LoadImageRaw(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    const char * fileName = DATA_PTR(argv[0]);
    int width = mrb_as_int(mrb, argv[1]);
    int height = mrb_as_int(mrb, argv[2]);
    int format = mrb_as_int(mrb, argv[3]);
    int headerSize = mrb_as_int(mrb, argv[4]);

    Image* retval = (Image*)mrb_malloc(mrb, sizeof(Image));
    *retval = LoadImageRaw(fileName, width, height, format, headerSize); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibImage, &mrb_raylib_struct_Image, retval));
}

static mrb_value mrb_raylib_LoadImageSvg(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    const char * fileNameOrString = DATA_PTR(argv[0]);
    int width = mrb_as_int(mrb, argv[1]);
    int height = mrb_as_int(mrb, argv[2]);

    Image* retval = (Image*)mrb_malloc(mrb, sizeof(Image));
    *retval = LoadImageSvg(fileNameOrString, width, height); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibImage, &mrb_raylib_struct_Image, retval));
}

static mrb_value mrb_raylib_LoadImageAnim(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    const char * fileName = DATA_PTR(argv[0]);
    int * frames = DATA_PTR(argv[1]);

    Image* retval = (Image*)mrb_malloc(mrb, sizeof(Image));
    *retval = LoadImageAnim(fileName, frames); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibImage, &mrb_raylib_struct_Image, retval));
}

static mrb_value mrb_raylib_LoadImageFromMemory(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    const char * fileType = DATA_PTR(argv[0]);
    const unsigned char * fileData = DATA_PTR(argv[1]);
    int dataSize = mrb_as_int(mrb, argv[2]);

    Image* retval = (Image*)mrb_malloc(mrb, sizeof(Image));
    *retval = LoadImageFromMemory(fileType, fileData, dataSize); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibImage, &mrb_raylib_struct_Image, retval));
}

static mrb_value mrb_raylib_LoadImageFromTexture(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Texture2D texture = *(Texture2D*)DATA_PTR(argv[0]);

    Image* retval = (Image*)mrb_malloc(mrb, sizeof(Image));
    *retval = LoadImageFromTexture(texture); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibImage, &mrb_raylib_struct_Image, retval));
}

static mrb_value mrb_raylib_LoadImageFromScreen(mrb_state* mrb, mrb_value self)
{
    Image* retval = (Image*)mrb_malloc(mrb, sizeof(Image));
    *retval = LoadImageFromScreen(); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibImage, &mrb_raylib_struct_Image, retval));
}

static mrb_value mrb_raylib_IsImageReady(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Image image = *(Image*)DATA_PTR(argv[0]);

    bool retval = IsImageReady(image);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_UnloadImage(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Image image = *(Image*)DATA_PTR(argv[0]);

    UnloadImage(image);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ExportImage(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Image image = *(Image*)DATA_PTR(argv[0]);
    const char * fileName = DATA_PTR(argv[1]);

    bool retval = ExportImage(image, fileName);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_ExportImageToMemory(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Image image = *(Image*)DATA_PTR(argv[0]);
    const char * fileType = DATA_PTR(argv[1]);
    int * fileSize = DATA_PTR(argv[2]);

    unsigned char * retval = ExportImageToMemory(image, fileType, fileSize);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_ExportImageAsCode(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Image image = *(Image*)DATA_PTR(argv[0]);
    const char * fileName = DATA_PTR(argv[1]);

    bool retval = ExportImageAsCode(image, fileName);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_GenImageColor(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    int width = mrb_as_int(mrb, argv[0]);
    int height = mrb_as_int(mrb, argv[1]);
    Color color = *(Color*)DATA_PTR(argv[2]);

    Image* retval = (Image*)mrb_malloc(mrb, sizeof(Image));
    *retval = GenImageColor(width, height, color); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibImage, &mrb_raylib_struct_Image, retval));
}

static mrb_value mrb_raylib_GenImageGradientLinear(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    int width = mrb_as_int(mrb, argv[0]);
    int height = mrb_as_int(mrb, argv[1]);
    int direction = mrb_as_int(mrb, argv[2]);
    Color start = *(Color*)DATA_PTR(argv[3]);
    Color end = *(Color*)DATA_PTR(argv[4]);

    Image* retval = (Image*)mrb_malloc(mrb, sizeof(Image));
    *retval = GenImageGradientLinear(width, height, direction, start, end); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibImage, &mrb_raylib_struct_Image, retval));
}

static mrb_value mrb_raylib_GenImageGradientRadial(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    int width = mrb_as_int(mrb, argv[0]);
    int height = mrb_as_int(mrb, argv[1]);
    float density = mrb_as_float(mrb, argv[2]);
    Color inner = *(Color*)DATA_PTR(argv[3]);
    Color outer = *(Color*)DATA_PTR(argv[4]);

    Image* retval = (Image*)mrb_malloc(mrb, sizeof(Image));
    *retval = GenImageGradientRadial(width, height, density, inner, outer); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibImage, &mrb_raylib_struct_Image, retval));
}

static mrb_value mrb_raylib_GenImageGradientSquare(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    int width = mrb_as_int(mrb, argv[0]);
    int height = mrb_as_int(mrb, argv[1]);
    float density = mrb_as_float(mrb, argv[2]);
    Color inner = *(Color*)DATA_PTR(argv[3]);
    Color outer = *(Color*)DATA_PTR(argv[4]);

    Image* retval = (Image*)mrb_malloc(mrb, sizeof(Image));
    *retval = GenImageGradientSquare(width, height, density, inner, outer); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibImage, &mrb_raylib_struct_Image, retval));
}

static mrb_value mrb_raylib_GenImageChecked(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[6];
    void* ptrs[6] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], };
    mrb_get_args_a(mrb, "oooooo", ptrs);
    int width = mrb_as_int(mrb, argv[0]);
    int height = mrb_as_int(mrb, argv[1]);
    int checksX = mrb_as_int(mrb, argv[2]);
    int checksY = mrb_as_int(mrb, argv[3]);
    Color col1 = *(Color*)DATA_PTR(argv[4]);
    Color col2 = *(Color*)DATA_PTR(argv[5]);

    Image* retval = (Image*)mrb_malloc(mrb, sizeof(Image));
    *retval = GenImageChecked(width, height, checksX, checksY, col1, col2); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibImage, &mrb_raylib_struct_Image, retval));
}

static mrb_value mrb_raylib_GenImageWhiteNoise(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    int width = mrb_as_int(mrb, argv[0]);
    int height = mrb_as_int(mrb, argv[1]);
    float factor = mrb_as_float(mrb, argv[2]);

    Image* retval = (Image*)mrb_malloc(mrb, sizeof(Image));
    *retval = GenImageWhiteNoise(width, height, factor); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibImage, &mrb_raylib_struct_Image, retval));
}

static mrb_value mrb_raylib_GenImagePerlinNoise(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    int width = mrb_as_int(mrb, argv[0]);
    int height = mrb_as_int(mrb, argv[1]);
    int offsetX = mrb_as_int(mrb, argv[2]);
    int offsetY = mrb_as_int(mrb, argv[3]);
    float scale = mrb_as_float(mrb, argv[4]);

    Image* retval = (Image*)mrb_malloc(mrb, sizeof(Image));
    *retval = GenImagePerlinNoise(width, height, offsetX, offsetY, scale); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibImage, &mrb_raylib_struct_Image, retval));
}

static mrb_value mrb_raylib_GenImageCellular(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    int width = mrb_as_int(mrb, argv[0]);
    int height = mrb_as_int(mrb, argv[1]);
    int tileSize = mrb_as_int(mrb, argv[2]);

    Image* retval = (Image*)mrb_malloc(mrb, sizeof(Image));
    *retval = GenImageCellular(width, height, tileSize); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibImage, &mrb_raylib_struct_Image, retval));
}

static mrb_value mrb_raylib_GenImageText(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    int width = mrb_as_int(mrb, argv[0]);
    int height = mrb_as_int(mrb, argv[1]);
    const char * text = DATA_PTR(argv[2]);

    Image* retval = (Image*)mrb_malloc(mrb, sizeof(Image));
    *retval = GenImageText(width, height, text); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibImage, &mrb_raylib_struct_Image, retval));
}

static mrb_value mrb_raylib_ImageCopy(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Image image = *(Image*)DATA_PTR(argv[0]);

    Image* retval = (Image*)mrb_malloc(mrb, sizeof(Image));
    *retval = ImageCopy(image); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibImage, &mrb_raylib_struct_Image, retval));
}

static mrb_value mrb_raylib_ImageFromImage(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Image image = *(Image*)DATA_PTR(argv[0]);
    Rectangle rec = *(Rectangle*)DATA_PTR(argv[1]);

    Image* retval = (Image*)mrb_malloc(mrb, sizeof(Image));
    *retval = ImageFromImage(image, rec); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibImage, &mrb_raylib_struct_Image, retval));
}

static mrb_value mrb_raylib_ImageText(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    const char * text = DATA_PTR(argv[0]);
    int fontSize = mrb_as_int(mrb, argv[1]);
    Color color = *(Color*)DATA_PTR(argv[2]);

    Image* retval = (Image*)mrb_malloc(mrb, sizeof(Image));
    *retval = ImageText(text, fontSize, color); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibImage, &mrb_raylib_struct_Image, retval));
}

static mrb_value mrb_raylib_ImageTextEx(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    Font font = *(Font*)DATA_PTR(argv[0]);
    const char * text = DATA_PTR(argv[1]);
    float fontSize = mrb_as_float(mrb, argv[2]);
    float spacing = mrb_as_float(mrb, argv[3]);
    Color tint = *(Color*)DATA_PTR(argv[4]);

    Image* retval = (Image*)mrb_malloc(mrb, sizeof(Image));
    *retval = ImageTextEx(font, text, fontSize, spacing, tint); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibImage, &mrb_raylib_struct_Image, retval));
}

static mrb_value mrb_raylib_ImageFormat(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Image * image = DATA_PTR(argv[0]);
    int newFormat = mrb_as_int(mrb, argv[1]);

    ImageFormat(image, newFormat);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageToPOT(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Image * image = DATA_PTR(argv[0]);
    Color fill = *(Color*)DATA_PTR(argv[1]);

    ImageToPOT(image, fill);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageCrop(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Image * image = DATA_PTR(argv[0]);
    Rectangle crop = *(Rectangle*)DATA_PTR(argv[1]);

    ImageCrop(image, crop);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageAlphaCrop(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Image * image = DATA_PTR(argv[0]);
    float threshold = mrb_as_float(mrb, argv[1]);

    ImageAlphaCrop(image, threshold);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageAlphaClear(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Image * image = DATA_PTR(argv[0]);
    Color color = *(Color*)DATA_PTR(argv[1]);
    float threshold = mrb_as_float(mrb, argv[2]);

    ImageAlphaClear(image, color, threshold);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageAlphaMask(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Image * image = DATA_PTR(argv[0]);
    Image alphaMask = *(Image*)DATA_PTR(argv[1]);

    ImageAlphaMask(image, alphaMask);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageAlphaPremultiply(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Image * image = DATA_PTR(argv[0]);

    ImageAlphaPremultiply(image);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageBlurGaussian(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Image * image = DATA_PTR(argv[0]);
    int blurSize = mrb_as_int(mrb, argv[1]);

    ImageBlurGaussian(image, blurSize);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageResize(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Image * image = DATA_PTR(argv[0]);
    int newWidth = mrb_as_int(mrb, argv[1]);
    int newHeight = mrb_as_int(mrb, argv[2]);

    ImageResize(image, newWidth, newHeight);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageResizeNN(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Image * image = DATA_PTR(argv[0]);
    int newWidth = mrb_as_int(mrb, argv[1]);
    int newHeight = mrb_as_int(mrb, argv[2]);

    ImageResizeNN(image, newWidth, newHeight);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageResizeCanvas(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[6];
    void* ptrs[6] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], };
    mrb_get_args_a(mrb, "oooooo", ptrs);
    Image * image = DATA_PTR(argv[0]);
    int newWidth = mrb_as_int(mrb, argv[1]);
    int newHeight = mrb_as_int(mrb, argv[2]);
    int offsetX = mrb_as_int(mrb, argv[3]);
    int offsetY = mrb_as_int(mrb, argv[4]);
    Color fill = *(Color*)DATA_PTR(argv[5]);

    ImageResizeCanvas(image, newWidth, newHeight, offsetX, offsetY, fill);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageMipmaps(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Image * image = DATA_PTR(argv[0]);

    ImageMipmaps(image);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageDither(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    Image * image = DATA_PTR(argv[0]);
    int rBpp = mrb_as_int(mrb, argv[1]);
    int gBpp = mrb_as_int(mrb, argv[2]);
    int bBpp = mrb_as_int(mrb, argv[3]);
    int aBpp = mrb_as_int(mrb, argv[4]);

    ImageDither(image, rBpp, gBpp, bBpp, aBpp);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageFlipVertical(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Image * image = DATA_PTR(argv[0]);

    ImageFlipVertical(image);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageFlipHorizontal(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Image * image = DATA_PTR(argv[0]);

    ImageFlipHorizontal(image);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageRotate(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Image * image = DATA_PTR(argv[0]);
    int degrees = mrb_as_int(mrb, argv[1]);

    ImageRotate(image, degrees);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageRotateCW(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Image * image = DATA_PTR(argv[0]);

    ImageRotateCW(image);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageRotateCCW(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Image * image = DATA_PTR(argv[0]);

    ImageRotateCCW(image);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageColorTint(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Image * image = DATA_PTR(argv[0]);
    Color color = *(Color*)DATA_PTR(argv[1]);

    ImageColorTint(image, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageColorInvert(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Image * image = DATA_PTR(argv[0]);

    ImageColorInvert(image);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageColorGrayscale(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Image * image = DATA_PTR(argv[0]);

    ImageColorGrayscale(image);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageColorContrast(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Image * image = DATA_PTR(argv[0]);
    float contrast = mrb_as_float(mrb, argv[1]);

    ImageColorContrast(image, contrast);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageColorBrightness(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Image * image = DATA_PTR(argv[0]);
    int brightness = mrb_as_int(mrb, argv[1]);

    ImageColorBrightness(image, brightness);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageColorReplace(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Image * image = DATA_PTR(argv[0]);
    Color color = *(Color*)DATA_PTR(argv[1]);
    Color replace = *(Color*)DATA_PTR(argv[2]);

    ImageColorReplace(image, color, replace);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_LoadImageColors(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Image image = *(Image*)DATA_PTR(argv[0]);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_LoadImagePalette(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Image image = *(Image*)DATA_PTR(argv[0]);
    int maxPaletteSize = mrb_as_int(mrb, argv[1]);
    int * colorCount = DATA_PTR(argv[2]);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_UnloadImageColors(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Color * colors = DATA_PTR(argv[0]);

    UnloadImageColors(colors);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_UnloadImagePalette(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Color * colors = DATA_PTR(argv[0]);

    UnloadImagePalette(colors);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_GetImageAlphaBorder(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Image image = *(Image*)DATA_PTR(argv[0]);
    float threshold = mrb_as_float(mrb, argv[1]);

    Rectangle* retval = (Rectangle*)mrb_malloc(mrb, sizeof(Rectangle));
    *retval = GetImageAlphaBorder(image, threshold); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibRectangle, &mrb_raylib_struct_Rectangle, retval));
}

static mrb_value mrb_raylib_GetImageColor(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Image image = *(Image*)DATA_PTR(argv[0]);
    int x = mrb_as_int(mrb, argv[1]);
    int y = mrb_as_int(mrb, argv[2]);

    Color* retval = (Color*)mrb_malloc(mrb, sizeof(Color));
    *retval = GetImageColor(image, x, y); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibColor, &mrb_raylib_struct_Color, retval));
}

static mrb_value mrb_raylib_ImageClearBackground(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Image * dst = DATA_PTR(argv[0]);
    Color color = *(Color*)DATA_PTR(argv[1]);

    ImageClearBackground(dst, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageDrawPixel(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    Image * dst = DATA_PTR(argv[0]);
    int posX = mrb_as_int(mrb, argv[1]);
    int posY = mrb_as_int(mrb, argv[2]);
    Color color = *(Color*)DATA_PTR(argv[3]);

    ImageDrawPixel(dst, posX, posY, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageDrawPixelV(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Image * dst = DATA_PTR(argv[0]);
    Vector2 position = *(Vector2*)DATA_PTR(argv[1]);
    Color color = *(Color*)DATA_PTR(argv[2]);

    ImageDrawPixelV(dst, position, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageDrawLine(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[6];
    void* ptrs[6] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], };
    mrb_get_args_a(mrb, "oooooo", ptrs);
    Image * dst = DATA_PTR(argv[0]);
    int startPosX = mrb_as_int(mrb, argv[1]);
    int startPosY = mrb_as_int(mrb, argv[2]);
    int endPosX = mrb_as_int(mrb, argv[3]);
    int endPosY = mrb_as_int(mrb, argv[4]);
    Color color = *(Color*)DATA_PTR(argv[5]);

    ImageDrawLine(dst, startPosX, startPosY, endPosX, endPosY, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageDrawLineV(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    Image * dst = DATA_PTR(argv[0]);
    Vector2 start = *(Vector2*)DATA_PTR(argv[1]);
    Vector2 end = *(Vector2*)DATA_PTR(argv[2]);
    Color color = *(Color*)DATA_PTR(argv[3]);

    ImageDrawLineV(dst, start, end, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageDrawCircle(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    Image * dst = DATA_PTR(argv[0]);
    int centerX = mrb_as_int(mrb, argv[1]);
    int centerY = mrb_as_int(mrb, argv[2]);
    int radius = mrb_as_int(mrb, argv[3]);
    Color color = *(Color*)DATA_PTR(argv[4]);

    ImageDrawCircle(dst, centerX, centerY, radius, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageDrawCircleV(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    Image * dst = DATA_PTR(argv[0]);
    Vector2 center = *(Vector2*)DATA_PTR(argv[1]);
    int radius = mrb_as_int(mrb, argv[2]);
    Color color = *(Color*)DATA_PTR(argv[3]);

    ImageDrawCircleV(dst, center, radius, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageDrawCircleLines(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    Image * dst = DATA_PTR(argv[0]);
    int centerX = mrb_as_int(mrb, argv[1]);
    int centerY = mrb_as_int(mrb, argv[2]);
    int radius = mrb_as_int(mrb, argv[3]);
    Color color = *(Color*)DATA_PTR(argv[4]);

    ImageDrawCircleLines(dst, centerX, centerY, radius, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageDrawCircleLinesV(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    Image * dst = DATA_PTR(argv[0]);
    Vector2 center = *(Vector2*)DATA_PTR(argv[1]);
    int radius = mrb_as_int(mrb, argv[2]);
    Color color = *(Color*)DATA_PTR(argv[3]);

    ImageDrawCircleLinesV(dst, center, radius, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageDrawRectangle(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[6];
    void* ptrs[6] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], };
    mrb_get_args_a(mrb, "oooooo", ptrs);
    Image * dst = DATA_PTR(argv[0]);
    int posX = mrb_as_int(mrb, argv[1]);
    int posY = mrb_as_int(mrb, argv[2]);
    int width = mrb_as_int(mrb, argv[3]);
    int height = mrb_as_int(mrb, argv[4]);
    Color color = *(Color*)DATA_PTR(argv[5]);

    ImageDrawRectangle(dst, posX, posY, width, height, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageDrawRectangleV(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    Image * dst = DATA_PTR(argv[0]);
    Vector2 position = *(Vector2*)DATA_PTR(argv[1]);
    Vector2 size = *(Vector2*)DATA_PTR(argv[2]);
    Color color = *(Color*)DATA_PTR(argv[3]);

    ImageDrawRectangleV(dst, position, size, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageDrawRectangleRec(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Image * dst = DATA_PTR(argv[0]);
    Rectangle rec = *(Rectangle*)DATA_PTR(argv[1]);
    Color color = *(Color*)DATA_PTR(argv[2]);

    ImageDrawRectangleRec(dst, rec, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageDrawRectangleLines(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    Image * dst = DATA_PTR(argv[0]);
    Rectangle rec = *(Rectangle*)DATA_PTR(argv[1]);
    int thick = mrb_as_int(mrb, argv[2]);
    Color color = *(Color*)DATA_PTR(argv[3]);

    ImageDrawRectangleLines(dst, rec, thick, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageDraw(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    Image * dst = DATA_PTR(argv[0]);
    Image src = *(Image*)DATA_PTR(argv[1]);
    Rectangle srcRec = *(Rectangle*)DATA_PTR(argv[2]);
    Rectangle dstRec = *(Rectangle*)DATA_PTR(argv[3]);
    Color tint = *(Color*)DATA_PTR(argv[4]);

    ImageDraw(dst, src, srcRec, dstRec, tint);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageDrawText(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[6];
    void* ptrs[6] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], };
    mrb_get_args_a(mrb, "oooooo", ptrs);
    Image * dst = DATA_PTR(argv[0]);
    const char * text = DATA_PTR(argv[1]);
    int posX = mrb_as_int(mrb, argv[2]);
    int posY = mrb_as_int(mrb, argv[3]);
    int fontSize = mrb_as_int(mrb, argv[4]);
    Color color = *(Color*)DATA_PTR(argv[5]);

    ImageDrawText(dst, text, posX, posY, fontSize, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ImageDrawTextEx(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[7];
    void* ptrs[7] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], &argv[6], };
    mrb_get_args_a(mrb, "ooooooo", ptrs);
    Image * dst = DATA_PTR(argv[0]);
    Font font = *(Font*)DATA_PTR(argv[1]);
    const char * text = DATA_PTR(argv[2]);
    Vector2 position = *(Vector2*)DATA_PTR(argv[3]);
    float fontSize = mrb_as_float(mrb, argv[4]);
    float spacing = mrb_as_float(mrb, argv[5]);
    Color tint = *(Color*)DATA_PTR(argv[6]);

    ImageDrawTextEx(dst, font, text, position, fontSize, spacing, tint);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_LoadTexture(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * fileName = DATA_PTR(argv[0]);

    Texture2D* retval = (Texture2D*)mrb_malloc(mrb, sizeof(Texture2D));
    *retval = LoadTexture(fileName); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibTexture, &mrb_raylib_struct_Texture, retval));
}

static mrb_value mrb_raylib_LoadTextureFromImage(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Image image = *(Image*)DATA_PTR(argv[0]);

    Texture2D* retval = (Texture2D*)mrb_malloc(mrb, sizeof(Texture2D));
    *retval = LoadTextureFromImage(image); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibTexture, &mrb_raylib_struct_Texture, retval));
}

static mrb_value mrb_raylib_LoadTextureCubemap(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Image image = *(Image*)DATA_PTR(argv[0]);
    int layout = mrb_as_int(mrb, argv[1]);

    TextureCubemap* retval = (TextureCubemap*)mrb_malloc(mrb, sizeof(TextureCubemap));
    *retval = LoadTextureCubemap(image, layout); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibTexture, &mrb_raylib_struct_Texture, retval));
}

static mrb_value mrb_raylib_LoadRenderTexture(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    int width = mrb_as_int(mrb, argv[0]);
    int height = mrb_as_int(mrb, argv[1]);

    RenderTexture2D* retval = (RenderTexture2D*)mrb_malloc(mrb, sizeof(RenderTexture2D));
    *retval = LoadRenderTexture(width, height); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibRenderTexture, &mrb_raylib_struct_RenderTexture, retval));
}

static mrb_value mrb_raylib_IsTextureReady(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Texture2D texture = *(Texture2D*)DATA_PTR(argv[0]);

    bool retval = IsTextureReady(texture);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_UnloadTexture(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Texture2D texture = *(Texture2D*)DATA_PTR(argv[0]);

    UnloadTexture(texture);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_IsRenderTextureReady(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    RenderTexture2D target = *(RenderTexture2D*)DATA_PTR(argv[0]);

    bool retval = IsRenderTextureReady(target);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_UnloadRenderTexture(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    RenderTexture2D target = *(RenderTexture2D*)DATA_PTR(argv[0]);

    UnloadRenderTexture(target);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_UpdateTexture(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Texture2D texture = *(Texture2D*)DATA_PTR(argv[0]);
    const void * pixels = DATA_PTR(argv[1]);

    UpdateTexture(texture, pixels);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_UpdateTextureRec(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Texture2D texture = *(Texture2D*)DATA_PTR(argv[0]);
    Rectangle rec = *(Rectangle*)DATA_PTR(argv[1]);
    const void * pixels = DATA_PTR(argv[2]);

    UpdateTextureRec(texture, rec, pixels);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_GenTextureMipmaps(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Texture2D * texture = DATA_PTR(argv[0]);

    GenTextureMipmaps(texture);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetTextureFilter(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Texture2D texture = *(Texture2D*)DATA_PTR(argv[0]);
    int filter = mrb_as_int(mrb, argv[1]);

    SetTextureFilter(texture, filter);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetTextureWrap(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Texture2D texture = *(Texture2D*)DATA_PTR(argv[0]);
    int wrap = mrb_as_int(mrb, argv[1]);

    SetTextureWrap(texture, wrap);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawTexture(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    Texture2D texture = *(Texture2D*)DATA_PTR(argv[0]);
    int posX = mrb_as_int(mrb, argv[1]);
    int posY = mrb_as_int(mrb, argv[2]);
    Color tint = *(Color*)DATA_PTR(argv[3]);

    DrawTexture(texture, posX, posY, tint);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawTextureV(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Texture2D texture = *(Texture2D*)DATA_PTR(argv[0]);
    Vector2 position = *(Vector2*)DATA_PTR(argv[1]);
    Color tint = *(Color*)DATA_PTR(argv[2]);

    DrawTextureV(texture, position, tint);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawTextureEx(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    Texture2D texture = *(Texture2D*)DATA_PTR(argv[0]);
    Vector2 position = *(Vector2*)DATA_PTR(argv[1]);
    float rotation = mrb_as_float(mrb, argv[2]);
    float scale = mrb_as_float(mrb, argv[3]);
    Color tint = *(Color*)DATA_PTR(argv[4]);

    DrawTextureEx(texture, position, rotation, scale, tint);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawTextureRec(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    Texture2D texture = *(Texture2D*)DATA_PTR(argv[0]);
    Rectangle source = *(Rectangle*)DATA_PTR(argv[1]);
    Vector2 position = *(Vector2*)DATA_PTR(argv[2]);
    Color tint = *(Color*)DATA_PTR(argv[3]);

    DrawTextureRec(texture, source, position, tint);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawTexturePro(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[6];
    void* ptrs[6] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], };
    mrb_get_args_a(mrb, "oooooo", ptrs);
    Texture2D texture = *(Texture2D*)DATA_PTR(argv[0]);
    Rectangle source = *(Rectangle*)DATA_PTR(argv[1]);
    Rectangle dest = *(Rectangle*)DATA_PTR(argv[2]);
    Vector2 origin = *(Vector2*)DATA_PTR(argv[3]);
    float rotation = mrb_as_float(mrb, argv[4]);
    Color tint = *(Color*)DATA_PTR(argv[5]);

    DrawTexturePro(texture, source, dest, origin, rotation, tint);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawTextureNPatch(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[6];
    void* ptrs[6] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], };
    mrb_get_args_a(mrb, "oooooo", ptrs);
    Texture2D texture = *(Texture2D*)DATA_PTR(argv[0]);
    NPatchInfo nPatchInfo = *(NPatchInfo*)DATA_PTR(argv[1]);
    Rectangle dest = *(Rectangle*)DATA_PTR(argv[2]);
    Vector2 origin = *(Vector2*)DATA_PTR(argv[3]);
    float rotation = mrb_as_float(mrb, argv[4]);
    Color tint = *(Color*)DATA_PTR(argv[5]);

    DrawTextureNPatch(texture, nPatchInfo, dest, origin, rotation, tint);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_Fade(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Color color = *(Color*)DATA_PTR(argv[0]);
    float alpha = mrb_as_float(mrb, argv[1]);

    Color* retval = (Color*)mrb_malloc(mrb, sizeof(Color));
    *retval = Fade(color, alpha); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibColor, &mrb_raylib_struct_Color, retval));
}

static mrb_value mrb_raylib_ColorToInt(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Color color = *(Color*)DATA_PTR(argv[0]);

    int retval = ColorToInt(color);

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_ColorNormalize(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Color color = *(Color*)DATA_PTR(argv[0]);

    Vector4* retval = (Vector4*)mrb_malloc(mrb, sizeof(Vector4));
    *retval = ColorNormalize(color); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibVector4, &mrb_raylib_struct_Vector4, retval));
}

static mrb_value mrb_raylib_ColorFromNormalized(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Vector4 normalized = *(Vector4*)DATA_PTR(argv[0]);

    Color* retval = (Color*)mrb_malloc(mrb, sizeof(Color));
    *retval = ColorFromNormalized(normalized); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibColor, &mrb_raylib_struct_Color, retval));
}

static mrb_value mrb_raylib_ColorToHSV(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Color color = *(Color*)DATA_PTR(argv[0]);

    Vector3* retval = (Vector3*)mrb_malloc(mrb, sizeof(Vector3));
    *retval = ColorToHSV(color); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibVector3, &mrb_raylib_struct_Vector3, retval));
}

static mrb_value mrb_raylib_ColorFromHSV(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    float hue = mrb_as_float(mrb, argv[0]);
    float saturation = mrb_as_float(mrb, argv[1]);
    float value = mrb_as_float(mrb, argv[2]);

    Color* retval = (Color*)mrb_malloc(mrb, sizeof(Color));
    *retval = ColorFromHSV(hue, saturation, value); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibColor, &mrb_raylib_struct_Color, retval));
}

static mrb_value mrb_raylib_ColorTint(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Color color = *(Color*)DATA_PTR(argv[0]);
    Color tint = *(Color*)DATA_PTR(argv[1]);

    Color* retval = (Color*)mrb_malloc(mrb, sizeof(Color));
    *retval = ColorTint(color, tint); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibColor, &mrb_raylib_struct_Color, retval));
}

static mrb_value mrb_raylib_ColorBrightness(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Color color = *(Color*)DATA_PTR(argv[0]);
    float factor = mrb_as_float(mrb, argv[1]);

    Color* retval = (Color*)mrb_malloc(mrb, sizeof(Color));
    *retval = ColorBrightness(color, factor); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibColor, &mrb_raylib_struct_Color, retval));
}

static mrb_value mrb_raylib_ColorContrast(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Color color = *(Color*)DATA_PTR(argv[0]);
    float contrast = mrb_as_float(mrb, argv[1]);

    Color* retval = (Color*)mrb_malloc(mrb, sizeof(Color));
    *retval = ColorContrast(color, contrast); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibColor, &mrb_raylib_struct_Color, retval));
}

static mrb_value mrb_raylib_ColorAlpha(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Color color = *(Color*)DATA_PTR(argv[0]);
    float alpha = mrb_as_float(mrb, argv[1]);

    Color* retval = (Color*)mrb_malloc(mrb, sizeof(Color));
    *retval = ColorAlpha(color, alpha); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibColor, &mrb_raylib_struct_Color, retval));
}

static mrb_value mrb_raylib_ColorAlphaBlend(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Color dst = *(Color*)DATA_PTR(argv[0]);
    Color src = *(Color*)DATA_PTR(argv[1]);
    Color tint = *(Color*)DATA_PTR(argv[2]);

    Color* retval = (Color*)mrb_malloc(mrb, sizeof(Color));
    *retval = ColorAlphaBlend(dst, src, tint); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibColor, &mrb_raylib_struct_Color, retval));
}

static mrb_value mrb_raylib_GetColor(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    unsigned int hexValue = mrb_as_int(mrb, argv[0]);

    Color* retval = (Color*)mrb_malloc(mrb, sizeof(Color));
    *retval = GetColor(hexValue); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibColor, &mrb_raylib_struct_Color, retval));
}

static mrb_value mrb_raylib_GetPixelColor(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    void * srcPtr = DATA_PTR(argv[0]);
    int format = mrb_as_int(mrb, argv[1]);

    Color* retval = (Color*)mrb_malloc(mrb, sizeof(Color));
    *retval = GetPixelColor(srcPtr, format); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibColor, &mrb_raylib_struct_Color, retval));
}

static mrb_value mrb_raylib_SetPixelColor(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    void * dstPtr = DATA_PTR(argv[0]);
    Color color = *(Color*)DATA_PTR(argv[1]);
    int format = mrb_as_int(mrb, argv[2]);

    SetPixelColor(dstPtr, color, format);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_GetPixelDataSize(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    int width = mrb_as_int(mrb, argv[0]);
    int height = mrb_as_int(mrb, argv[1]);
    int format = mrb_as_int(mrb, argv[2]);

    int retval = GetPixelDataSize(width, height, format);

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_GetFontDefault(mrb_state* mrb, mrb_value self)
{
    Font* retval = (Font*)mrb_malloc(mrb, sizeof(Font));
    *retval = GetFontDefault(); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibFont, &mrb_raylib_struct_Font, retval));
}

static mrb_value mrb_raylib_LoadFont(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * fileName = DATA_PTR(argv[0]);

    Font* retval = (Font*)mrb_malloc(mrb, sizeof(Font));
    *retval = LoadFont(fileName); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibFont, &mrb_raylib_struct_Font, retval));
}

static mrb_value mrb_raylib_LoadFontEx(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    const char * fileName = DATA_PTR(argv[0]);
    int fontSize = mrb_as_int(mrb, argv[1]);
    int * codepoints = DATA_PTR(argv[2]);
    int codepointCount = mrb_as_int(mrb, argv[3]);

    Font* retval = (Font*)mrb_malloc(mrb, sizeof(Font));
    *retval = LoadFontEx(fileName, fontSize, codepoints, codepointCount); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibFont, &mrb_raylib_struct_Font, retval));
}

static mrb_value mrb_raylib_LoadFontFromImage(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Image image = *(Image*)DATA_PTR(argv[0]);
    Color key = *(Color*)DATA_PTR(argv[1]);
    int firstChar = mrb_as_int(mrb, argv[2]);

    Font* retval = (Font*)mrb_malloc(mrb, sizeof(Font));
    *retval = LoadFontFromImage(image, key, firstChar); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibFont, &mrb_raylib_struct_Font, retval));
}

static mrb_value mrb_raylib_LoadFontFromMemory(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[6];
    void* ptrs[6] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], };
    mrb_get_args_a(mrb, "oooooo", ptrs);
    const char * fileType = DATA_PTR(argv[0]);
    const unsigned char * fileData = DATA_PTR(argv[1]);
    int dataSize = mrb_as_int(mrb, argv[2]);
    int fontSize = mrb_as_int(mrb, argv[3]);
    int * codepoints = DATA_PTR(argv[4]);
    int codepointCount = mrb_as_int(mrb, argv[5]);

    Font* retval = (Font*)mrb_malloc(mrb, sizeof(Font));
    *retval = LoadFontFromMemory(fileType, fileData, dataSize, fontSize, codepoints, codepointCount); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibFont, &mrb_raylib_struct_Font, retval));
}

static mrb_value mrb_raylib_IsFontReady(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Font font = *(Font*)DATA_PTR(argv[0]);

    bool retval = IsFontReady(font);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_LoadFontData(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[6];
    void* ptrs[6] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], };
    mrb_get_args_a(mrb, "oooooo", ptrs);
    const unsigned char * fileData = DATA_PTR(argv[0]);
    int dataSize = mrb_as_int(mrb, argv[1]);
    int fontSize = mrb_as_int(mrb, argv[2]);
    int * codepoints = DATA_PTR(argv[3]);
    int codepointCount = mrb_as_int(mrb, argv[4]);
    int type = mrb_as_int(mrb, argv[5]);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_GenImageFontAtlas(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[6];
    void* ptrs[6] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], };
    mrb_get_args_a(mrb, "oooooo", ptrs);
    const GlyphInfo * glyphs = DATA_PTR(argv[0]);
    Rectangle ** glyphRecs = DATA_PTR(argv[1]);
    int glyphCount = mrb_as_int(mrb, argv[2]);
    int fontSize = mrb_as_int(mrb, argv[3]);
    int padding = mrb_as_int(mrb, argv[4]);
    int packMethod = mrb_as_int(mrb, argv[5]);

    Image* retval = (Image*)mrb_malloc(mrb, sizeof(Image));
    *retval = GenImageFontAtlas(glyphs, glyphRecs, glyphCount, fontSize, padding, packMethod); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibImage, &mrb_raylib_struct_Image, retval));
}

static mrb_value mrb_raylib_UnloadFontData(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    GlyphInfo * glyphs = DATA_PTR(argv[0]);
    int glyphCount = mrb_as_int(mrb, argv[1]);

    UnloadFontData(glyphs, glyphCount);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_UnloadFont(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Font font = *(Font*)DATA_PTR(argv[0]);

    UnloadFont(font);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ExportFontAsCode(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Font font = *(Font*)DATA_PTR(argv[0]);
    const char * fileName = DATA_PTR(argv[1]);

    bool retval = ExportFontAsCode(font, fileName);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_DrawFPS(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    int posX = mrb_as_int(mrb, argv[0]);
    int posY = mrb_as_int(mrb, argv[1]);

    DrawFPS(posX, posY);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawText(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    const char * text = DATA_PTR(argv[0]);
    int posX = mrb_as_int(mrb, argv[1]);
    int posY = mrb_as_int(mrb, argv[2]);
    int fontSize = mrb_as_int(mrb, argv[3]);
    Color color = *(Color*)DATA_PTR(argv[4]);

    DrawText(text, posX, posY, fontSize, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawTextEx(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[6];
    void* ptrs[6] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], };
    mrb_get_args_a(mrb, "oooooo", ptrs);
    Font font = *(Font*)DATA_PTR(argv[0]);
    const char * text = DATA_PTR(argv[1]);
    Vector2 position = *(Vector2*)DATA_PTR(argv[2]);
    float fontSize = mrb_as_float(mrb, argv[3]);
    float spacing = mrb_as_float(mrb, argv[4]);
    Color tint = *(Color*)DATA_PTR(argv[5]);

    DrawTextEx(font, text, position, fontSize, spacing, tint);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawTextPro(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[8];
    void* ptrs[8] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], &argv[6], &argv[7], };
    mrb_get_args_a(mrb, "oooooooo", ptrs);
    Font font = *(Font*)DATA_PTR(argv[0]);
    const char * text = DATA_PTR(argv[1]);
    Vector2 position = *(Vector2*)DATA_PTR(argv[2]);
    Vector2 origin = *(Vector2*)DATA_PTR(argv[3]);
    float rotation = mrb_as_float(mrb, argv[4]);
    float fontSize = mrb_as_float(mrb, argv[5]);
    float spacing = mrb_as_float(mrb, argv[6]);
    Color tint = *(Color*)DATA_PTR(argv[7]);

    DrawTextPro(font, text, position, origin, rotation, fontSize, spacing, tint);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawTextCodepoint(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    Font font = *(Font*)DATA_PTR(argv[0]);
    int codepoint = mrb_as_int(mrb, argv[1]);
    Vector2 position = *(Vector2*)DATA_PTR(argv[2]);
    float fontSize = mrb_as_float(mrb, argv[3]);
    Color tint = *(Color*)DATA_PTR(argv[4]);

    DrawTextCodepoint(font, codepoint, position, fontSize, tint);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawTextCodepoints(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[7];
    void* ptrs[7] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], &argv[6], };
    mrb_get_args_a(mrb, "ooooooo", ptrs);
    Font font = *(Font*)DATA_PTR(argv[0]);
    const int * codepoints = DATA_PTR(argv[1]);
    int codepointCount = mrb_as_int(mrb, argv[2]);
    Vector2 position = *(Vector2*)DATA_PTR(argv[3]);
    float fontSize = mrb_as_float(mrb, argv[4]);
    float spacing = mrb_as_float(mrb, argv[5]);
    Color tint = *(Color*)DATA_PTR(argv[6]);

    DrawTextCodepoints(font, codepoints, codepointCount, position, fontSize, spacing, tint);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetTextLineSpacing(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    int spacing = mrb_as_int(mrb, argv[0]);

    SetTextLineSpacing(spacing);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_MeasureText(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    const char * text = DATA_PTR(argv[0]);
    int fontSize = mrb_as_int(mrb, argv[1]);

    int retval = MeasureText(text, fontSize);

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_MeasureTextEx(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    Font font = *(Font*)DATA_PTR(argv[0]);
    const char * text = DATA_PTR(argv[1]);
    float fontSize = mrb_as_float(mrb, argv[2]);
    float spacing = mrb_as_float(mrb, argv[3]);

    Vector2* retval = (Vector2*)mrb_malloc(mrb, sizeof(Vector2));
    *retval = MeasureTextEx(font, text, fontSize, spacing); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibVector2, &mrb_raylib_struct_Vector2, retval));
}

static mrb_value mrb_raylib_GetGlyphIndex(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Font font = *(Font*)DATA_PTR(argv[0]);
    int codepoint = mrb_as_int(mrb, argv[1]);

    int retval = GetGlyphIndex(font, codepoint);

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_GetGlyphInfo(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Font font = *(Font*)DATA_PTR(argv[0]);
    int codepoint = mrb_as_int(mrb, argv[1]);

    GlyphInfo* retval = (GlyphInfo*)mrb_malloc(mrb, sizeof(GlyphInfo));
    *retval = GetGlyphInfo(font, codepoint); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibGlyphInfo, &mrb_raylib_struct_GlyphInfo, retval));
}

static mrb_value mrb_raylib_GetGlyphAtlasRec(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Font font = *(Font*)DATA_PTR(argv[0]);
    int codepoint = mrb_as_int(mrb, argv[1]);

    Rectangle* retval = (Rectangle*)mrb_malloc(mrb, sizeof(Rectangle));
    *retval = GetGlyphAtlasRec(font, codepoint); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibRectangle, &mrb_raylib_struct_Rectangle, retval));
}

static mrb_value mrb_raylib_LoadUTF8(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    const int * codepoints = DATA_PTR(argv[0]);
    int length = mrb_as_int(mrb, argv[1]);

    char * retval = LoadUTF8(codepoints, length);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_UnloadUTF8(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    char * text = DATA_PTR(argv[0]);

    UnloadUTF8(text);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_LoadCodepoints(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    const char * text = DATA_PTR(argv[0]);
    int * count = DATA_PTR(argv[1]);

    int * retval = LoadCodepoints(text, count);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_UnloadCodepoints(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    int * codepoints = DATA_PTR(argv[0]);

    UnloadCodepoints(codepoints);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_GetCodepointCount(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * text = DATA_PTR(argv[0]);

    int retval = GetCodepointCount(text);

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_GetCodepoint(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    const char * text = DATA_PTR(argv[0]);
    int * codepointSize = DATA_PTR(argv[1]);

    int retval = GetCodepoint(text, codepointSize);

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_GetCodepointNext(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    const char * text = DATA_PTR(argv[0]);
    int * codepointSize = DATA_PTR(argv[1]);

    int retval = GetCodepointNext(text, codepointSize);

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_GetCodepointPrevious(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    const char * text = DATA_PTR(argv[0]);
    int * codepointSize = DATA_PTR(argv[1]);

    int retval = GetCodepointPrevious(text, codepointSize);

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_CodepointToUTF8(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    int codepoint = mrb_as_int(mrb, argv[0]);
    int * utf8Size = DATA_PTR(argv[1]);

    const char * retval = CodepointToUTF8(codepoint, utf8Size);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_TextCopy(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    char * dst = DATA_PTR(argv[0]);
    const char * src = DATA_PTR(argv[1]);

    int retval = TextCopy(dst, src);

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_TextIsEqual(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    const char * text1 = DATA_PTR(argv[0]);
    const char * text2 = DATA_PTR(argv[1]);

    bool retval = TextIsEqual(text1, text2);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_TextLength(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * text = DATA_PTR(argv[0]);

    unsigned int retval = TextLength(text);

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_TextSubtext(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    const char * text = DATA_PTR(argv[0]);
    int position = mrb_as_int(mrb, argv[1]);
    int length = mrb_as_int(mrb, argv[2]);

    const char * retval = TextSubtext(text, position, length);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_TextReplace(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    char * text = DATA_PTR(argv[0]);
    const char * replace = DATA_PTR(argv[1]);
    const char * by = DATA_PTR(argv[2]);

    char * retval = TextReplace(text, replace, by);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_TextInsert(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    const char * text = DATA_PTR(argv[0]);
    const char * insert = DATA_PTR(argv[1]);
    int position = mrb_as_int(mrb, argv[2]);

    char * retval = TextInsert(text, insert, position);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_TextJoin(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    const char ** textList = DATA_PTR(argv[0]);
    int count = mrb_as_int(mrb, argv[1]);
    const char * delimiter = DATA_PTR(argv[2]);

    const char * retval = TextJoin(textList, count, delimiter);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_TextSplit(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    const char * text = DATA_PTR(argv[0]);
    char delimiter = mrb_as_int(mrb, argv[1]);
    int * count = DATA_PTR(argv[2]);

    const char ** retval = TextSplit(text, delimiter, count);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_TextAppend(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    char * text = DATA_PTR(argv[0]);
    const char * append = DATA_PTR(argv[1]);
    int * position = DATA_PTR(argv[2]);

    TextAppend(text, append, position);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_TextFindIndex(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    const char * text = DATA_PTR(argv[0]);
    const char * find = DATA_PTR(argv[1]);

    int retval = TextFindIndex(text, find);

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_TextToUpper(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * text = DATA_PTR(argv[0]);

    const char * retval = TextToUpper(text);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_TextToLower(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * text = DATA_PTR(argv[0]);

    const char * retval = TextToLower(text);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_TextToPascal(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * text = DATA_PTR(argv[0]);

    const char * retval = TextToPascal(text);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_TextToInteger(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * text = DATA_PTR(argv[0]);

    int retval = TextToInteger(text);

    return mrb_int_value(mrb, retval);
}

static mrb_value mrb_raylib_DrawLine3D(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Vector3 startPos = *(Vector3*)DATA_PTR(argv[0]);
    Vector3 endPos = *(Vector3*)DATA_PTR(argv[1]);
    Color color = *(Color*)DATA_PTR(argv[2]);

    DrawLine3D(startPos, endPos, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawPoint3D(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Vector3 position = *(Vector3*)DATA_PTR(argv[0]);
    Color color = *(Color*)DATA_PTR(argv[1]);

    DrawPoint3D(position, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawCircle3D(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    Vector3 center = *(Vector3*)DATA_PTR(argv[0]);
    float radius = mrb_as_float(mrb, argv[1]);
    Vector3 rotationAxis = *(Vector3*)DATA_PTR(argv[2]);
    float rotationAngle = mrb_as_float(mrb, argv[3]);
    Color color = *(Color*)DATA_PTR(argv[4]);

    DrawCircle3D(center, radius, rotationAxis, rotationAngle, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawTriangle3D(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    Vector3 v1 = *(Vector3*)DATA_PTR(argv[0]);
    Vector3 v2 = *(Vector3*)DATA_PTR(argv[1]);
    Vector3 v3 = *(Vector3*)DATA_PTR(argv[2]);
    Color color = *(Color*)DATA_PTR(argv[3]);

    DrawTriangle3D(v1, v2, v3, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawTriangleStrip3D(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Vector3 * points = DATA_PTR(argv[0]);
    int pointCount = mrb_as_int(mrb, argv[1]);
    Color color = *(Color*)DATA_PTR(argv[2]);

    DrawTriangleStrip3D(points, pointCount, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawCube(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    Vector3 position = *(Vector3*)DATA_PTR(argv[0]);
    float width = mrb_as_float(mrb, argv[1]);
    float height = mrb_as_float(mrb, argv[2]);
    float length = mrb_as_float(mrb, argv[3]);
    Color color = *(Color*)DATA_PTR(argv[4]);

    DrawCube(position, width, height, length, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawCubeV(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Vector3 position = *(Vector3*)DATA_PTR(argv[0]);
    Vector3 size = *(Vector3*)DATA_PTR(argv[1]);
    Color color = *(Color*)DATA_PTR(argv[2]);

    DrawCubeV(position, size, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawCubeWires(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    Vector3 position = *(Vector3*)DATA_PTR(argv[0]);
    float width = mrb_as_float(mrb, argv[1]);
    float height = mrb_as_float(mrb, argv[2]);
    float length = mrb_as_float(mrb, argv[3]);
    Color color = *(Color*)DATA_PTR(argv[4]);

    DrawCubeWires(position, width, height, length, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawCubeWiresV(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Vector3 position = *(Vector3*)DATA_PTR(argv[0]);
    Vector3 size = *(Vector3*)DATA_PTR(argv[1]);
    Color color = *(Color*)DATA_PTR(argv[2]);

    DrawCubeWiresV(position, size, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawSphere(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Vector3 centerPos = *(Vector3*)DATA_PTR(argv[0]);
    float radius = mrb_as_float(mrb, argv[1]);
    Color color = *(Color*)DATA_PTR(argv[2]);

    DrawSphere(centerPos, radius, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawSphereEx(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    Vector3 centerPos = *(Vector3*)DATA_PTR(argv[0]);
    float radius = mrb_as_float(mrb, argv[1]);
    int rings = mrb_as_int(mrb, argv[2]);
    int slices = mrb_as_int(mrb, argv[3]);
    Color color = *(Color*)DATA_PTR(argv[4]);

    DrawSphereEx(centerPos, radius, rings, slices, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawSphereWires(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    Vector3 centerPos = *(Vector3*)DATA_PTR(argv[0]);
    float radius = mrb_as_float(mrb, argv[1]);
    int rings = mrb_as_int(mrb, argv[2]);
    int slices = mrb_as_int(mrb, argv[3]);
    Color color = *(Color*)DATA_PTR(argv[4]);

    DrawSphereWires(centerPos, radius, rings, slices, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawCylinder(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[6];
    void* ptrs[6] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], };
    mrb_get_args_a(mrb, "oooooo", ptrs);
    Vector3 position = *(Vector3*)DATA_PTR(argv[0]);
    float radiusTop = mrb_as_float(mrb, argv[1]);
    float radiusBottom = mrb_as_float(mrb, argv[2]);
    float height = mrb_as_float(mrb, argv[3]);
    int slices = mrb_as_int(mrb, argv[4]);
    Color color = *(Color*)DATA_PTR(argv[5]);

    DrawCylinder(position, radiusTop, radiusBottom, height, slices, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawCylinderEx(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[6];
    void* ptrs[6] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], };
    mrb_get_args_a(mrb, "oooooo", ptrs);
    Vector3 startPos = *(Vector3*)DATA_PTR(argv[0]);
    Vector3 endPos = *(Vector3*)DATA_PTR(argv[1]);
    float startRadius = mrb_as_float(mrb, argv[2]);
    float endRadius = mrb_as_float(mrb, argv[3]);
    int sides = mrb_as_int(mrb, argv[4]);
    Color color = *(Color*)DATA_PTR(argv[5]);

    DrawCylinderEx(startPos, endPos, startRadius, endRadius, sides, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawCylinderWires(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[6];
    void* ptrs[6] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], };
    mrb_get_args_a(mrb, "oooooo", ptrs);
    Vector3 position = *(Vector3*)DATA_PTR(argv[0]);
    float radiusTop = mrb_as_float(mrb, argv[1]);
    float radiusBottom = mrb_as_float(mrb, argv[2]);
    float height = mrb_as_float(mrb, argv[3]);
    int slices = mrb_as_int(mrb, argv[4]);
    Color color = *(Color*)DATA_PTR(argv[5]);

    DrawCylinderWires(position, radiusTop, radiusBottom, height, slices, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawCylinderWiresEx(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[6];
    void* ptrs[6] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], };
    mrb_get_args_a(mrb, "oooooo", ptrs);
    Vector3 startPos = *(Vector3*)DATA_PTR(argv[0]);
    Vector3 endPos = *(Vector3*)DATA_PTR(argv[1]);
    float startRadius = mrb_as_float(mrb, argv[2]);
    float endRadius = mrb_as_float(mrb, argv[3]);
    int sides = mrb_as_int(mrb, argv[4]);
    Color color = *(Color*)DATA_PTR(argv[5]);

    DrawCylinderWiresEx(startPos, endPos, startRadius, endRadius, sides, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawCapsule(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[6];
    void* ptrs[6] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], };
    mrb_get_args_a(mrb, "oooooo", ptrs);
    Vector3 startPos = *(Vector3*)DATA_PTR(argv[0]);
    Vector3 endPos = *(Vector3*)DATA_PTR(argv[1]);
    float radius = mrb_as_float(mrb, argv[2]);
    int slices = mrb_as_int(mrb, argv[3]);
    int rings = mrb_as_int(mrb, argv[4]);
    Color color = *(Color*)DATA_PTR(argv[5]);

    DrawCapsule(startPos, endPos, radius, slices, rings, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawCapsuleWires(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[6];
    void* ptrs[6] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], };
    mrb_get_args_a(mrb, "oooooo", ptrs);
    Vector3 startPos = *(Vector3*)DATA_PTR(argv[0]);
    Vector3 endPos = *(Vector3*)DATA_PTR(argv[1]);
    float radius = mrb_as_float(mrb, argv[2]);
    int slices = mrb_as_int(mrb, argv[3]);
    int rings = mrb_as_int(mrb, argv[4]);
    Color color = *(Color*)DATA_PTR(argv[5]);

    DrawCapsuleWires(startPos, endPos, radius, slices, rings, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawPlane(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Vector3 centerPos = *(Vector3*)DATA_PTR(argv[0]);
    Vector2 size = *(Vector2*)DATA_PTR(argv[1]);
    Color color = *(Color*)DATA_PTR(argv[2]);

    DrawPlane(centerPos, size, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawRay(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Ray ray = *(Ray*)DATA_PTR(argv[0]);
    Color color = *(Color*)DATA_PTR(argv[1]);

    DrawRay(ray, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawGrid(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    int slices = mrb_as_int(mrb, argv[0]);
    float spacing = mrb_as_float(mrb, argv[1]);

    DrawGrid(slices, spacing);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_LoadModel(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * fileName = DATA_PTR(argv[0]);

    Model* retval = (Model*)mrb_malloc(mrb, sizeof(Model));
    *retval = LoadModel(fileName); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibModel, &mrb_raylib_struct_Model, retval));
}

static mrb_value mrb_raylib_LoadModelFromMesh(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Mesh mesh = *(Mesh*)DATA_PTR(argv[0]);

    Model* retval = (Model*)mrb_malloc(mrb, sizeof(Model));
    *retval = LoadModelFromMesh(mesh); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibModel, &mrb_raylib_struct_Model, retval));
}

static mrb_value mrb_raylib_IsModelReady(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Model model = *(Model*)DATA_PTR(argv[0]);

    bool retval = IsModelReady(model);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_UnloadModel(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Model model = *(Model*)DATA_PTR(argv[0]);

    UnloadModel(model);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_GetModelBoundingBox(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Model model = *(Model*)DATA_PTR(argv[0]);

    BoundingBox* retval = (BoundingBox*)mrb_malloc(mrb, sizeof(BoundingBox));
    *retval = GetModelBoundingBox(model); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibBoundingBox, &mrb_raylib_struct_BoundingBox, retval));
}

static mrb_value mrb_raylib_DrawModel(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    Model model = *(Model*)DATA_PTR(argv[0]);
    Vector3 position = *(Vector3*)DATA_PTR(argv[1]);
    float scale = mrb_as_float(mrb, argv[2]);
    Color tint = *(Color*)DATA_PTR(argv[3]);

    DrawModel(model, position, scale, tint);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawModelEx(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[6];
    void* ptrs[6] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], };
    mrb_get_args_a(mrb, "oooooo", ptrs);
    Model model = *(Model*)DATA_PTR(argv[0]);
    Vector3 position = *(Vector3*)DATA_PTR(argv[1]);
    Vector3 rotationAxis = *(Vector3*)DATA_PTR(argv[2]);
    float rotationAngle = mrb_as_float(mrb, argv[3]);
    Vector3 scale = *(Vector3*)DATA_PTR(argv[4]);
    Color tint = *(Color*)DATA_PTR(argv[5]);

    DrawModelEx(model, position, rotationAxis, rotationAngle, scale, tint);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawModelWires(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    Model model = *(Model*)DATA_PTR(argv[0]);
    Vector3 position = *(Vector3*)DATA_PTR(argv[1]);
    float scale = mrb_as_float(mrb, argv[2]);
    Color tint = *(Color*)DATA_PTR(argv[3]);

    DrawModelWires(model, position, scale, tint);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawModelWiresEx(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[6];
    void* ptrs[6] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], };
    mrb_get_args_a(mrb, "oooooo", ptrs);
    Model model = *(Model*)DATA_PTR(argv[0]);
    Vector3 position = *(Vector3*)DATA_PTR(argv[1]);
    Vector3 rotationAxis = *(Vector3*)DATA_PTR(argv[2]);
    float rotationAngle = mrb_as_float(mrb, argv[3]);
    Vector3 scale = *(Vector3*)DATA_PTR(argv[4]);
    Color tint = *(Color*)DATA_PTR(argv[5]);

    DrawModelWiresEx(model, position, rotationAxis, rotationAngle, scale, tint);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawBoundingBox(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    BoundingBox box = *(BoundingBox*)DATA_PTR(argv[0]);
    Color color = *(Color*)DATA_PTR(argv[1]);

    DrawBoundingBox(box, color);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawBillboard(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    Camera camera = *(Camera*)DATA_PTR(argv[0]);
    Texture2D texture = *(Texture2D*)DATA_PTR(argv[1]);
    Vector3 position = *(Vector3*)DATA_PTR(argv[2]);
    float size = mrb_as_float(mrb, argv[3]);
    Color tint = *(Color*)DATA_PTR(argv[4]);

    DrawBillboard(camera, texture, position, size, tint);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawBillboardRec(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[6];
    void* ptrs[6] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], };
    mrb_get_args_a(mrb, "oooooo", ptrs);
    Camera camera = *(Camera*)DATA_PTR(argv[0]);
    Texture2D texture = *(Texture2D*)DATA_PTR(argv[1]);
    Rectangle source = *(Rectangle*)DATA_PTR(argv[2]);
    Vector3 position = *(Vector3*)DATA_PTR(argv[3]);
    Vector2 size = *(Vector2*)DATA_PTR(argv[4]);
    Color tint = *(Color*)DATA_PTR(argv[5]);

    DrawBillboardRec(camera, texture, source, position, size, tint);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawBillboardPro(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[9];
    void* ptrs[9] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], &argv[5], &argv[6], &argv[7], &argv[8], };
    mrb_get_args_a(mrb, "ooooooooo", ptrs);
    Camera camera = *(Camera*)DATA_PTR(argv[0]);
    Texture2D texture = *(Texture2D*)DATA_PTR(argv[1]);
    Rectangle source = *(Rectangle*)DATA_PTR(argv[2]);
    Vector3 position = *(Vector3*)DATA_PTR(argv[3]);
    Vector3 up = *(Vector3*)DATA_PTR(argv[4]);
    Vector2 size = *(Vector2*)DATA_PTR(argv[5]);
    Vector2 origin = *(Vector2*)DATA_PTR(argv[6]);
    float rotation = mrb_as_float(mrb, argv[7]);
    Color tint = *(Color*)DATA_PTR(argv[8]);

    DrawBillboardPro(camera, texture, source, position, up, size, origin, rotation, tint);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_UploadMesh(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Mesh * mesh = DATA_PTR(argv[0]);
    bool dynamic = mrb_as_int(mrb, argv[1]);

    UploadMesh(mesh, dynamic);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_UpdateMeshBuffer(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    Mesh mesh = *(Mesh*)DATA_PTR(argv[0]);
    int index = mrb_as_int(mrb, argv[1]);
    const void * data = DATA_PTR(argv[2]);
    int dataSize = mrb_as_int(mrb, argv[3]);
    int offset = mrb_as_int(mrb, argv[4]);

    UpdateMeshBuffer(mesh, index, data, dataSize, offset);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_UnloadMesh(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Mesh mesh = *(Mesh*)DATA_PTR(argv[0]);

    UnloadMesh(mesh);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawMesh(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Mesh mesh = *(Mesh*)DATA_PTR(argv[0]);
    Material material = *(Material*)DATA_PTR(argv[1]);
    Matrix transform = *(Matrix*)DATA_PTR(argv[2]);

    DrawMesh(mesh, material, transform);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DrawMeshInstanced(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    Mesh mesh = *(Mesh*)DATA_PTR(argv[0]);
    Material material = *(Material*)DATA_PTR(argv[1]);
    const Matrix * transforms = DATA_PTR(argv[2]);
    int instances = mrb_as_int(mrb, argv[3]);

    DrawMeshInstanced(mesh, material, transforms, instances);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ExportMesh(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Mesh mesh = *(Mesh*)DATA_PTR(argv[0]);
    const char * fileName = DATA_PTR(argv[1]);

    bool retval = ExportMesh(mesh, fileName);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_GetMeshBoundingBox(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Mesh mesh = *(Mesh*)DATA_PTR(argv[0]);

    BoundingBox* retval = (BoundingBox*)mrb_malloc(mrb, sizeof(BoundingBox));
    *retval = GetMeshBoundingBox(mesh); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibBoundingBox, &mrb_raylib_struct_BoundingBox, retval));
}

static mrb_value mrb_raylib_GenMeshTangents(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Mesh * mesh = DATA_PTR(argv[0]);

    GenMeshTangents(mesh);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_GenMeshPoly(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    int sides = mrb_as_int(mrb, argv[0]);
    float radius = mrb_as_float(mrb, argv[1]);

    Mesh* retval = (Mesh*)mrb_malloc(mrb, sizeof(Mesh));
    *retval = GenMeshPoly(sides, radius); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibMesh, &mrb_raylib_struct_Mesh, retval));
}

static mrb_value mrb_raylib_GenMeshPlane(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    float width = mrb_as_float(mrb, argv[0]);
    float length = mrb_as_float(mrb, argv[1]);
    int resX = mrb_as_int(mrb, argv[2]);
    int resZ = mrb_as_int(mrb, argv[3]);

    Mesh* retval = (Mesh*)mrb_malloc(mrb, sizeof(Mesh));
    *retval = GenMeshPlane(width, length, resX, resZ); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibMesh, &mrb_raylib_struct_Mesh, retval));
}

static mrb_value mrb_raylib_GenMeshCube(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    float width = mrb_as_float(mrb, argv[0]);
    float height = mrb_as_float(mrb, argv[1]);
    float length = mrb_as_float(mrb, argv[2]);

    Mesh* retval = (Mesh*)mrb_malloc(mrb, sizeof(Mesh));
    *retval = GenMeshCube(width, height, length); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibMesh, &mrb_raylib_struct_Mesh, retval));
}

static mrb_value mrb_raylib_GenMeshSphere(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    float radius = mrb_as_float(mrb, argv[0]);
    int rings = mrb_as_int(mrb, argv[1]);
    int slices = mrb_as_int(mrb, argv[2]);

    Mesh* retval = (Mesh*)mrb_malloc(mrb, sizeof(Mesh));
    *retval = GenMeshSphere(radius, rings, slices); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibMesh, &mrb_raylib_struct_Mesh, retval));
}

static mrb_value mrb_raylib_GenMeshHemiSphere(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    float radius = mrb_as_float(mrb, argv[0]);
    int rings = mrb_as_int(mrb, argv[1]);
    int slices = mrb_as_int(mrb, argv[2]);

    Mesh* retval = (Mesh*)mrb_malloc(mrb, sizeof(Mesh));
    *retval = GenMeshHemiSphere(radius, rings, slices); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibMesh, &mrb_raylib_struct_Mesh, retval));
}

static mrb_value mrb_raylib_GenMeshCylinder(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    float radius = mrb_as_float(mrb, argv[0]);
    float height = mrb_as_float(mrb, argv[1]);
    int slices = mrb_as_int(mrb, argv[2]);

    Mesh* retval = (Mesh*)mrb_malloc(mrb, sizeof(Mesh));
    *retval = GenMeshCylinder(radius, height, slices); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibMesh, &mrb_raylib_struct_Mesh, retval));
}

static mrb_value mrb_raylib_GenMeshCone(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    float radius = mrb_as_float(mrb, argv[0]);
    float height = mrb_as_float(mrb, argv[1]);
    int slices = mrb_as_int(mrb, argv[2]);

    Mesh* retval = (Mesh*)mrb_malloc(mrb, sizeof(Mesh));
    *retval = GenMeshCone(radius, height, slices); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibMesh, &mrb_raylib_struct_Mesh, retval));
}

static mrb_value mrb_raylib_GenMeshTorus(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    float radius = mrb_as_float(mrb, argv[0]);
    float size = mrb_as_float(mrb, argv[1]);
    int radSeg = mrb_as_int(mrb, argv[2]);
    int sides = mrb_as_int(mrb, argv[3]);

    Mesh* retval = (Mesh*)mrb_malloc(mrb, sizeof(Mesh));
    *retval = GenMeshTorus(radius, size, radSeg, sides); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibMesh, &mrb_raylib_struct_Mesh, retval));
}

static mrb_value mrb_raylib_GenMeshKnot(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    float radius = mrb_as_float(mrb, argv[0]);
    float size = mrb_as_float(mrb, argv[1]);
    int radSeg = mrb_as_int(mrb, argv[2]);
    int sides = mrb_as_int(mrb, argv[3]);

    Mesh* retval = (Mesh*)mrb_malloc(mrb, sizeof(Mesh));
    *retval = GenMeshKnot(radius, size, radSeg, sides); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibMesh, &mrb_raylib_struct_Mesh, retval));
}

static mrb_value mrb_raylib_GenMeshHeightmap(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Image heightmap = *(Image*)DATA_PTR(argv[0]);
    Vector3 size = *(Vector3*)DATA_PTR(argv[1]);

    Mesh* retval = (Mesh*)mrb_malloc(mrb, sizeof(Mesh));
    *retval = GenMeshHeightmap(heightmap, size); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibMesh, &mrb_raylib_struct_Mesh, retval));
}

static mrb_value mrb_raylib_GenMeshCubicmap(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Image cubicmap = *(Image*)DATA_PTR(argv[0]);
    Vector3 cubeSize = *(Vector3*)DATA_PTR(argv[1]);

    Mesh* retval = (Mesh*)mrb_malloc(mrb, sizeof(Mesh));
    *retval = GenMeshCubicmap(cubicmap, cubeSize); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibMesh, &mrb_raylib_struct_Mesh, retval));
}

static mrb_value mrb_raylib_LoadMaterials(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    const char * fileName = DATA_PTR(argv[0]);
    int * materialCount = DATA_PTR(argv[1]);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_LoadMaterialDefault(mrb_state* mrb, mrb_value self)
{
    Material* retval = (Material*)mrb_malloc(mrb, sizeof(Material));
    *retval = LoadMaterialDefault(); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibMaterial, &mrb_raylib_struct_Material, retval));
}

static mrb_value mrb_raylib_IsMaterialReady(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Material material = *(Material*)DATA_PTR(argv[0]);

    bool retval = IsMaterialReady(material);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_UnloadMaterial(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Material material = *(Material*)DATA_PTR(argv[0]);

    UnloadMaterial(material);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetMaterialTexture(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Material * material = DATA_PTR(argv[0]);
    int mapType = mrb_as_int(mrb, argv[1]);
    Texture2D texture = *(Texture2D*)DATA_PTR(argv[2]);

    SetMaterialTexture(material, mapType, texture);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetModelMeshMaterial(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Model * model = DATA_PTR(argv[0]);
    int meshId = mrb_as_int(mrb, argv[1]);
    int materialId = mrb_as_int(mrb, argv[2]);

    SetModelMeshMaterial(model, meshId, materialId);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_LoadModelAnimations(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    const char * fileName = DATA_PTR(argv[0]);
    int * animCount = DATA_PTR(argv[1]);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_UpdateModelAnimation(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Model model = *(Model*)DATA_PTR(argv[0]);
    ModelAnimation anim = *(ModelAnimation*)DATA_PTR(argv[1]);
    int frame = mrb_as_int(mrb, argv[2]);

    UpdateModelAnimation(model, anim, frame);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_UnloadModelAnimation(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    ModelAnimation anim = *(ModelAnimation*)DATA_PTR(argv[0]);

    UnloadModelAnimation(anim);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_UnloadModelAnimations(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    ModelAnimation * animations = DATA_PTR(argv[0]);
    int animCount = mrb_as_int(mrb, argv[1]);

    UnloadModelAnimations(animations, animCount);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_IsModelAnimationValid(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Model model = *(Model*)DATA_PTR(argv[0]);
    ModelAnimation anim = *(ModelAnimation*)DATA_PTR(argv[1]);

    bool retval = IsModelAnimationValid(model, anim);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_CheckCollisionSpheres(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    Vector3 center1 = *(Vector3*)DATA_PTR(argv[0]);
    float radius1 = mrb_as_float(mrb, argv[1]);
    Vector3 center2 = *(Vector3*)DATA_PTR(argv[2]);
    float radius2 = mrb_as_float(mrb, argv[3]);

    bool retval = CheckCollisionSpheres(center1, radius1, center2, radius2);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_CheckCollisionBoxes(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    BoundingBox box1 = *(BoundingBox*)DATA_PTR(argv[0]);
    BoundingBox box2 = *(BoundingBox*)DATA_PTR(argv[1]);

    bool retval = CheckCollisionBoxes(box1, box2);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_CheckCollisionBoxSphere(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    BoundingBox box = *(BoundingBox*)DATA_PTR(argv[0]);
    Vector3 center = *(Vector3*)DATA_PTR(argv[1]);
    float radius = mrb_as_float(mrb, argv[2]);

    bool retval = CheckCollisionBoxSphere(box, center, radius);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_GetRayCollisionSphere(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Ray ray = *(Ray*)DATA_PTR(argv[0]);
    Vector3 center = *(Vector3*)DATA_PTR(argv[1]);
    float radius = mrb_as_float(mrb, argv[2]);

    RayCollision* retval = (RayCollision*)mrb_malloc(mrb, sizeof(RayCollision));
    *retval = GetRayCollisionSphere(ray, center, radius); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibRayCollision, &mrb_raylib_struct_RayCollision, retval));
}

static mrb_value mrb_raylib_GetRayCollisionBox(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Ray ray = *(Ray*)DATA_PTR(argv[0]);
    BoundingBox box = *(BoundingBox*)DATA_PTR(argv[1]);

    RayCollision* retval = (RayCollision*)mrb_malloc(mrb, sizeof(RayCollision));
    *retval = GetRayCollisionBox(ray, box); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibRayCollision, &mrb_raylib_struct_RayCollision, retval));
}

static mrb_value mrb_raylib_GetRayCollisionMesh(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Ray ray = *(Ray*)DATA_PTR(argv[0]);
    Mesh mesh = *(Mesh*)DATA_PTR(argv[1]);
    Matrix transform = *(Matrix*)DATA_PTR(argv[2]);

    RayCollision* retval = (RayCollision*)mrb_malloc(mrb, sizeof(RayCollision));
    *retval = GetRayCollisionMesh(ray, mesh, transform); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibRayCollision, &mrb_raylib_struct_RayCollision, retval));
}

static mrb_value mrb_raylib_GetRayCollisionTriangle(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    Ray ray = *(Ray*)DATA_PTR(argv[0]);
    Vector3 p1 = *(Vector3*)DATA_PTR(argv[1]);
    Vector3 p2 = *(Vector3*)DATA_PTR(argv[2]);
    Vector3 p3 = *(Vector3*)DATA_PTR(argv[3]);

    RayCollision* retval = (RayCollision*)mrb_malloc(mrb, sizeof(RayCollision));
    *retval = GetRayCollisionTriangle(ray, p1, p2, p3); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibRayCollision, &mrb_raylib_struct_RayCollision, retval));
}

static mrb_value mrb_raylib_GetRayCollisionQuad(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[5];
    void* ptrs[5] = { &argv[0], &argv[1], &argv[2], &argv[3], &argv[4], };
    mrb_get_args_a(mrb, "ooooo", ptrs);
    Ray ray = *(Ray*)DATA_PTR(argv[0]);
    Vector3 p1 = *(Vector3*)DATA_PTR(argv[1]);
    Vector3 p2 = *(Vector3*)DATA_PTR(argv[2]);
    Vector3 p3 = *(Vector3*)DATA_PTR(argv[3]);
    Vector3 p4 = *(Vector3*)DATA_PTR(argv[4]);

    RayCollision* retval = (RayCollision*)mrb_malloc(mrb, sizeof(RayCollision));
    *retval = GetRayCollisionQuad(ray, p1, p2, p3, p4); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibRayCollision, &mrb_raylib_struct_RayCollision, retval));
}

static mrb_value mrb_raylib_InitAudioDevice(mrb_state* mrb, mrb_value self)
{
    InitAudioDevice();

    return mrb_nil_value();
}

static mrb_value mrb_raylib_CloseAudioDevice(mrb_state* mrb, mrb_value self)
{
    CloseAudioDevice();

    return mrb_nil_value();
}

static mrb_value mrb_raylib_IsAudioDeviceReady(mrb_state* mrb, mrb_value self)
{
    bool retval = IsAudioDeviceReady();

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_SetMasterVolume(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    float volume = mrb_as_float(mrb, argv[0]);

    SetMasterVolume(volume);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_GetMasterVolume(mrb_state* mrb, mrb_value self)
{
    float retval = GetMasterVolume();

    return mrb_float_value(mrb, retval);
}

static mrb_value mrb_raylib_LoadWave(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * fileName = DATA_PTR(argv[0]);

    Wave* retval = (Wave*)mrb_malloc(mrb, sizeof(Wave));
    *retval = LoadWave(fileName); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibWave, &mrb_raylib_struct_Wave, retval));
}

static mrb_value mrb_raylib_LoadWaveFromMemory(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    const char * fileType = DATA_PTR(argv[0]);
    const unsigned char * fileData = DATA_PTR(argv[1]);
    int dataSize = mrb_as_int(mrb, argv[2]);

    Wave* retval = (Wave*)mrb_malloc(mrb, sizeof(Wave));
    *retval = LoadWaveFromMemory(fileType, fileData, dataSize); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibWave, &mrb_raylib_struct_Wave, retval));
}

static mrb_value mrb_raylib_IsWaveReady(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Wave wave = *(Wave*)DATA_PTR(argv[0]);

    bool retval = IsWaveReady(wave);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_LoadSound(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * fileName = DATA_PTR(argv[0]);

    Sound* retval = (Sound*)mrb_malloc(mrb, sizeof(Sound));
    *retval = LoadSound(fileName); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibSound, &mrb_raylib_struct_Sound, retval));
}

static mrb_value mrb_raylib_LoadSoundFromWave(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Wave wave = *(Wave*)DATA_PTR(argv[0]);

    Sound* retval = (Sound*)mrb_malloc(mrb, sizeof(Sound));
    *retval = LoadSoundFromWave(wave); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibSound, &mrb_raylib_struct_Sound, retval));
}

static mrb_value mrb_raylib_LoadSoundAlias(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Sound source = *(Sound*)DATA_PTR(argv[0]);

    Sound* retval = (Sound*)mrb_malloc(mrb, sizeof(Sound));
    *retval = LoadSoundAlias(source); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibSound, &mrb_raylib_struct_Sound, retval));
}

static mrb_value mrb_raylib_IsSoundReady(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Sound sound = *(Sound*)DATA_PTR(argv[0]);

    bool retval = IsSoundReady(sound);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_UpdateSound(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Sound sound = *(Sound*)DATA_PTR(argv[0]);
    const void * data = DATA_PTR(argv[1]);
    int sampleCount = mrb_as_int(mrb, argv[2]);

    UpdateSound(sound, data, sampleCount);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_UnloadWave(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Wave wave = *(Wave*)DATA_PTR(argv[0]);

    UnloadWave(wave);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_UnloadSound(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Sound sound = *(Sound*)DATA_PTR(argv[0]);

    UnloadSound(sound);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_UnloadSoundAlias(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Sound alias = *(Sound*)DATA_PTR(argv[0]);

    UnloadSoundAlias(alias);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ExportWave(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Wave wave = *(Wave*)DATA_PTR(argv[0]);
    const char * fileName = DATA_PTR(argv[1]);

    bool retval = ExportWave(wave, fileName);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_ExportWaveAsCode(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Wave wave = *(Wave*)DATA_PTR(argv[0]);
    const char * fileName = DATA_PTR(argv[1]);

    bool retval = ExportWaveAsCode(wave, fileName);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_PlaySound(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Sound sound = *(Sound*)DATA_PTR(argv[0]);

    PlaySound(sound);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_StopSound(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Sound sound = *(Sound*)DATA_PTR(argv[0]);

    StopSound(sound);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_PauseSound(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Sound sound = *(Sound*)DATA_PTR(argv[0]);

    PauseSound(sound);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ResumeSound(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Sound sound = *(Sound*)DATA_PTR(argv[0]);

    ResumeSound(sound);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_IsSoundPlaying(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Sound sound = *(Sound*)DATA_PTR(argv[0]);

    bool retval = IsSoundPlaying(sound);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_SetSoundVolume(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Sound sound = *(Sound*)DATA_PTR(argv[0]);
    float volume = mrb_as_float(mrb, argv[1]);

    SetSoundVolume(sound, volume);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetSoundPitch(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Sound sound = *(Sound*)DATA_PTR(argv[0]);
    float pitch = mrb_as_float(mrb, argv[1]);

    SetSoundPitch(sound, pitch);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetSoundPan(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Sound sound = *(Sound*)DATA_PTR(argv[0]);
    float pan = mrb_as_float(mrb, argv[1]);

    SetSoundPan(sound, pan);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_WaveCopy(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Wave wave = *(Wave*)DATA_PTR(argv[0]);

    Wave* retval = (Wave*)mrb_malloc(mrb, sizeof(Wave));
    *retval = WaveCopy(wave); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibWave, &mrb_raylib_struct_Wave, retval));
}

static mrb_value mrb_raylib_WaveCrop(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    Wave * wave = DATA_PTR(argv[0]);
    int initSample = mrb_as_int(mrb, argv[1]);
    int finalSample = mrb_as_int(mrb, argv[2]);

    WaveCrop(wave, initSample, finalSample);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_WaveFormat(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[4];
    void* ptrs[4] = { &argv[0], &argv[1], &argv[2], &argv[3], };
    mrb_get_args_a(mrb, "oooo", ptrs);
    Wave * wave = DATA_PTR(argv[0]);
    int sampleRate = mrb_as_int(mrb, argv[1]);
    int sampleSize = mrb_as_int(mrb, argv[2]);
    int channels = mrb_as_int(mrb, argv[3]);

    WaveFormat(wave, sampleRate, sampleSize, channels);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_LoadWaveSamples(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Wave wave = *(Wave*)DATA_PTR(argv[0]);

    float * retval = LoadWaveSamples(wave);

    return self; /* TODO return wrapped object */
}

static mrb_value mrb_raylib_UnloadWaveSamples(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    float * samples = DATA_PTR(argv[0]);

    UnloadWaveSamples(samples);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_LoadMusicStream(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    const char * fileName = DATA_PTR(argv[0]);

    Music* retval = (Music*)mrb_malloc(mrb, sizeof(Music));
    *retval = LoadMusicStream(fileName); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibMusic, &mrb_raylib_struct_Music, retval));
}

static mrb_value mrb_raylib_LoadMusicStreamFromMemory(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    const char * fileType = DATA_PTR(argv[0]);
    const unsigned char * data = DATA_PTR(argv[1]);
    int dataSize = mrb_as_int(mrb, argv[2]);

    Music* retval = (Music*)mrb_malloc(mrb, sizeof(Music));
    *retval = LoadMusicStreamFromMemory(fileType, data, dataSize); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibMusic, &mrb_raylib_struct_Music, retval));
}

static mrb_value mrb_raylib_IsMusicReady(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Music music = *(Music*)DATA_PTR(argv[0]);

    bool retval = IsMusicReady(music);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_UnloadMusicStream(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Music music = *(Music*)DATA_PTR(argv[0]);

    UnloadMusicStream(music);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_PlayMusicStream(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Music music = *(Music*)DATA_PTR(argv[0]);

    PlayMusicStream(music);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_IsMusicStreamPlaying(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Music music = *(Music*)DATA_PTR(argv[0]);

    bool retval = IsMusicStreamPlaying(music);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_UpdateMusicStream(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Music music = *(Music*)DATA_PTR(argv[0]);

    UpdateMusicStream(music);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_StopMusicStream(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Music music = *(Music*)DATA_PTR(argv[0]);

    StopMusicStream(music);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_PauseMusicStream(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Music music = *(Music*)DATA_PTR(argv[0]);

    PauseMusicStream(music);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ResumeMusicStream(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Music music = *(Music*)DATA_PTR(argv[0]);

    ResumeMusicStream(music);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SeekMusicStream(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Music music = *(Music*)DATA_PTR(argv[0]);
    float position = mrb_as_float(mrb, argv[1]);

    SeekMusicStream(music, position);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetMusicVolume(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Music music = *(Music*)DATA_PTR(argv[0]);
    float volume = mrb_as_float(mrb, argv[1]);

    SetMusicVolume(music, volume);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetMusicPitch(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Music music = *(Music*)DATA_PTR(argv[0]);
    float pitch = mrb_as_float(mrb, argv[1]);

    SetMusicPitch(music, pitch);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetMusicPan(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    Music music = *(Music*)DATA_PTR(argv[0]);
    float pan = mrb_as_float(mrb, argv[1]);

    SetMusicPan(music, pan);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_GetMusicTimeLength(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Music music = *(Music*)DATA_PTR(argv[0]);

    float retval = GetMusicTimeLength(music);

    return mrb_float_value(mrb, retval);
}

static mrb_value mrb_raylib_GetMusicTimePlayed(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    Music music = *(Music*)DATA_PTR(argv[0]);

    float retval = GetMusicTimePlayed(music);

    return mrb_float_value(mrb, retval);
}

static mrb_value mrb_raylib_LoadAudioStream(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    unsigned int sampleRate = mrb_as_int(mrb, argv[0]);
    unsigned int sampleSize = mrb_as_int(mrb, argv[1]);
    unsigned int channels = mrb_as_int(mrb, argv[2]);

    AudioStream* retval = (AudioStream*)mrb_malloc(mrb, sizeof(AudioStream));
    *retval = LoadAudioStream(sampleRate, sampleSize, channels); /* TODO check if this pattern leaks memory or not */
    return mrb_obj_value(Data_Wrap_Struct(mrb, cRaylibAudioStream, &mrb_raylib_struct_AudioStream, retval));
}

static mrb_value mrb_raylib_IsAudioStreamReady(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    AudioStream stream = *(AudioStream*)DATA_PTR(argv[0]);

    bool retval = IsAudioStreamReady(stream);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_UnloadAudioStream(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    AudioStream stream = *(AudioStream*)DATA_PTR(argv[0]);

    UnloadAudioStream(stream);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_UpdateAudioStream(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[3];
    void* ptrs[3] = { &argv[0], &argv[1], &argv[2], };
    mrb_get_args_a(mrb, "ooo", ptrs);
    AudioStream stream = *(AudioStream*)DATA_PTR(argv[0]);
    const void * data = DATA_PTR(argv[1]);
    int frameCount = mrb_as_int(mrb, argv[2]);

    UpdateAudioStream(stream, data, frameCount);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_IsAudioStreamProcessed(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    AudioStream stream = *(AudioStream*)DATA_PTR(argv[0]);

    bool retval = IsAudioStreamProcessed(stream);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_PlayAudioStream(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    AudioStream stream = *(AudioStream*)DATA_PTR(argv[0]);

    PlayAudioStream(stream);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_PauseAudioStream(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    AudioStream stream = *(AudioStream*)DATA_PTR(argv[0]);

    PauseAudioStream(stream);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_ResumeAudioStream(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    AudioStream stream = *(AudioStream*)DATA_PTR(argv[0]);

    ResumeAudioStream(stream);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_IsAudioStreamPlaying(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    AudioStream stream = *(AudioStream*)DATA_PTR(argv[0]);

    bool retval = IsAudioStreamPlaying(stream);

    return retval ? mrb_true_value() : mrb_false_value();
}

static mrb_value mrb_raylib_StopAudioStream(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    AudioStream stream = *(AudioStream*)DATA_PTR(argv[0]);

    StopAudioStream(stream);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetAudioStreamVolume(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    AudioStream stream = *(AudioStream*)DATA_PTR(argv[0]);
    float volume = mrb_as_float(mrb, argv[1]);

    SetAudioStreamVolume(stream, volume);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetAudioStreamPitch(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    AudioStream stream = *(AudioStream*)DATA_PTR(argv[0]);
    float pitch = mrb_as_float(mrb, argv[1]);

    SetAudioStreamPitch(stream, pitch);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetAudioStreamPan(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    AudioStream stream = *(AudioStream*)DATA_PTR(argv[0]);
    float pan = mrb_as_float(mrb, argv[1]);

    SetAudioStreamPan(stream, pan);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetAudioStreamBufferSizeDefault(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    int size = mrb_as_int(mrb, argv[0]);

    SetAudioStreamBufferSizeDefault(size);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_SetAudioStreamCallback(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    AudioStream stream = *(AudioStream*)DATA_PTR(argv[0]);
    AudioCallback callback = *(AudioCallback*)DATA_PTR(argv[1]);

    SetAudioStreamCallback(stream, callback);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_AttachAudioStreamProcessor(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    AudioStream stream = *(AudioStream*)DATA_PTR(argv[0]);
    AudioCallback processor = *(AudioCallback*)DATA_PTR(argv[1]);

    AttachAudioStreamProcessor(stream, processor);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DetachAudioStreamProcessor(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[2];
    void* ptrs[2] = { &argv[0], &argv[1], };
    mrb_get_args_a(mrb, "oo", ptrs);
    AudioStream stream = *(AudioStream*)DATA_PTR(argv[0]);
    AudioCallback processor = *(AudioCallback*)DATA_PTR(argv[1]);

    DetachAudioStreamProcessor(stream, processor);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_AttachAudioMixedProcessor(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    AudioCallback processor = *(AudioCallback*)DATA_PTR(argv[0]);

    AttachAudioMixedProcessor(processor);

    return mrb_nil_value();
}

static mrb_value mrb_raylib_DetachAudioMixedProcessor(mrb_state* mrb, mrb_value self)
{
    mrb_value argv[1];
    void* ptrs[1] = { &argv[0], };
    mrb_get_args_a(mrb, "o", ptrs);
    AudioCallback processor = *(AudioCallback*)DATA_PTR(argv[0]);

    DetachAudioMixedProcessor(processor);

    return mrb_nil_value();
}

void mrb_raylib_module_init(mrb_state* mrb)
{
    mRaylib = mrb_define_module(mrb, "Raylib");


    // Define/Macro

    mrb_define_const(mrb, mRaylib, "RAYLIB_VERSION_MAJOR", mrb_int_value(mrb, 5));
    mrb_define_const(mrb, mRaylib, "RAYLIB_VERSION_MINOR", mrb_int_value(mrb, 0));
    mrb_define_const(mrb, mRaylib, "RAYLIB_VERSION_PATCH", mrb_int_value(mrb, 0));
    mrb_define_const(mrb, mRaylib, "RAYLIB_VERSION", mrb_str_new_cstr_frozen(mrb, "5.0-dev"));

    // Enum

    // enum ConfigFlags
    mrb_define_const(mrb, mRaylib, "FLAG_VSYNC_HINT", mrb_int_value(mrb, 64));
    mrb_define_const(mrb, mRaylib, "FLAG_FULLSCREEN_MODE", mrb_int_value(mrb, 2));
    mrb_define_const(mrb, mRaylib, "FLAG_WINDOW_RESIZABLE", mrb_int_value(mrb, 4));
    mrb_define_const(mrb, mRaylib, "FLAG_WINDOW_UNDECORATED", mrb_int_value(mrb, 8));
    mrb_define_const(mrb, mRaylib, "FLAG_WINDOW_HIDDEN", mrb_int_value(mrb, 128));
    mrb_define_const(mrb, mRaylib, "FLAG_WINDOW_MINIMIZED", mrb_int_value(mrb, 512));
    mrb_define_const(mrb, mRaylib, "FLAG_WINDOW_MAXIMIZED", mrb_int_value(mrb, 1024));
    mrb_define_const(mrb, mRaylib, "FLAG_WINDOW_UNFOCUSED", mrb_int_value(mrb, 2048));
    mrb_define_const(mrb, mRaylib, "FLAG_WINDOW_TOPMOST", mrb_int_value(mrb, 4096));
    mrb_define_const(mrb, mRaylib, "FLAG_WINDOW_ALWAYS_RUN", mrb_int_value(mrb, 256));
    mrb_define_const(mrb, mRaylib, "FLAG_WINDOW_TRANSPARENT", mrb_int_value(mrb, 16));
    mrb_define_const(mrb, mRaylib, "FLAG_WINDOW_HIGHDPI", mrb_int_value(mrb, 8192));
    mrb_define_const(mrb, mRaylib, "FLAG_WINDOW_MOUSE_PASSTHROUGH", mrb_int_value(mrb, 16384));
    mrb_define_const(mrb, mRaylib, "FLAG_BORDERLESS_WINDOWED_MODE", mrb_int_value(mrb, 32768));
    mrb_define_const(mrb, mRaylib, "FLAG_MSAA_4X_HINT", mrb_int_value(mrb, 32));
    mrb_define_const(mrb, mRaylib, "FLAG_INTERLACED_HINT", mrb_int_value(mrb, 65536));

    // enum TraceLogLevel
    mrb_define_const(mrb, mRaylib, "LOG_ALL", mrb_int_value(mrb, 0));
    mrb_define_const(mrb, mRaylib, "LOG_TRACE", mrb_int_value(mrb, 1));
    mrb_define_const(mrb, mRaylib, "LOG_DEBUG", mrb_int_value(mrb, 2));
    mrb_define_const(mrb, mRaylib, "LOG_INFO", mrb_int_value(mrb, 3));
    mrb_define_const(mrb, mRaylib, "LOG_WARNING", mrb_int_value(mrb, 4));
    mrb_define_const(mrb, mRaylib, "LOG_ERROR", mrb_int_value(mrb, 5));
    mrb_define_const(mrb, mRaylib, "LOG_FATAL", mrb_int_value(mrb, 6));
    mrb_define_const(mrb, mRaylib, "LOG_NONE", mrb_int_value(mrb, 7));

    // enum KeyboardKey
    mrb_define_const(mrb, mRaylib, "KEY_NULL", mrb_int_value(mrb, 0));
    mrb_define_const(mrb, mRaylib, "KEY_APOSTROPHE", mrb_int_value(mrb, 39));
    mrb_define_const(mrb, mRaylib, "KEY_COMMA", mrb_int_value(mrb, 44));
    mrb_define_const(mrb, mRaylib, "KEY_MINUS", mrb_int_value(mrb, 45));
    mrb_define_const(mrb, mRaylib, "KEY_PERIOD", mrb_int_value(mrb, 46));
    mrb_define_const(mrb, mRaylib, "KEY_SLASH", mrb_int_value(mrb, 47));
    mrb_define_const(mrb, mRaylib, "KEY_ZERO", mrb_int_value(mrb, 48));
    mrb_define_const(mrb, mRaylib, "KEY_ONE", mrb_int_value(mrb, 49));
    mrb_define_const(mrb, mRaylib, "KEY_TWO", mrb_int_value(mrb, 50));
    mrb_define_const(mrb, mRaylib, "KEY_THREE", mrb_int_value(mrb, 51));
    mrb_define_const(mrb, mRaylib, "KEY_FOUR", mrb_int_value(mrb, 52));
    mrb_define_const(mrb, mRaylib, "KEY_FIVE", mrb_int_value(mrb, 53));
    mrb_define_const(mrb, mRaylib, "KEY_SIX", mrb_int_value(mrb, 54));
    mrb_define_const(mrb, mRaylib, "KEY_SEVEN", mrb_int_value(mrb, 55));
    mrb_define_const(mrb, mRaylib, "KEY_EIGHT", mrb_int_value(mrb, 56));
    mrb_define_const(mrb, mRaylib, "KEY_NINE", mrb_int_value(mrb, 57));
    mrb_define_const(mrb, mRaylib, "KEY_SEMICOLON", mrb_int_value(mrb, 59));
    mrb_define_const(mrb, mRaylib, "KEY_EQUAL", mrb_int_value(mrb, 61));
    mrb_define_const(mrb, mRaylib, "KEY_A", mrb_int_value(mrb, 65));
    mrb_define_const(mrb, mRaylib, "KEY_B", mrb_int_value(mrb, 66));
    mrb_define_const(mrb, mRaylib, "KEY_C", mrb_int_value(mrb, 67));
    mrb_define_const(mrb, mRaylib, "KEY_D", mrb_int_value(mrb, 68));
    mrb_define_const(mrb, mRaylib, "KEY_E", mrb_int_value(mrb, 69));
    mrb_define_const(mrb, mRaylib, "KEY_F", mrb_int_value(mrb, 70));
    mrb_define_const(mrb, mRaylib, "KEY_G", mrb_int_value(mrb, 71));
    mrb_define_const(mrb, mRaylib, "KEY_H", mrb_int_value(mrb, 72));
    mrb_define_const(mrb, mRaylib, "KEY_I", mrb_int_value(mrb, 73));
    mrb_define_const(mrb, mRaylib, "KEY_J", mrb_int_value(mrb, 74));
    mrb_define_const(mrb, mRaylib, "KEY_K", mrb_int_value(mrb, 75));
    mrb_define_const(mrb, mRaylib, "KEY_L", mrb_int_value(mrb, 76));
    mrb_define_const(mrb, mRaylib, "KEY_M", mrb_int_value(mrb, 77));
    mrb_define_const(mrb, mRaylib, "KEY_N", mrb_int_value(mrb, 78));
    mrb_define_const(mrb, mRaylib, "KEY_O", mrb_int_value(mrb, 79));
    mrb_define_const(mrb, mRaylib, "KEY_P", mrb_int_value(mrb, 80));
    mrb_define_const(mrb, mRaylib, "KEY_Q", mrb_int_value(mrb, 81));
    mrb_define_const(mrb, mRaylib, "KEY_R", mrb_int_value(mrb, 82));
    mrb_define_const(mrb, mRaylib, "KEY_S", mrb_int_value(mrb, 83));
    mrb_define_const(mrb, mRaylib, "KEY_T", mrb_int_value(mrb, 84));
    mrb_define_const(mrb, mRaylib, "KEY_U", mrb_int_value(mrb, 85));
    mrb_define_const(mrb, mRaylib, "KEY_V", mrb_int_value(mrb, 86));
    mrb_define_const(mrb, mRaylib, "KEY_W", mrb_int_value(mrb, 87));
    mrb_define_const(mrb, mRaylib, "KEY_X", mrb_int_value(mrb, 88));
    mrb_define_const(mrb, mRaylib, "KEY_Y", mrb_int_value(mrb, 89));
    mrb_define_const(mrb, mRaylib, "KEY_Z", mrb_int_value(mrb, 90));
    mrb_define_const(mrb, mRaylib, "KEY_LEFT_BRACKET", mrb_int_value(mrb, 91));
    mrb_define_const(mrb, mRaylib, "KEY_BACKSLASH", mrb_int_value(mrb, 92));
    mrb_define_const(mrb, mRaylib, "KEY_RIGHT_BRACKET", mrb_int_value(mrb, 93));
    mrb_define_const(mrb, mRaylib, "KEY_GRAVE", mrb_int_value(mrb, 96));
    mrb_define_const(mrb, mRaylib, "KEY_SPACE", mrb_int_value(mrb, 32));
    mrb_define_const(mrb, mRaylib, "KEY_ESCAPE", mrb_int_value(mrb, 256));
    mrb_define_const(mrb, mRaylib, "KEY_ENTER", mrb_int_value(mrb, 257));
    mrb_define_const(mrb, mRaylib, "KEY_TAB", mrb_int_value(mrb, 258));
    mrb_define_const(mrb, mRaylib, "KEY_BACKSPACE", mrb_int_value(mrb, 259));
    mrb_define_const(mrb, mRaylib, "KEY_INSERT", mrb_int_value(mrb, 260));
    mrb_define_const(mrb, mRaylib, "KEY_DELETE", mrb_int_value(mrb, 261));
    mrb_define_const(mrb, mRaylib, "KEY_RIGHT", mrb_int_value(mrb, 262));
    mrb_define_const(mrb, mRaylib, "KEY_LEFT", mrb_int_value(mrb, 263));
    mrb_define_const(mrb, mRaylib, "KEY_DOWN", mrb_int_value(mrb, 264));
    mrb_define_const(mrb, mRaylib, "KEY_UP", mrb_int_value(mrb, 265));
    mrb_define_const(mrb, mRaylib, "KEY_PAGE_UP", mrb_int_value(mrb, 266));
    mrb_define_const(mrb, mRaylib, "KEY_PAGE_DOWN", mrb_int_value(mrb, 267));
    mrb_define_const(mrb, mRaylib, "KEY_HOME", mrb_int_value(mrb, 268));
    mrb_define_const(mrb, mRaylib, "KEY_END", mrb_int_value(mrb, 269));
    mrb_define_const(mrb, mRaylib, "KEY_CAPS_LOCK", mrb_int_value(mrb, 280));
    mrb_define_const(mrb, mRaylib, "KEY_SCROLL_LOCK", mrb_int_value(mrb, 281));
    mrb_define_const(mrb, mRaylib, "KEY_NUM_LOCK", mrb_int_value(mrb, 282));
    mrb_define_const(mrb, mRaylib, "KEY_PRINT_SCREEN", mrb_int_value(mrb, 283));
    mrb_define_const(mrb, mRaylib, "KEY_PAUSE", mrb_int_value(mrb, 284));
    mrb_define_const(mrb, mRaylib, "KEY_F1", mrb_int_value(mrb, 290));
    mrb_define_const(mrb, mRaylib, "KEY_F2", mrb_int_value(mrb, 291));
    mrb_define_const(mrb, mRaylib, "KEY_F3", mrb_int_value(mrb, 292));
    mrb_define_const(mrb, mRaylib, "KEY_F4", mrb_int_value(mrb, 293));
    mrb_define_const(mrb, mRaylib, "KEY_F5", mrb_int_value(mrb, 294));
    mrb_define_const(mrb, mRaylib, "KEY_F6", mrb_int_value(mrb, 295));
    mrb_define_const(mrb, mRaylib, "KEY_F7", mrb_int_value(mrb, 296));
    mrb_define_const(mrb, mRaylib, "KEY_F8", mrb_int_value(mrb, 297));
    mrb_define_const(mrb, mRaylib, "KEY_F9", mrb_int_value(mrb, 298));
    mrb_define_const(mrb, mRaylib, "KEY_F10", mrb_int_value(mrb, 299));
    mrb_define_const(mrb, mRaylib, "KEY_F11", mrb_int_value(mrb, 300));
    mrb_define_const(mrb, mRaylib, "KEY_F12", mrb_int_value(mrb, 301));
    mrb_define_const(mrb, mRaylib, "KEY_LEFT_SHIFT", mrb_int_value(mrb, 340));
    mrb_define_const(mrb, mRaylib, "KEY_LEFT_CONTROL", mrb_int_value(mrb, 341));
    mrb_define_const(mrb, mRaylib, "KEY_LEFT_ALT", mrb_int_value(mrb, 342));
    mrb_define_const(mrb, mRaylib, "KEY_LEFT_SUPER", mrb_int_value(mrb, 343));
    mrb_define_const(mrb, mRaylib, "KEY_RIGHT_SHIFT", mrb_int_value(mrb, 344));
    mrb_define_const(mrb, mRaylib, "KEY_RIGHT_CONTROL", mrb_int_value(mrb, 345));
    mrb_define_const(mrb, mRaylib, "KEY_RIGHT_ALT", mrb_int_value(mrb, 346));
    mrb_define_const(mrb, mRaylib, "KEY_RIGHT_SUPER", mrb_int_value(mrb, 347));
    mrb_define_const(mrb, mRaylib, "KEY_KB_MENU", mrb_int_value(mrb, 348));
    mrb_define_const(mrb, mRaylib, "KEY_KP_0", mrb_int_value(mrb, 320));
    mrb_define_const(mrb, mRaylib, "KEY_KP_1", mrb_int_value(mrb, 321));
    mrb_define_const(mrb, mRaylib, "KEY_KP_2", mrb_int_value(mrb, 322));
    mrb_define_const(mrb, mRaylib, "KEY_KP_3", mrb_int_value(mrb, 323));
    mrb_define_const(mrb, mRaylib, "KEY_KP_4", mrb_int_value(mrb, 324));
    mrb_define_const(mrb, mRaylib, "KEY_KP_5", mrb_int_value(mrb, 325));
    mrb_define_const(mrb, mRaylib, "KEY_KP_6", mrb_int_value(mrb, 326));
    mrb_define_const(mrb, mRaylib, "KEY_KP_7", mrb_int_value(mrb, 327));
    mrb_define_const(mrb, mRaylib, "KEY_KP_8", mrb_int_value(mrb, 328));
    mrb_define_const(mrb, mRaylib, "KEY_KP_9", mrb_int_value(mrb, 329));
    mrb_define_const(mrb, mRaylib, "KEY_KP_DECIMAL", mrb_int_value(mrb, 330));
    mrb_define_const(mrb, mRaylib, "KEY_KP_DIVIDE", mrb_int_value(mrb, 331));
    mrb_define_const(mrb, mRaylib, "KEY_KP_MULTIPLY", mrb_int_value(mrb, 332));
    mrb_define_const(mrb, mRaylib, "KEY_KP_SUBTRACT", mrb_int_value(mrb, 333));
    mrb_define_const(mrb, mRaylib, "KEY_KP_ADD", mrb_int_value(mrb, 334));
    mrb_define_const(mrb, mRaylib, "KEY_KP_ENTER", mrb_int_value(mrb, 335));
    mrb_define_const(mrb, mRaylib, "KEY_KP_EQUAL", mrb_int_value(mrb, 336));
    mrb_define_const(mrb, mRaylib, "KEY_BACK", mrb_int_value(mrb, 4));
    mrb_define_const(mrb, mRaylib, "KEY_MENU", mrb_int_value(mrb, 82));
    mrb_define_const(mrb, mRaylib, "KEY_VOLUME_UP", mrb_int_value(mrb, 24));
    mrb_define_const(mrb, mRaylib, "KEY_VOLUME_DOWN", mrb_int_value(mrb, 25));

    // enum MouseButton
    mrb_define_const(mrb, mRaylib, "MOUSE_BUTTON_LEFT", mrb_int_value(mrb, 0));
    mrb_define_const(mrb, mRaylib, "MOUSE_BUTTON_RIGHT", mrb_int_value(mrb, 1));
    mrb_define_const(mrb, mRaylib, "MOUSE_BUTTON_MIDDLE", mrb_int_value(mrb, 2));
    mrb_define_const(mrb, mRaylib, "MOUSE_BUTTON_SIDE", mrb_int_value(mrb, 3));
    mrb_define_const(mrb, mRaylib, "MOUSE_BUTTON_EXTRA", mrb_int_value(mrb, 4));
    mrb_define_const(mrb, mRaylib, "MOUSE_BUTTON_FORWARD", mrb_int_value(mrb, 5));
    mrb_define_const(mrb, mRaylib, "MOUSE_BUTTON_BACK", mrb_int_value(mrb, 6));

    // enum MouseCursor
    mrb_define_const(mrb, mRaylib, "MOUSE_CURSOR_DEFAULT", mrb_int_value(mrb, 0));
    mrb_define_const(mrb, mRaylib, "MOUSE_CURSOR_ARROW", mrb_int_value(mrb, 1));
    mrb_define_const(mrb, mRaylib, "MOUSE_CURSOR_IBEAM", mrb_int_value(mrb, 2));
    mrb_define_const(mrb, mRaylib, "MOUSE_CURSOR_CROSSHAIR", mrb_int_value(mrb, 3));
    mrb_define_const(mrb, mRaylib, "MOUSE_CURSOR_POINTING_HAND", mrb_int_value(mrb, 4));
    mrb_define_const(mrb, mRaylib, "MOUSE_CURSOR_RESIZE_EW", mrb_int_value(mrb, 5));
    mrb_define_const(mrb, mRaylib, "MOUSE_CURSOR_RESIZE_NS", mrb_int_value(mrb, 6));
    mrb_define_const(mrb, mRaylib, "MOUSE_CURSOR_RESIZE_NWSE", mrb_int_value(mrb, 7));
    mrb_define_const(mrb, mRaylib, "MOUSE_CURSOR_RESIZE_NESW", mrb_int_value(mrb, 8));
    mrb_define_const(mrb, mRaylib, "MOUSE_CURSOR_RESIZE_ALL", mrb_int_value(mrb, 9));
    mrb_define_const(mrb, mRaylib, "MOUSE_CURSOR_NOT_ALLOWED", mrb_int_value(mrb, 10));

    // enum GamepadButton
    mrb_define_const(mrb, mRaylib, "GAMEPAD_BUTTON_UNKNOWN", mrb_int_value(mrb, 0));
    mrb_define_const(mrb, mRaylib, "GAMEPAD_BUTTON_LEFT_FACE_UP", mrb_int_value(mrb, 1));
    mrb_define_const(mrb, mRaylib, "GAMEPAD_BUTTON_LEFT_FACE_RIGHT", mrb_int_value(mrb, 2));
    mrb_define_const(mrb, mRaylib, "GAMEPAD_BUTTON_LEFT_FACE_DOWN", mrb_int_value(mrb, 3));
    mrb_define_const(mrb, mRaylib, "GAMEPAD_BUTTON_LEFT_FACE_LEFT", mrb_int_value(mrb, 4));
    mrb_define_const(mrb, mRaylib, "GAMEPAD_BUTTON_RIGHT_FACE_UP", mrb_int_value(mrb, 5));
    mrb_define_const(mrb, mRaylib, "GAMEPAD_BUTTON_RIGHT_FACE_RIGHT", mrb_int_value(mrb, 6));
    mrb_define_const(mrb, mRaylib, "GAMEPAD_BUTTON_RIGHT_FACE_DOWN", mrb_int_value(mrb, 7));
    mrb_define_const(mrb, mRaylib, "GAMEPAD_BUTTON_RIGHT_FACE_LEFT", mrb_int_value(mrb, 8));
    mrb_define_const(mrb, mRaylib, "GAMEPAD_BUTTON_LEFT_TRIGGER_1", mrb_int_value(mrb, 9));
    mrb_define_const(mrb, mRaylib, "GAMEPAD_BUTTON_LEFT_TRIGGER_2", mrb_int_value(mrb, 10));
    mrb_define_const(mrb, mRaylib, "GAMEPAD_BUTTON_RIGHT_TRIGGER_1", mrb_int_value(mrb, 11));
    mrb_define_const(mrb, mRaylib, "GAMEPAD_BUTTON_RIGHT_TRIGGER_2", mrb_int_value(mrb, 12));
    mrb_define_const(mrb, mRaylib, "GAMEPAD_BUTTON_MIDDLE_LEFT", mrb_int_value(mrb, 13));
    mrb_define_const(mrb, mRaylib, "GAMEPAD_BUTTON_MIDDLE", mrb_int_value(mrb, 14));
    mrb_define_const(mrb, mRaylib, "GAMEPAD_BUTTON_MIDDLE_RIGHT", mrb_int_value(mrb, 15));
    mrb_define_const(mrb, mRaylib, "GAMEPAD_BUTTON_LEFT_THUMB", mrb_int_value(mrb, 16));
    mrb_define_const(mrb, mRaylib, "GAMEPAD_BUTTON_RIGHT_THUMB", mrb_int_value(mrb, 17));

    // enum GamepadAxis
    mrb_define_const(mrb, mRaylib, "GAMEPAD_AXIS_LEFT_X", mrb_int_value(mrb, 0));
    mrb_define_const(mrb, mRaylib, "GAMEPAD_AXIS_LEFT_Y", mrb_int_value(mrb, 1));
    mrb_define_const(mrb, mRaylib, "GAMEPAD_AXIS_RIGHT_X", mrb_int_value(mrb, 2));
    mrb_define_const(mrb, mRaylib, "GAMEPAD_AXIS_RIGHT_Y", mrb_int_value(mrb, 3));
    mrb_define_const(mrb, mRaylib, "GAMEPAD_AXIS_LEFT_TRIGGER", mrb_int_value(mrb, 4));
    mrb_define_const(mrb, mRaylib, "GAMEPAD_AXIS_RIGHT_TRIGGER", mrb_int_value(mrb, 5));

    // enum MaterialMapIndex
    mrb_define_const(mrb, mRaylib, "MATERIAL_MAP_ALBEDO", mrb_int_value(mrb, 0));
    mrb_define_const(mrb, mRaylib, "MATERIAL_MAP_METALNESS", mrb_int_value(mrb, 1));
    mrb_define_const(mrb, mRaylib, "MATERIAL_MAP_NORMAL", mrb_int_value(mrb, 2));
    mrb_define_const(mrb, mRaylib, "MATERIAL_MAP_ROUGHNESS", mrb_int_value(mrb, 3));
    mrb_define_const(mrb, mRaylib, "MATERIAL_MAP_OCCLUSION", mrb_int_value(mrb, 4));
    mrb_define_const(mrb, mRaylib, "MATERIAL_MAP_EMISSION", mrb_int_value(mrb, 5));
    mrb_define_const(mrb, mRaylib, "MATERIAL_MAP_HEIGHT", mrb_int_value(mrb, 6));
    mrb_define_const(mrb, mRaylib, "MATERIAL_MAP_CUBEMAP", mrb_int_value(mrb, 7));
    mrb_define_const(mrb, mRaylib, "MATERIAL_MAP_IRRADIANCE", mrb_int_value(mrb, 8));
    mrb_define_const(mrb, mRaylib, "MATERIAL_MAP_PREFILTER", mrb_int_value(mrb, 9));
    mrb_define_const(mrb, mRaylib, "MATERIAL_MAP_BRDF", mrb_int_value(mrb, 10));

    // enum ShaderLocationIndex
    mrb_define_const(mrb, mRaylib, "SHADER_LOC_VERTEX_POSITION", mrb_int_value(mrb, 0));
    mrb_define_const(mrb, mRaylib, "SHADER_LOC_VERTEX_TEXCOORD01", mrb_int_value(mrb, 1));
    mrb_define_const(mrb, mRaylib, "SHADER_LOC_VERTEX_TEXCOORD02", mrb_int_value(mrb, 2));
    mrb_define_const(mrb, mRaylib, "SHADER_LOC_VERTEX_NORMAL", mrb_int_value(mrb, 3));
    mrb_define_const(mrb, mRaylib, "SHADER_LOC_VERTEX_TANGENT", mrb_int_value(mrb, 4));
    mrb_define_const(mrb, mRaylib, "SHADER_LOC_VERTEX_COLOR", mrb_int_value(mrb, 5));
    mrb_define_const(mrb, mRaylib, "SHADER_LOC_MATRIX_MVP", mrb_int_value(mrb, 6));
    mrb_define_const(mrb, mRaylib, "SHADER_LOC_MATRIX_VIEW", mrb_int_value(mrb, 7));
    mrb_define_const(mrb, mRaylib, "SHADER_LOC_MATRIX_PROJECTION", mrb_int_value(mrb, 8));
    mrb_define_const(mrb, mRaylib, "SHADER_LOC_MATRIX_MODEL", mrb_int_value(mrb, 9));
    mrb_define_const(mrb, mRaylib, "SHADER_LOC_MATRIX_NORMAL", mrb_int_value(mrb, 10));
    mrb_define_const(mrb, mRaylib, "SHADER_LOC_VECTOR_VIEW", mrb_int_value(mrb, 11));
    mrb_define_const(mrb, mRaylib, "SHADER_LOC_COLOR_DIFFUSE", mrb_int_value(mrb, 12));
    mrb_define_const(mrb, mRaylib, "SHADER_LOC_COLOR_SPECULAR", mrb_int_value(mrb, 13));
    mrb_define_const(mrb, mRaylib, "SHADER_LOC_COLOR_AMBIENT", mrb_int_value(mrb, 14));
    mrb_define_const(mrb, mRaylib, "SHADER_LOC_MAP_ALBEDO", mrb_int_value(mrb, 15));
    mrb_define_const(mrb, mRaylib, "SHADER_LOC_MAP_METALNESS", mrb_int_value(mrb, 16));
    mrb_define_const(mrb, mRaylib, "SHADER_LOC_MAP_NORMAL", mrb_int_value(mrb, 17));
    mrb_define_const(mrb, mRaylib, "SHADER_LOC_MAP_ROUGHNESS", mrb_int_value(mrb, 18));
    mrb_define_const(mrb, mRaylib, "SHADER_LOC_MAP_OCCLUSION", mrb_int_value(mrb, 19));
    mrb_define_const(mrb, mRaylib, "SHADER_LOC_MAP_EMISSION", mrb_int_value(mrb, 20));
    mrb_define_const(mrb, mRaylib, "SHADER_LOC_MAP_HEIGHT", mrb_int_value(mrb, 21));
    mrb_define_const(mrb, mRaylib, "SHADER_LOC_MAP_CUBEMAP", mrb_int_value(mrb, 22));
    mrb_define_const(mrb, mRaylib, "SHADER_LOC_MAP_IRRADIANCE", mrb_int_value(mrb, 23));
    mrb_define_const(mrb, mRaylib, "SHADER_LOC_MAP_PREFILTER", mrb_int_value(mrb, 24));
    mrb_define_const(mrb, mRaylib, "SHADER_LOC_MAP_BRDF", mrb_int_value(mrb, 25));

    // enum ShaderUniformDataType
    mrb_define_const(mrb, mRaylib, "SHADER_UNIFORM_FLOAT", mrb_int_value(mrb, 0));
    mrb_define_const(mrb, mRaylib, "SHADER_UNIFORM_VEC2", mrb_int_value(mrb, 1));
    mrb_define_const(mrb, mRaylib, "SHADER_UNIFORM_VEC3", mrb_int_value(mrb, 2));
    mrb_define_const(mrb, mRaylib, "SHADER_UNIFORM_VEC4", mrb_int_value(mrb, 3));
    mrb_define_const(mrb, mRaylib, "SHADER_UNIFORM_INT", mrb_int_value(mrb, 4));
    mrb_define_const(mrb, mRaylib, "SHADER_UNIFORM_IVEC2", mrb_int_value(mrb, 5));
    mrb_define_const(mrb, mRaylib, "SHADER_UNIFORM_IVEC3", mrb_int_value(mrb, 6));
    mrb_define_const(mrb, mRaylib, "SHADER_UNIFORM_IVEC4", mrb_int_value(mrb, 7));
    mrb_define_const(mrb, mRaylib, "SHADER_UNIFORM_SAMPLER2D", mrb_int_value(mrb, 8));

    // enum ShaderAttributeDataType
    mrb_define_const(mrb, mRaylib, "SHADER_ATTRIB_FLOAT", mrb_int_value(mrb, 0));
    mrb_define_const(mrb, mRaylib, "SHADER_ATTRIB_VEC2", mrb_int_value(mrb, 1));
    mrb_define_const(mrb, mRaylib, "SHADER_ATTRIB_VEC3", mrb_int_value(mrb, 2));
    mrb_define_const(mrb, mRaylib, "SHADER_ATTRIB_VEC4", mrb_int_value(mrb, 3));

    // enum PixelFormat
    mrb_define_const(mrb, mRaylib, "PIXELFORMAT_UNCOMPRESSED_GRAYSCALE", mrb_int_value(mrb, 1));
    mrb_define_const(mrb, mRaylib, "PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA", mrb_int_value(mrb, 2));
    mrb_define_const(mrb, mRaylib, "PIXELFORMAT_UNCOMPRESSED_R5G6B5", mrb_int_value(mrb, 3));
    mrb_define_const(mrb, mRaylib, "PIXELFORMAT_UNCOMPRESSED_R8G8B8", mrb_int_value(mrb, 4));
    mrb_define_const(mrb, mRaylib, "PIXELFORMAT_UNCOMPRESSED_R5G5B5A1", mrb_int_value(mrb, 5));
    mrb_define_const(mrb, mRaylib, "PIXELFORMAT_UNCOMPRESSED_R4G4B4A4", mrb_int_value(mrb, 6));
    mrb_define_const(mrb, mRaylib, "PIXELFORMAT_UNCOMPRESSED_R8G8B8A8", mrb_int_value(mrb, 7));
    mrb_define_const(mrb, mRaylib, "PIXELFORMAT_UNCOMPRESSED_R32", mrb_int_value(mrb, 8));
    mrb_define_const(mrb, mRaylib, "PIXELFORMAT_UNCOMPRESSED_R32G32B32", mrb_int_value(mrb, 9));
    mrb_define_const(mrb, mRaylib, "PIXELFORMAT_UNCOMPRESSED_R32G32B32A32", mrb_int_value(mrb, 10));
    mrb_define_const(mrb, mRaylib, "PIXELFORMAT_UNCOMPRESSED_R16", mrb_int_value(mrb, 11));
    mrb_define_const(mrb, mRaylib, "PIXELFORMAT_UNCOMPRESSED_R16G16B16", mrb_int_value(mrb, 12));
    mrb_define_const(mrb, mRaylib, "PIXELFORMAT_UNCOMPRESSED_R16G16B16A16", mrb_int_value(mrb, 13));
    mrb_define_const(mrb, mRaylib, "PIXELFORMAT_COMPRESSED_DXT1_RGB", mrb_int_value(mrb, 14));
    mrb_define_const(mrb, mRaylib, "PIXELFORMAT_COMPRESSED_DXT1_RGBA", mrb_int_value(mrb, 15));
    mrb_define_const(mrb, mRaylib, "PIXELFORMAT_COMPRESSED_DXT3_RGBA", mrb_int_value(mrb, 16));
    mrb_define_const(mrb, mRaylib, "PIXELFORMAT_COMPRESSED_DXT5_RGBA", mrb_int_value(mrb, 17));
    mrb_define_const(mrb, mRaylib, "PIXELFORMAT_COMPRESSED_ETC1_RGB", mrb_int_value(mrb, 18));
    mrb_define_const(mrb, mRaylib, "PIXELFORMAT_COMPRESSED_ETC2_RGB", mrb_int_value(mrb, 19));
    mrb_define_const(mrb, mRaylib, "PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA", mrb_int_value(mrb, 20));
    mrb_define_const(mrb, mRaylib, "PIXELFORMAT_COMPRESSED_PVRT_RGB", mrb_int_value(mrb, 21));
    mrb_define_const(mrb, mRaylib, "PIXELFORMAT_COMPRESSED_PVRT_RGBA", mrb_int_value(mrb, 22));
    mrb_define_const(mrb, mRaylib, "PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA", mrb_int_value(mrb, 23));
    mrb_define_const(mrb, mRaylib, "PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA", mrb_int_value(mrb, 24));

    // enum TextureFilter
    mrb_define_const(mrb, mRaylib, "TEXTURE_FILTER_POINT", mrb_int_value(mrb, 0));
    mrb_define_const(mrb, mRaylib, "TEXTURE_FILTER_BILINEAR", mrb_int_value(mrb, 1));
    mrb_define_const(mrb, mRaylib, "TEXTURE_FILTER_TRILINEAR", mrb_int_value(mrb, 2));
    mrb_define_const(mrb, mRaylib, "TEXTURE_FILTER_ANISOTROPIC_4X", mrb_int_value(mrb, 3));
    mrb_define_const(mrb, mRaylib, "TEXTURE_FILTER_ANISOTROPIC_8X", mrb_int_value(mrb, 4));
    mrb_define_const(mrb, mRaylib, "TEXTURE_FILTER_ANISOTROPIC_16X", mrb_int_value(mrb, 5));

    // enum TextureWrap
    mrb_define_const(mrb, mRaylib, "TEXTURE_WRAP_REPEAT", mrb_int_value(mrb, 0));
    mrb_define_const(mrb, mRaylib, "TEXTURE_WRAP_CLAMP", mrb_int_value(mrb, 1));
    mrb_define_const(mrb, mRaylib, "TEXTURE_WRAP_MIRROR_REPEAT", mrb_int_value(mrb, 2));
    mrb_define_const(mrb, mRaylib, "TEXTURE_WRAP_MIRROR_CLAMP", mrb_int_value(mrb, 3));

    // enum CubemapLayout
    mrb_define_const(mrb, mRaylib, "CUBEMAP_LAYOUT_AUTO_DETECT", mrb_int_value(mrb, 0));
    mrb_define_const(mrb, mRaylib, "CUBEMAP_LAYOUT_LINE_VERTICAL", mrb_int_value(mrb, 1));
    mrb_define_const(mrb, mRaylib, "CUBEMAP_LAYOUT_LINE_HORIZONTAL", mrb_int_value(mrb, 2));
    mrb_define_const(mrb, mRaylib, "CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR", mrb_int_value(mrb, 3));
    mrb_define_const(mrb, mRaylib, "CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE", mrb_int_value(mrb, 4));
    mrb_define_const(mrb, mRaylib, "CUBEMAP_LAYOUT_PANORAMA", mrb_int_value(mrb, 5));

    // enum FontType
    mrb_define_const(mrb, mRaylib, "FONT_DEFAULT", mrb_int_value(mrb, 0));
    mrb_define_const(mrb, mRaylib, "FONT_BITMAP", mrb_int_value(mrb, 1));
    mrb_define_const(mrb, mRaylib, "FONT_SDF", mrb_int_value(mrb, 2));

    // enum BlendMode
    mrb_define_const(mrb, mRaylib, "BLEND_ALPHA", mrb_int_value(mrb, 0));
    mrb_define_const(mrb, mRaylib, "BLEND_ADDITIVE", mrb_int_value(mrb, 1));
    mrb_define_const(mrb, mRaylib, "BLEND_MULTIPLIED", mrb_int_value(mrb, 2));
    mrb_define_const(mrb, mRaylib, "BLEND_ADD_COLORS", mrb_int_value(mrb, 3));
    mrb_define_const(mrb, mRaylib, "BLEND_SUBTRACT_COLORS", mrb_int_value(mrb, 4));
    mrb_define_const(mrb, mRaylib, "BLEND_ALPHA_PREMULTIPLY", mrb_int_value(mrb, 5));
    mrb_define_const(mrb, mRaylib, "BLEND_CUSTOM", mrb_int_value(mrb, 6));
    mrb_define_const(mrb, mRaylib, "BLEND_CUSTOM_SEPARATE", mrb_int_value(mrb, 7));

    // enum Gesture
    mrb_define_const(mrb, mRaylib, "GESTURE_NONE", mrb_int_value(mrb, 0));
    mrb_define_const(mrb, mRaylib, "GESTURE_TAP", mrb_int_value(mrb, 1));
    mrb_define_const(mrb, mRaylib, "GESTURE_DOUBLETAP", mrb_int_value(mrb, 2));
    mrb_define_const(mrb, mRaylib, "GESTURE_HOLD", mrb_int_value(mrb, 4));
    mrb_define_const(mrb, mRaylib, "GESTURE_DRAG", mrb_int_value(mrb, 8));
    mrb_define_const(mrb, mRaylib, "GESTURE_SWIPE_RIGHT", mrb_int_value(mrb, 16));
    mrb_define_const(mrb, mRaylib, "GESTURE_SWIPE_LEFT", mrb_int_value(mrb, 32));
    mrb_define_const(mrb, mRaylib, "GESTURE_SWIPE_UP", mrb_int_value(mrb, 64));
    mrb_define_const(mrb, mRaylib, "GESTURE_SWIPE_DOWN", mrb_int_value(mrb, 128));
    mrb_define_const(mrb, mRaylib, "GESTURE_PINCH_IN", mrb_int_value(mrb, 256));
    mrb_define_const(mrb, mRaylib, "GESTURE_PINCH_OUT", mrb_int_value(mrb, 512));

    // enum CameraMode
    mrb_define_const(mrb, mRaylib, "CAMERA_CUSTOM", mrb_int_value(mrb, 0));
    mrb_define_const(mrb, mRaylib, "CAMERA_FREE", mrb_int_value(mrb, 1));
    mrb_define_const(mrb, mRaylib, "CAMERA_ORBITAL", mrb_int_value(mrb, 2));
    mrb_define_const(mrb, mRaylib, "CAMERA_FIRST_PERSON", mrb_int_value(mrb, 3));
    mrb_define_const(mrb, mRaylib, "CAMERA_THIRD_PERSON", mrb_int_value(mrb, 4));

    // enum CameraProjection
    mrb_define_const(mrb, mRaylib, "CAMERA_PERSPECTIVE", mrb_int_value(mrb, 0));
    mrb_define_const(mrb, mRaylib, "CAMERA_ORTHOGRAPHIC", mrb_int_value(mrb, 1));

    // enum NPatchLayout
    mrb_define_const(mrb, mRaylib, "NPATCH_NINE_PATCH", mrb_int_value(mrb, 0));
    mrb_define_const(mrb, mRaylib, "NPATCH_THREE_PATCH_VERTICAL", mrb_int_value(mrb, 1));
    mrb_define_const(mrb, mRaylib, "NPATCH_THREE_PATCH_HORIZONTAL", mrb_int_value(mrb, 2));


    // Struct

    cRaylibVector2 = mrb_define_class_under(mrb, mRaylib, "Vector2", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibVector2, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibVector2, "initialize", mrb_raylib_Vector2_initialize, MRB_ARGS_OPT(1));
    mrb_define_method(mrb, cRaylibVector2, "x", mrb_raylib_Vector2_x_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibVector2, "x=", mrb_raylib_Vector2_x_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibVector2, "y", mrb_raylib_Vector2_y_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibVector2, "y=", mrb_raylib_Vector2_y_set, MRB_ARGS_REQ(1));

    cRaylibVector3 = mrb_define_class_under(mrb, mRaylib, "Vector3", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibVector3, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibVector3, "initialize", mrb_raylib_Vector3_initialize, MRB_ARGS_OPT(1));
    mrb_define_method(mrb, cRaylibVector3, "x", mrb_raylib_Vector3_x_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibVector3, "x=", mrb_raylib_Vector3_x_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibVector3, "y", mrb_raylib_Vector3_y_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibVector3, "y=", mrb_raylib_Vector3_y_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibVector3, "z", mrb_raylib_Vector3_z_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibVector3, "z=", mrb_raylib_Vector3_z_set, MRB_ARGS_REQ(1));

    cRaylibVector4 = mrb_define_class_under(mrb, mRaylib, "Vector4", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibVector4, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibVector4, "initialize", mrb_raylib_Vector4_initialize, MRB_ARGS_OPT(1));
    mrb_define_method(mrb, cRaylibVector4, "x", mrb_raylib_Vector4_x_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibVector4, "x=", mrb_raylib_Vector4_x_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibVector4, "y", mrb_raylib_Vector4_y_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibVector4, "y=", mrb_raylib_Vector4_y_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibVector4, "z", mrb_raylib_Vector4_z_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibVector4, "z=", mrb_raylib_Vector4_z_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibVector4, "w", mrb_raylib_Vector4_w_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibVector4, "w=", mrb_raylib_Vector4_w_set, MRB_ARGS_REQ(1));

    cRaylibMatrix = mrb_define_class_under(mrb, mRaylib, "Matrix", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibMatrix, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibMatrix, "initialize", mrb_raylib_Matrix_initialize, MRB_ARGS_OPT(1));
    mrb_define_method(mrb, cRaylibMatrix, "m0", mrb_raylib_Matrix_m0_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibMatrix, "m0=", mrb_raylib_Matrix_m0_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibMatrix, "m4", mrb_raylib_Matrix_m4_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibMatrix, "m4=", mrb_raylib_Matrix_m4_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibMatrix, "m8", mrb_raylib_Matrix_m8_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibMatrix, "m8=", mrb_raylib_Matrix_m8_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibMatrix, "m12", mrb_raylib_Matrix_m12_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibMatrix, "m12=", mrb_raylib_Matrix_m12_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibMatrix, "m1", mrb_raylib_Matrix_m1_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibMatrix, "m1=", mrb_raylib_Matrix_m1_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibMatrix, "m5", mrb_raylib_Matrix_m5_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibMatrix, "m5=", mrb_raylib_Matrix_m5_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibMatrix, "m9", mrb_raylib_Matrix_m9_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibMatrix, "m9=", mrb_raylib_Matrix_m9_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibMatrix, "m13", mrb_raylib_Matrix_m13_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibMatrix, "m13=", mrb_raylib_Matrix_m13_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibMatrix, "m2", mrb_raylib_Matrix_m2_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibMatrix, "m2=", mrb_raylib_Matrix_m2_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibMatrix, "m6", mrb_raylib_Matrix_m6_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibMatrix, "m6=", mrb_raylib_Matrix_m6_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibMatrix, "m10", mrb_raylib_Matrix_m10_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibMatrix, "m10=", mrb_raylib_Matrix_m10_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibMatrix, "m14", mrb_raylib_Matrix_m14_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibMatrix, "m14=", mrb_raylib_Matrix_m14_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibMatrix, "m3", mrb_raylib_Matrix_m3_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibMatrix, "m3=", mrb_raylib_Matrix_m3_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibMatrix, "m7", mrb_raylib_Matrix_m7_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibMatrix, "m7=", mrb_raylib_Matrix_m7_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibMatrix, "m11", mrb_raylib_Matrix_m11_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibMatrix, "m11=", mrb_raylib_Matrix_m11_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibMatrix, "m15", mrb_raylib_Matrix_m15_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibMatrix, "m15=", mrb_raylib_Matrix_m15_set, MRB_ARGS_REQ(1));

    cRaylibColor = mrb_define_class_under(mrb, mRaylib, "Color", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibColor, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibColor, "initialize", mrb_raylib_Color_initialize, MRB_ARGS_OPT(1));
    mrb_define_method(mrb, cRaylibColor, "r", mrb_raylib_Color_r_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibColor, "r=", mrb_raylib_Color_r_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibColor, "g", mrb_raylib_Color_g_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibColor, "g=", mrb_raylib_Color_g_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibColor, "b", mrb_raylib_Color_b_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibColor, "b=", mrb_raylib_Color_b_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibColor, "a", mrb_raylib_Color_a_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibColor, "a=", mrb_raylib_Color_a_set, MRB_ARGS_REQ(1));

    cRaylibRectangle = mrb_define_class_under(mrb, mRaylib, "Rectangle", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibRectangle, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibRectangle, "initialize", mrb_raylib_Rectangle_initialize, MRB_ARGS_OPT(1));
    mrb_define_method(mrb, cRaylibRectangle, "x", mrb_raylib_Rectangle_x_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibRectangle, "x=", mrb_raylib_Rectangle_x_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibRectangle, "y", mrb_raylib_Rectangle_y_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibRectangle, "y=", mrb_raylib_Rectangle_y_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibRectangle, "width", mrb_raylib_Rectangle_width_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibRectangle, "width=", mrb_raylib_Rectangle_width_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibRectangle, "height", mrb_raylib_Rectangle_height_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibRectangle, "height=", mrb_raylib_Rectangle_height_set, MRB_ARGS_REQ(1));

    cRaylibImage = mrb_define_class_under(mrb, mRaylib, "Image", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibImage, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibImage, "initialize", mrb_raylib_Image_initialize, MRB_ARGS_OPT(1));
    // mrb_define_method(mrb, cRaylibImage, "data", mrb_raylib_Image_data_get, MRB_ARGS_NONE()); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibImage, "data=", mrb_raylib_Image_data_set, MRB_ARGS_REQ(1)); // TODO prepare Buffer version of classes
    mrb_define_method(mrb, cRaylibImage, "width", mrb_raylib_Image_width_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibImage, "width=", mrb_raylib_Image_width_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibImage, "height", mrb_raylib_Image_height_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibImage, "height=", mrb_raylib_Image_height_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibImage, "mipmaps", mrb_raylib_Image_mipmaps_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibImage, "mipmaps=", mrb_raylib_Image_mipmaps_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibImage, "format", mrb_raylib_Image_format_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibImage, "format=", mrb_raylib_Image_format_set, MRB_ARGS_REQ(1));

    cRaylibTexture = mrb_define_class_under(mrb, mRaylib, "Texture", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibTexture, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibTexture, "initialize", mrb_raylib_Texture_initialize, MRB_ARGS_OPT(1));
    mrb_define_method(mrb, cRaylibTexture, "id", mrb_raylib_Texture_id_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibTexture, "id=", mrb_raylib_Texture_id_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibTexture, "width", mrb_raylib_Texture_width_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibTexture, "width=", mrb_raylib_Texture_width_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibTexture, "height", mrb_raylib_Texture_height_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibTexture, "height=", mrb_raylib_Texture_height_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibTexture, "mipmaps", mrb_raylib_Texture_mipmaps_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibTexture, "mipmaps=", mrb_raylib_Texture_mipmaps_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibTexture, "format", mrb_raylib_Texture_format_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibTexture, "format=", mrb_raylib_Texture_format_set, MRB_ARGS_REQ(1));

    cRaylibRenderTexture = mrb_define_class_under(mrb, mRaylib, "RenderTexture", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibRenderTexture, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibRenderTexture, "initialize", mrb_raylib_RenderTexture_initialize, MRB_ARGS_OPT(1));
    mrb_define_method(mrb, cRaylibRenderTexture, "id", mrb_raylib_RenderTexture_id_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibRenderTexture, "id=", mrb_raylib_RenderTexture_id_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibRenderTexture, "texture", mrb_raylib_RenderTexture_texture_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibRenderTexture, "texture=", mrb_raylib_RenderTexture_texture_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibRenderTexture, "depth", mrb_raylib_RenderTexture_depth_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibRenderTexture, "depth=", mrb_raylib_RenderTexture_depth_set, MRB_ARGS_REQ(1));

    cRaylibNPatchInfo = mrb_define_class_under(mrb, mRaylib, "NPatchInfo", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibNPatchInfo, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibNPatchInfo, "initialize", mrb_raylib_NPatchInfo_initialize, MRB_ARGS_OPT(1));
    mrb_define_method(mrb, cRaylibNPatchInfo, "source", mrb_raylib_NPatchInfo_source_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibNPatchInfo, "source=", mrb_raylib_NPatchInfo_source_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibNPatchInfo, "left", mrb_raylib_NPatchInfo_left_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibNPatchInfo, "left=", mrb_raylib_NPatchInfo_left_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibNPatchInfo, "top", mrb_raylib_NPatchInfo_top_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibNPatchInfo, "top=", mrb_raylib_NPatchInfo_top_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibNPatchInfo, "right", mrb_raylib_NPatchInfo_right_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibNPatchInfo, "right=", mrb_raylib_NPatchInfo_right_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibNPatchInfo, "bottom", mrb_raylib_NPatchInfo_bottom_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibNPatchInfo, "bottom=", mrb_raylib_NPatchInfo_bottom_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibNPatchInfo, "layout", mrb_raylib_NPatchInfo_layout_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibNPatchInfo, "layout=", mrb_raylib_NPatchInfo_layout_set, MRB_ARGS_REQ(1));

    cRaylibGlyphInfo = mrb_define_class_under(mrb, mRaylib, "GlyphInfo", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibGlyphInfo, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibGlyphInfo, "initialize", mrb_raylib_GlyphInfo_initialize, MRB_ARGS_OPT(1));
    mrb_define_method(mrb, cRaylibGlyphInfo, "value", mrb_raylib_GlyphInfo_value_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibGlyphInfo, "value=", mrb_raylib_GlyphInfo_value_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibGlyphInfo, "offsetX", mrb_raylib_GlyphInfo_offsetX_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibGlyphInfo, "offsetX=", mrb_raylib_GlyphInfo_offsetX_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibGlyphInfo, "offsetY", mrb_raylib_GlyphInfo_offsetY_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibGlyphInfo, "offsetY=", mrb_raylib_GlyphInfo_offsetY_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibGlyphInfo, "advanceX", mrb_raylib_GlyphInfo_advanceX_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibGlyphInfo, "advanceX=", mrb_raylib_GlyphInfo_advanceX_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibGlyphInfo, "image", mrb_raylib_GlyphInfo_image_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibGlyphInfo, "image=", mrb_raylib_GlyphInfo_image_set, MRB_ARGS_REQ(1));

    cRaylibFont = mrb_define_class_under(mrb, mRaylib, "Font", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibFont, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibFont, "initialize", mrb_raylib_Font_initialize, MRB_ARGS_OPT(1));
    mrb_define_method(mrb, cRaylibFont, "baseSize", mrb_raylib_Font_baseSize_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibFont, "baseSize=", mrb_raylib_Font_baseSize_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibFont, "glyphCount", mrb_raylib_Font_glyphCount_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibFont, "glyphCount=", mrb_raylib_Font_glyphCount_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibFont, "glyphPadding", mrb_raylib_Font_glyphPadding_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibFont, "glyphPadding=", mrb_raylib_Font_glyphPadding_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibFont, "texture", mrb_raylib_Font_texture_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibFont, "texture=", mrb_raylib_Font_texture_set, MRB_ARGS_REQ(1));
    // mrb_define_method(mrb, cRaylibFont, "recs", mrb_raylib_Font_recs_get, MRB_ARGS_NONE()); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibFont, "recs=", mrb_raylib_Font_recs_set, MRB_ARGS_REQ(1)); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibFont, "glyphs", mrb_raylib_Font_glyphs_get, MRB_ARGS_NONE()); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibFont, "glyphs=", mrb_raylib_Font_glyphs_set, MRB_ARGS_REQ(1)); // TODO prepare Buffer version of classes

    cRaylibCamera3D = mrb_define_class_under(mrb, mRaylib, "Camera3D", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibCamera3D, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibCamera3D, "initialize", mrb_raylib_Camera3D_initialize, MRB_ARGS_OPT(1));
    mrb_define_method(mrb, cRaylibCamera3D, "position", mrb_raylib_Camera3D_position_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibCamera3D, "position=", mrb_raylib_Camera3D_position_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibCamera3D, "target", mrb_raylib_Camera3D_target_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibCamera3D, "target=", mrb_raylib_Camera3D_target_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibCamera3D, "up", mrb_raylib_Camera3D_up_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibCamera3D, "up=", mrb_raylib_Camera3D_up_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibCamera3D, "fovy", mrb_raylib_Camera3D_fovy_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibCamera3D, "fovy=", mrb_raylib_Camera3D_fovy_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibCamera3D, "projection", mrb_raylib_Camera3D_projection_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibCamera3D, "projection=", mrb_raylib_Camera3D_projection_set, MRB_ARGS_REQ(1));

    cRaylibCamera2D = mrb_define_class_under(mrb, mRaylib, "Camera2D", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibCamera2D, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibCamera2D, "initialize", mrb_raylib_Camera2D_initialize, MRB_ARGS_OPT(1));
    mrb_define_method(mrb, cRaylibCamera2D, "offset", mrb_raylib_Camera2D_offset_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibCamera2D, "offset=", mrb_raylib_Camera2D_offset_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibCamera2D, "target", mrb_raylib_Camera2D_target_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibCamera2D, "target=", mrb_raylib_Camera2D_target_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibCamera2D, "rotation", mrb_raylib_Camera2D_rotation_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibCamera2D, "rotation=", mrb_raylib_Camera2D_rotation_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibCamera2D, "zoom", mrb_raylib_Camera2D_zoom_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibCamera2D, "zoom=", mrb_raylib_Camera2D_zoom_set, MRB_ARGS_REQ(1));

    cRaylibMesh = mrb_define_class_under(mrb, mRaylib, "Mesh", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibMesh, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibMesh, "initialize", mrb_raylib_Mesh_initialize, MRB_ARGS_OPT(1));
    mrb_define_method(mrb, cRaylibMesh, "vertexCount", mrb_raylib_Mesh_vertexCount_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibMesh, "vertexCount=", mrb_raylib_Mesh_vertexCount_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibMesh, "triangleCount", mrb_raylib_Mesh_triangleCount_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibMesh, "triangleCount=", mrb_raylib_Mesh_triangleCount_set, MRB_ARGS_REQ(1));
    // mrb_define_method(mrb, cRaylibMesh, "vertices", mrb_raylib_Mesh_vertices_get, MRB_ARGS_NONE()); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibMesh, "vertices=", mrb_raylib_Mesh_vertices_set, MRB_ARGS_REQ(1)); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibMesh, "texcoords", mrb_raylib_Mesh_texcoords_get, MRB_ARGS_NONE()); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibMesh, "texcoords=", mrb_raylib_Mesh_texcoords_set, MRB_ARGS_REQ(1)); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibMesh, "texcoords2", mrb_raylib_Mesh_texcoords2_get, MRB_ARGS_NONE()); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibMesh, "texcoords2=", mrb_raylib_Mesh_texcoords2_set, MRB_ARGS_REQ(1)); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibMesh, "normals", mrb_raylib_Mesh_normals_get, MRB_ARGS_NONE()); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibMesh, "normals=", mrb_raylib_Mesh_normals_set, MRB_ARGS_REQ(1)); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibMesh, "tangents", mrb_raylib_Mesh_tangents_get, MRB_ARGS_NONE()); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibMesh, "tangents=", mrb_raylib_Mesh_tangents_set, MRB_ARGS_REQ(1)); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibMesh, "colors", mrb_raylib_Mesh_colors_get, MRB_ARGS_NONE()); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibMesh, "colors=", mrb_raylib_Mesh_colors_set, MRB_ARGS_REQ(1)); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibMesh, "indices", mrb_raylib_Mesh_indices_get, MRB_ARGS_NONE()); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibMesh, "indices=", mrb_raylib_Mesh_indices_set, MRB_ARGS_REQ(1)); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibMesh, "animVertices", mrb_raylib_Mesh_animVertices_get, MRB_ARGS_NONE()); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibMesh, "animVertices=", mrb_raylib_Mesh_animVertices_set, MRB_ARGS_REQ(1)); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibMesh, "animNormals", mrb_raylib_Mesh_animNormals_get, MRB_ARGS_NONE()); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibMesh, "animNormals=", mrb_raylib_Mesh_animNormals_set, MRB_ARGS_REQ(1)); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibMesh, "boneIds", mrb_raylib_Mesh_boneIds_get, MRB_ARGS_NONE()); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibMesh, "boneIds=", mrb_raylib_Mesh_boneIds_set, MRB_ARGS_REQ(1)); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibMesh, "boneWeights", mrb_raylib_Mesh_boneWeights_get, MRB_ARGS_NONE()); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibMesh, "boneWeights=", mrb_raylib_Mesh_boneWeights_set, MRB_ARGS_REQ(1)); // TODO prepare Buffer version of classes
    mrb_define_method(mrb, cRaylibMesh, "vaoId", mrb_raylib_Mesh_vaoId_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibMesh, "vaoId=", mrb_raylib_Mesh_vaoId_set, MRB_ARGS_REQ(1));
    // mrb_define_method(mrb, cRaylibMesh, "vboId", mrb_raylib_Mesh_vboId_get, MRB_ARGS_NONE()); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibMesh, "vboId=", mrb_raylib_Mesh_vboId_set, MRB_ARGS_REQ(1)); // TODO prepare Buffer version of classes

    cRaylibShader = mrb_define_class_under(mrb, mRaylib, "Shader", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibShader, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibShader, "initialize", mrb_raylib_Shader_initialize, MRB_ARGS_OPT(1));
    mrb_define_method(mrb, cRaylibShader, "id", mrb_raylib_Shader_id_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibShader, "id=", mrb_raylib_Shader_id_set, MRB_ARGS_REQ(1));
    // mrb_define_method(mrb, cRaylibShader, "locs", mrb_raylib_Shader_locs_get, MRB_ARGS_NONE()); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibShader, "locs=", mrb_raylib_Shader_locs_set, MRB_ARGS_REQ(1)); // TODO prepare Buffer version of classes

    cRaylibMaterialMap = mrb_define_class_under(mrb, mRaylib, "MaterialMap", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibMaterialMap, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibMaterialMap, "initialize", mrb_raylib_MaterialMap_initialize, MRB_ARGS_OPT(1));
    mrb_define_method(mrb, cRaylibMaterialMap, "texture", mrb_raylib_MaterialMap_texture_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibMaterialMap, "texture=", mrb_raylib_MaterialMap_texture_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibMaterialMap, "color", mrb_raylib_MaterialMap_color_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibMaterialMap, "color=", mrb_raylib_MaterialMap_color_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibMaterialMap, "value", mrb_raylib_MaterialMap_value_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibMaterialMap, "value=", mrb_raylib_MaterialMap_value_set, MRB_ARGS_REQ(1));

    cRaylibMaterial = mrb_define_class_under(mrb, mRaylib, "Material", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibMaterial, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibMaterial, "initialize", mrb_raylib_Material_initialize, MRB_ARGS_OPT(1));
    mrb_define_method(mrb, cRaylibMaterial, "shader", mrb_raylib_Material_shader_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibMaterial, "shader=", mrb_raylib_Material_shader_set, MRB_ARGS_REQ(1));
    // mrb_define_method(mrb, cRaylibMaterial, "maps", mrb_raylib_Material_maps_get, MRB_ARGS_NONE()); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibMaterial, "maps=", mrb_raylib_Material_maps_set, MRB_ARGS_REQ(1)); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibMaterial, "params", mrb_raylib_Material_params_get, MRB_ARGS_NONE()); // TODO add accessor which can handle array
    // mrb_define_method(mrb, cRaylibMaterial, "params=", mrb_raylib_Material_params_set, MRB_ARGS_REQ(1)); // TODO add accessor which can handle array

    cRaylibTransform = mrb_define_class_under(mrb, mRaylib, "Transform", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibTransform, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibTransform, "initialize", mrb_raylib_Transform_initialize, MRB_ARGS_OPT(1));
    mrb_define_method(mrb, cRaylibTransform, "translation", mrb_raylib_Transform_translation_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibTransform, "translation=", mrb_raylib_Transform_translation_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibTransform, "rotation", mrb_raylib_Transform_rotation_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibTransform, "rotation=", mrb_raylib_Transform_rotation_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibTransform, "scale", mrb_raylib_Transform_scale_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibTransform, "scale=", mrb_raylib_Transform_scale_set, MRB_ARGS_REQ(1));

    cRaylibBoneInfo = mrb_define_class_under(mrb, mRaylib, "BoneInfo", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibBoneInfo, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibBoneInfo, "initialize", mrb_raylib_BoneInfo_initialize, MRB_ARGS_OPT(1));
    mrb_define_method(mrb, cRaylibBoneInfo, "name", mrb_raylib_BoneInfo_name_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibBoneInfo, "name=", mrb_raylib_BoneInfo_name_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibBoneInfo, "parent", mrb_raylib_BoneInfo_parent_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibBoneInfo, "parent=", mrb_raylib_BoneInfo_parent_set, MRB_ARGS_REQ(1));

    cRaylibModel = mrb_define_class_under(mrb, mRaylib, "Model", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibModel, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibModel, "initialize", mrb_raylib_Model_initialize, MRB_ARGS_OPT(1));
    mrb_define_method(mrb, cRaylibModel, "transform", mrb_raylib_Model_transform_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibModel, "transform=", mrb_raylib_Model_transform_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibModel, "meshCount", mrb_raylib_Model_meshCount_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibModel, "meshCount=", mrb_raylib_Model_meshCount_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibModel, "materialCount", mrb_raylib_Model_materialCount_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibModel, "materialCount=", mrb_raylib_Model_materialCount_set, MRB_ARGS_REQ(1));
    // mrb_define_method(mrb, cRaylibModel, "meshes", mrb_raylib_Model_meshes_get, MRB_ARGS_NONE()); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibModel, "meshes=", mrb_raylib_Model_meshes_set, MRB_ARGS_REQ(1)); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibModel, "materials", mrb_raylib_Model_materials_get, MRB_ARGS_NONE()); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibModel, "materials=", mrb_raylib_Model_materials_set, MRB_ARGS_REQ(1)); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibModel, "meshMaterial", mrb_raylib_Model_meshMaterial_get, MRB_ARGS_NONE()); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibModel, "meshMaterial=", mrb_raylib_Model_meshMaterial_set, MRB_ARGS_REQ(1)); // TODO prepare Buffer version of classes
    mrb_define_method(mrb, cRaylibModel, "boneCount", mrb_raylib_Model_boneCount_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibModel, "boneCount=", mrb_raylib_Model_boneCount_set, MRB_ARGS_REQ(1));
    // mrb_define_method(mrb, cRaylibModel, "bones", mrb_raylib_Model_bones_get, MRB_ARGS_NONE()); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibModel, "bones=", mrb_raylib_Model_bones_set, MRB_ARGS_REQ(1)); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibModel, "bindPose", mrb_raylib_Model_bindPose_get, MRB_ARGS_NONE()); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibModel, "bindPose=", mrb_raylib_Model_bindPose_set, MRB_ARGS_REQ(1)); // TODO prepare Buffer version of classes

    cRaylibModelAnimation = mrb_define_class_under(mrb, mRaylib, "ModelAnimation", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibModelAnimation, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibModelAnimation, "initialize", mrb_raylib_ModelAnimation_initialize, MRB_ARGS_OPT(1));
    mrb_define_method(mrb, cRaylibModelAnimation, "boneCount", mrb_raylib_ModelAnimation_boneCount_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibModelAnimation, "boneCount=", mrb_raylib_ModelAnimation_boneCount_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibModelAnimation, "frameCount", mrb_raylib_ModelAnimation_frameCount_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibModelAnimation, "frameCount=", mrb_raylib_ModelAnimation_frameCount_set, MRB_ARGS_REQ(1));
    // mrb_define_method(mrb, cRaylibModelAnimation, "bones", mrb_raylib_ModelAnimation_bones_get, MRB_ARGS_NONE()); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibModelAnimation, "bones=", mrb_raylib_ModelAnimation_bones_set, MRB_ARGS_REQ(1)); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibModelAnimation, "framePoses", mrb_raylib_ModelAnimation_framePoses_get, MRB_ARGS_NONE()); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibModelAnimation, "framePoses=", mrb_raylib_ModelAnimation_framePoses_set, MRB_ARGS_REQ(1)); // TODO prepare Buffer version of classes
    mrb_define_method(mrb, cRaylibModelAnimation, "name", mrb_raylib_ModelAnimation_name_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibModelAnimation, "name=", mrb_raylib_ModelAnimation_name_set, MRB_ARGS_REQ(1));

    cRaylibRay = mrb_define_class_under(mrb, mRaylib, "Ray", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibRay, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibRay, "initialize", mrb_raylib_Ray_initialize, MRB_ARGS_OPT(1));
    mrb_define_method(mrb, cRaylibRay, "position", mrb_raylib_Ray_position_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibRay, "position=", mrb_raylib_Ray_position_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibRay, "direction", mrb_raylib_Ray_direction_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibRay, "direction=", mrb_raylib_Ray_direction_set, MRB_ARGS_REQ(1));

    cRaylibRayCollision = mrb_define_class_under(mrb, mRaylib, "RayCollision", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibRayCollision, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibRayCollision, "initialize", mrb_raylib_RayCollision_initialize, MRB_ARGS_OPT(1));
    mrb_define_method(mrb, cRaylibRayCollision, "hit", mrb_raylib_RayCollision_hit_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibRayCollision, "hit=", mrb_raylib_RayCollision_hit_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibRayCollision, "distance", mrb_raylib_RayCollision_distance_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibRayCollision, "distance=", mrb_raylib_RayCollision_distance_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibRayCollision, "point", mrb_raylib_RayCollision_point_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibRayCollision, "point=", mrb_raylib_RayCollision_point_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibRayCollision, "normal", mrb_raylib_RayCollision_normal_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibRayCollision, "normal=", mrb_raylib_RayCollision_normal_set, MRB_ARGS_REQ(1));

    cRaylibBoundingBox = mrb_define_class_under(mrb, mRaylib, "BoundingBox", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibBoundingBox, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibBoundingBox, "initialize", mrb_raylib_BoundingBox_initialize, MRB_ARGS_OPT(1));
    mrb_define_method(mrb, cRaylibBoundingBox, "min", mrb_raylib_BoundingBox_min_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibBoundingBox, "min=", mrb_raylib_BoundingBox_min_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibBoundingBox, "max", mrb_raylib_BoundingBox_max_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibBoundingBox, "max=", mrb_raylib_BoundingBox_max_set, MRB_ARGS_REQ(1));

    cRaylibWave = mrb_define_class_under(mrb, mRaylib, "Wave", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibWave, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibWave, "initialize", mrb_raylib_Wave_initialize, MRB_ARGS_OPT(1));
    mrb_define_method(mrb, cRaylibWave, "frameCount", mrb_raylib_Wave_frameCount_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibWave, "frameCount=", mrb_raylib_Wave_frameCount_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibWave, "sampleRate", mrb_raylib_Wave_sampleRate_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibWave, "sampleRate=", mrb_raylib_Wave_sampleRate_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibWave, "sampleSize", mrb_raylib_Wave_sampleSize_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibWave, "sampleSize=", mrb_raylib_Wave_sampleSize_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibWave, "channels", mrb_raylib_Wave_channels_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibWave, "channels=", mrb_raylib_Wave_channels_set, MRB_ARGS_REQ(1));
    // mrb_define_method(mrb, cRaylibWave, "data", mrb_raylib_Wave_data_get, MRB_ARGS_NONE()); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibWave, "data=", mrb_raylib_Wave_data_set, MRB_ARGS_REQ(1)); // TODO prepare Buffer version of classes

    cRaylibAudioStream = mrb_define_class_under(mrb, mRaylib, "AudioStream", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibAudioStream, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibAudioStream, "initialize", mrb_raylib_AudioStream_initialize, MRB_ARGS_OPT(1));
    // mrb_define_method(mrb, cRaylibAudioStream, "buffer", mrb_raylib_AudioStream_buffer_get, MRB_ARGS_NONE()); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibAudioStream, "buffer=", mrb_raylib_AudioStream_buffer_set, MRB_ARGS_REQ(1)); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibAudioStream, "processor", mrb_raylib_AudioStream_processor_get, MRB_ARGS_NONE()); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibAudioStream, "processor=", mrb_raylib_AudioStream_processor_set, MRB_ARGS_REQ(1)); // TODO prepare Buffer version of classes
    mrb_define_method(mrb, cRaylibAudioStream, "sampleRate", mrb_raylib_AudioStream_sampleRate_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibAudioStream, "sampleRate=", mrb_raylib_AudioStream_sampleRate_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibAudioStream, "sampleSize", mrb_raylib_AudioStream_sampleSize_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibAudioStream, "sampleSize=", mrb_raylib_AudioStream_sampleSize_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibAudioStream, "channels", mrb_raylib_AudioStream_channels_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibAudioStream, "channels=", mrb_raylib_AudioStream_channels_set, MRB_ARGS_REQ(1));

    cRaylibSound = mrb_define_class_under(mrb, mRaylib, "Sound", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibSound, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibSound, "initialize", mrb_raylib_Sound_initialize, MRB_ARGS_OPT(1));
    mrb_define_method(mrb, cRaylibSound, "stream", mrb_raylib_Sound_stream_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibSound, "stream=", mrb_raylib_Sound_stream_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibSound, "frameCount", mrb_raylib_Sound_frameCount_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibSound, "frameCount=", mrb_raylib_Sound_frameCount_set, MRB_ARGS_REQ(1));

    cRaylibMusic = mrb_define_class_under(mrb, mRaylib, "Music", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibMusic, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibMusic, "initialize", mrb_raylib_Music_initialize, MRB_ARGS_OPT(1));
    mrb_define_method(mrb, cRaylibMusic, "stream", mrb_raylib_Music_stream_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibMusic, "stream=", mrb_raylib_Music_stream_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibMusic, "frameCount", mrb_raylib_Music_frameCount_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibMusic, "frameCount=", mrb_raylib_Music_frameCount_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibMusic, "looping", mrb_raylib_Music_looping_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibMusic, "looping=", mrb_raylib_Music_looping_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibMusic, "ctxType", mrb_raylib_Music_ctxType_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibMusic, "ctxType=", mrb_raylib_Music_ctxType_set, MRB_ARGS_REQ(1));
    // mrb_define_method(mrb, cRaylibMusic, "ctxData", mrb_raylib_Music_ctxData_get, MRB_ARGS_NONE()); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibMusic, "ctxData=", mrb_raylib_Music_ctxData_set, MRB_ARGS_REQ(1)); // TODO prepare Buffer version of classes

    cRaylibVrDeviceInfo = mrb_define_class_under(mrb, mRaylib, "VrDeviceInfo", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibVrDeviceInfo, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibVrDeviceInfo, "initialize", mrb_raylib_VrDeviceInfo_initialize, MRB_ARGS_OPT(1));
    mrb_define_method(mrb, cRaylibVrDeviceInfo, "hResolution", mrb_raylib_VrDeviceInfo_hResolution_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibVrDeviceInfo, "hResolution=", mrb_raylib_VrDeviceInfo_hResolution_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibVrDeviceInfo, "vResolution", mrb_raylib_VrDeviceInfo_vResolution_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibVrDeviceInfo, "vResolution=", mrb_raylib_VrDeviceInfo_vResolution_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibVrDeviceInfo, "hScreenSize", mrb_raylib_VrDeviceInfo_hScreenSize_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibVrDeviceInfo, "hScreenSize=", mrb_raylib_VrDeviceInfo_hScreenSize_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibVrDeviceInfo, "vScreenSize", mrb_raylib_VrDeviceInfo_vScreenSize_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibVrDeviceInfo, "vScreenSize=", mrb_raylib_VrDeviceInfo_vScreenSize_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibVrDeviceInfo, "vScreenCenter", mrb_raylib_VrDeviceInfo_vScreenCenter_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibVrDeviceInfo, "vScreenCenter=", mrb_raylib_VrDeviceInfo_vScreenCenter_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibVrDeviceInfo, "eyeToScreenDistance", mrb_raylib_VrDeviceInfo_eyeToScreenDistance_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibVrDeviceInfo, "eyeToScreenDistance=", mrb_raylib_VrDeviceInfo_eyeToScreenDistance_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibVrDeviceInfo, "lensSeparationDistance", mrb_raylib_VrDeviceInfo_lensSeparationDistance_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibVrDeviceInfo, "lensSeparationDistance=", mrb_raylib_VrDeviceInfo_lensSeparationDistance_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibVrDeviceInfo, "interpupillaryDistance", mrb_raylib_VrDeviceInfo_interpupillaryDistance_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibVrDeviceInfo, "interpupillaryDistance=", mrb_raylib_VrDeviceInfo_interpupillaryDistance_set, MRB_ARGS_REQ(1));
    // mrb_define_method(mrb, cRaylibVrDeviceInfo, "lensDistortionValues", mrb_raylib_VrDeviceInfo_lensDistortionValues_get, MRB_ARGS_NONE()); // TODO add accessor which can handle array
    // mrb_define_method(mrb, cRaylibVrDeviceInfo, "lensDistortionValues=", mrb_raylib_VrDeviceInfo_lensDistortionValues_set, MRB_ARGS_REQ(1)); // TODO add accessor which can handle array
    // mrb_define_method(mrb, cRaylibVrDeviceInfo, "chromaAbCorrection", mrb_raylib_VrDeviceInfo_chromaAbCorrection_get, MRB_ARGS_NONE()); // TODO add accessor which can handle array
    // mrb_define_method(mrb, cRaylibVrDeviceInfo, "chromaAbCorrection=", mrb_raylib_VrDeviceInfo_chromaAbCorrection_set, MRB_ARGS_REQ(1)); // TODO add accessor which can handle array

    cRaylibVrStereoConfig = mrb_define_class_under(mrb, mRaylib, "VrStereoConfig", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibVrStereoConfig, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibVrStereoConfig, "initialize", mrb_raylib_VrStereoConfig_initialize, MRB_ARGS_OPT(1));
    // mrb_define_method(mrb, cRaylibVrStereoConfig, "projection", mrb_raylib_VrStereoConfig_projection_get, MRB_ARGS_NONE()); // TODO add accessor which can handle array
    // mrb_define_method(mrb, cRaylibVrStereoConfig, "projection=", mrb_raylib_VrStereoConfig_projection_set, MRB_ARGS_REQ(1)); // TODO add accessor which can handle array
    // mrb_define_method(mrb, cRaylibVrStereoConfig, "viewOffset", mrb_raylib_VrStereoConfig_viewOffset_get, MRB_ARGS_NONE()); // TODO add accessor which can handle array
    // mrb_define_method(mrb, cRaylibVrStereoConfig, "viewOffset=", mrb_raylib_VrStereoConfig_viewOffset_set, MRB_ARGS_REQ(1)); // TODO add accessor which can handle array
    // mrb_define_method(mrb, cRaylibVrStereoConfig, "leftLensCenter", mrb_raylib_VrStereoConfig_leftLensCenter_get, MRB_ARGS_NONE()); // TODO add accessor which can handle array
    // mrb_define_method(mrb, cRaylibVrStereoConfig, "leftLensCenter=", mrb_raylib_VrStereoConfig_leftLensCenter_set, MRB_ARGS_REQ(1)); // TODO add accessor which can handle array
    // mrb_define_method(mrb, cRaylibVrStereoConfig, "rightLensCenter", mrb_raylib_VrStereoConfig_rightLensCenter_get, MRB_ARGS_NONE()); // TODO add accessor which can handle array
    // mrb_define_method(mrb, cRaylibVrStereoConfig, "rightLensCenter=", mrb_raylib_VrStereoConfig_rightLensCenter_set, MRB_ARGS_REQ(1)); // TODO add accessor which can handle array
    // mrb_define_method(mrb, cRaylibVrStereoConfig, "leftScreenCenter", mrb_raylib_VrStereoConfig_leftScreenCenter_get, MRB_ARGS_NONE()); // TODO add accessor which can handle array
    // mrb_define_method(mrb, cRaylibVrStereoConfig, "leftScreenCenter=", mrb_raylib_VrStereoConfig_leftScreenCenter_set, MRB_ARGS_REQ(1)); // TODO add accessor which can handle array
    // mrb_define_method(mrb, cRaylibVrStereoConfig, "rightScreenCenter", mrb_raylib_VrStereoConfig_rightScreenCenter_get, MRB_ARGS_NONE()); // TODO add accessor which can handle array
    // mrb_define_method(mrb, cRaylibVrStereoConfig, "rightScreenCenter=", mrb_raylib_VrStereoConfig_rightScreenCenter_set, MRB_ARGS_REQ(1)); // TODO add accessor which can handle array
    // mrb_define_method(mrb, cRaylibVrStereoConfig, "scale", mrb_raylib_VrStereoConfig_scale_get, MRB_ARGS_NONE()); // TODO add accessor which can handle array
    // mrb_define_method(mrb, cRaylibVrStereoConfig, "scale=", mrb_raylib_VrStereoConfig_scale_set, MRB_ARGS_REQ(1)); // TODO add accessor which can handle array
    // mrb_define_method(mrb, cRaylibVrStereoConfig, "scaleIn", mrb_raylib_VrStereoConfig_scaleIn_get, MRB_ARGS_NONE()); // TODO add accessor which can handle array
    // mrb_define_method(mrb, cRaylibVrStereoConfig, "scaleIn=", mrb_raylib_VrStereoConfig_scaleIn_set, MRB_ARGS_REQ(1)); // TODO add accessor which can handle array

    cRaylibFilePathList = mrb_define_class_under(mrb, mRaylib, "FilePathList", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibFilePathList, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibFilePathList, "initialize", mrb_raylib_FilePathList_initialize, MRB_ARGS_OPT(1));
    mrb_define_method(mrb, cRaylibFilePathList, "capacity", mrb_raylib_FilePathList_capacity_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibFilePathList, "capacity=", mrb_raylib_FilePathList_capacity_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibFilePathList, "count", mrb_raylib_FilePathList_count_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibFilePathList, "count=", mrb_raylib_FilePathList_count_set, MRB_ARGS_REQ(1));
    // mrb_define_method(mrb, cRaylibFilePathList, "paths", mrb_raylib_FilePathList_paths_get, MRB_ARGS_NONE()); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibFilePathList, "paths=", mrb_raylib_FilePathList_paths_set, MRB_ARGS_REQ(1)); // TODO prepare Buffer version of classes

    cRaylibAutomationEvent = mrb_define_class_under(mrb, mRaylib, "AutomationEvent", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibAutomationEvent, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibAutomationEvent, "initialize", mrb_raylib_AutomationEvent_initialize, MRB_ARGS_OPT(1));
    mrb_define_method(mrb, cRaylibAutomationEvent, "frame", mrb_raylib_AutomationEvent_frame_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibAutomationEvent, "frame=", mrb_raylib_AutomationEvent_frame_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibAutomationEvent, "type", mrb_raylib_AutomationEvent_type_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibAutomationEvent, "type=", mrb_raylib_AutomationEvent_type_set, MRB_ARGS_REQ(1));
    // mrb_define_method(mrb, cRaylibAutomationEvent, "params", mrb_raylib_AutomationEvent_params_get, MRB_ARGS_NONE()); // TODO add accessor which can handle array
    // mrb_define_method(mrb, cRaylibAutomationEvent, "params=", mrb_raylib_AutomationEvent_params_set, MRB_ARGS_REQ(1)); // TODO add accessor which can handle array

    cRaylibAutomationEventList = mrb_define_class_under(mrb, mRaylib, "AutomationEventList", mrb->object_class);
    MRB_SET_INSTANCE_TT(cRaylibAutomationEventList, MRB_TT_DATA);
    mrb_define_method(mrb, cRaylibAutomationEventList, "initialize", mrb_raylib_AutomationEventList_initialize, MRB_ARGS_OPT(1));
    mrb_define_method(mrb, cRaylibAutomationEventList, "capacity", mrb_raylib_AutomationEventList_capacity_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibAutomationEventList, "capacity=", mrb_raylib_AutomationEventList_capacity_set, MRB_ARGS_REQ(1));
    mrb_define_method(mrb, cRaylibAutomationEventList, "count", mrb_raylib_AutomationEventList_count_get, MRB_ARGS_NONE());
    mrb_define_method(mrb, cRaylibAutomationEventList, "count=", mrb_raylib_AutomationEventList_count_set, MRB_ARGS_REQ(1));
    // mrb_define_method(mrb, cRaylibAutomationEventList, "events", mrb_raylib_AutomationEventList_events_get, MRB_ARGS_NONE()); // TODO prepare Buffer version of classes
    // mrb_define_method(mrb, cRaylibAutomationEventList, "events=", mrb_raylib_AutomationEventList_events_set, MRB_ARGS_REQ(1)); // TODO prepare Buffer version of classes


    // Function

    mrb_define_module_function(mrb, mRaylib, "InitWindow", mrb_raylib_InitWindow, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "CloseWindow", mrb_raylib_CloseWindow, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "WindowShouldClose", mrb_raylib_WindowShouldClose, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "IsWindowReady", mrb_raylib_IsWindowReady, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "IsWindowFullscreen", mrb_raylib_IsWindowFullscreen, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "IsWindowHidden", mrb_raylib_IsWindowHidden, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "IsWindowMinimized", mrb_raylib_IsWindowMinimized, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "IsWindowMaximized", mrb_raylib_IsWindowMaximized, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "IsWindowFocused", mrb_raylib_IsWindowFocused, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "IsWindowResized", mrb_raylib_IsWindowResized, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "IsWindowState", mrb_raylib_IsWindowState, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "SetWindowState", mrb_raylib_SetWindowState, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "ClearWindowState", mrb_raylib_ClearWindowState, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "ToggleFullscreen", mrb_raylib_ToggleFullscreen, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "ToggleBorderlessWindowed", mrb_raylib_ToggleBorderlessWindowed, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "MaximizeWindow", mrb_raylib_MaximizeWindow, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "MinimizeWindow", mrb_raylib_MinimizeWindow, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "RestoreWindow", mrb_raylib_RestoreWindow, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "SetWindowIcon", mrb_raylib_SetWindowIcon, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "SetWindowIcons", mrb_raylib_SetWindowIcons, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "SetWindowTitle", mrb_raylib_SetWindowTitle, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "SetWindowPosition", mrb_raylib_SetWindowPosition, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "SetWindowMonitor", mrb_raylib_SetWindowMonitor, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "SetWindowMinSize", mrb_raylib_SetWindowMinSize, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "SetWindowMaxSize", mrb_raylib_SetWindowMaxSize, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "SetWindowSize", mrb_raylib_SetWindowSize, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "SetWindowOpacity", mrb_raylib_SetWindowOpacity, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "SetWindowFocused", mrb_raylib_SetWindowFocused, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "GetWindowHandle", mrb_raylib_GetWindowHandle, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "GetScreenWidth", mrb_raylib_GetScreenWidth, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "GetScreenHeight", mrb_raylib_GetScreenHeight, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "GetRenderWidth", mrb_raylib_GetRenderWidth, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "GetRenderHeight", mrb_raylib_GetRenderHeight, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "GetMonitorCount", mrb_raylib_GetMonitorCount, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "GetCurrentMonitor", mrb_raylib_GetCurrentMonitor, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "GetMonitorPosition", mrb_raylib_GetMonitorPosition, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetMonitorWidth", mrb_raylib_GetMonitorWidth, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetMonitorHeight", mrb_raylib_GetMonitorHeight, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetMonitorPhysicalWidth", mrb_raylib_GetMonitorPhysicalWidth, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetMonitorPhysicalHeight", mrb_raylib_GetMonitorPhysicalHeight, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetMonitorRefreshRate", mrb_raylib_GetMonitorRefreshRate, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetWindowPosition", mrb_raylib_GetWindowPosition, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "GetWindowScaleDPI", mrb_raylib_GetWindowScaleDPI, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "GetMonitorName", mrb_raylib_GetMonitorName, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "SetClipboardText", mrb_raylib_SetClipboardText, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetClipboardText", mrb_raylib_GetClipboardText, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "EnableEventWaiting", mrb_raylib_EnableEventWaiting, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "DisableEventWaiting", mrb_raylib_DisableEventWaiting, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "ShowCursor", mrb_raylib_ShowCursor, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "HideCursor", mrb_raylib_HideCursor, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "IsCursorHidden", mrb_raylib_IsCursorHidden, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "EnableCursor", mrb_raylib_EnableCursor, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "DisableCursor", mrb_raylib_DisableCursor, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "IsCursorOnScreen", mrb_raylib_IsCursorOnScreen, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "ClearBackground", mrb_raylib_ClearBackground, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "BeginDrawing", mrb_raylib_BeginDrawing, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "EndDrawing", mrb_raylib_EndDrawing, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "BeginMode2D", mrb_raylib_BeginMode2D, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "EndMode2D", mrb_raylib_EndMode2D, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "BeginMode3D", mrb_raylib_BeginMode3D, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "EndMode3D", mrb_raylib_EndMode3D, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "BeginTextureMode", mrb_raylib_BeginTextureMode, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "EndTextureMode", mrb_raylib_EndTextureMode, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "BeginShaderMode", mrb_raylib_BeginShaderMode, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "EndShaderMode", mrb_raylib_EndShaderMode, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "BeginBlendMode", mrb_raylib_BeginBlendMode, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "EndBlendMode", mrb_raylib_EndBlendMode, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "BeginScissorMode", mrb_raylib_BeginScissorMode, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "EndScissorMode", mrb_raylib_EndScissorMode, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "BeginVrStereoMode", mrb_raylib_BeginVrStereoMode, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "EndVrStereoMode", mrb_raylib_EndVrStereoMode, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "LoadVrStereoConfig", mrb_raylib_LoadVrStereoConfig, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "UnloadVrStereoConfig", mrb_raylib_UnloadVrStereoConfig, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "LoadShader", mrb_raylib_LoadShader, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "LoadShaderFromMemory", mrb_raylib_LoadShaderFromMemory, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "IsShaderReady", mrb_raylib_IsShaderReady, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetShaderLocation", mrb_raylib_GetShaderLocation, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "GetShaderLocationAttrib", mrb_raylib_GetShaderLocationAttrib, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "SetShaderValue", mrb_raylib_SetShaderValue, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "SetShaderValueV", mrb_raylib_SetShaderValueV, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "SetShaderValueMatrix", mrb_raylib_SetShaderValueMatrix, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "SetShaderValueTexture", mrb_raylib_SetShaderValueTexture, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "UnloadShader", mrb_raylib_UnloadShader, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetMouseRay", mrb_raylib_GetMouseRay, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "GetCameraMatrix", mrb_raylib_GetCameraMatrix, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetCameraMatrix2D", mrb_raylib_GetCameraMatrix2D, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetWorldToScreen", mrb_raylib_GetWorldToScreen, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "GetScreenToWorld2D", mrb_raylib_GetScreenToWorld2D, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "GetWorldToScreenEx", mrb_raylib_GetWorldToScreenEx, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "GetWorldToScreen2D", mrb_raylib_GetWorldToScreen2D, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "SetTargetFPS", mrb_raylib_SetTargetFPS, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetFrameTime", mrb_raylib_GetFrameTime, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "GetTime", mrb_raylib_GetTime, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "GetFPS", mrb_raylib_GetFPS, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "SwapScreenBuffer", mrb_raylib_SwapScreenBuffer, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "PollInputEvents", mrb_raylib_PollInputEvents, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "WaitTime", mrb_raylib_WaitTime, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetRandomValue", mrb_raylib_GetRandomValue, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "SetRandomSeed", mrb_raylib_SetRandomSeed, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "TakeScreenshot", mrb_raylib_TakeScreenshot, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "SetConfigFlags", mrb_raylib_SetConfigFlags, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "OpenURL", mrb_raylib_OpenURL, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "SetTraceLogLevel", mrb_raylib_SetTraceLogLevel, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "MemAlloc", mrb_raylib_MemAlloc, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "MemRealloc", mrb_raylib_MemRealloc, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "MemFree", mrb_raylib_MemFree, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "SetTraceLogCallback", mrb_raylib_SetTraceLogCallback, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "SetLoadFileDataCallback", mrb_raylib_SetLoadFileDataCallback, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "SetSaveFileDataCallback", mrb_raylib_SetSaveFileDataCallback, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "SetLoadFileTextCallback", mrb_raylib_SetLoadFileTextCallback, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "SetSaveFileTextCallback", mrb_raylib_SetSaveFileTextCallback, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "LoadFileData", mrb_raylib_LoadFileData, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "UnloadFileData", mrb_raylib_UnloadFileData, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "SaveFileData", mrb_raylib_SaveFileData, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "ExportDataAsCode", mrb_raylib_ExportDataAsCode, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "LoadFileText", mrb_raylib_LoadFileText, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "UnloadFileText", mrb_raylib_UnloadFileText, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "SaveFileText", mrb_raylib_SaveFileText, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "FileExists", mrb_raylib_FileExists, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "DirectoryExists", mrb_raylib_DirectoryExists, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "IsFileExtension", mrb_raylib_IsFileExtension, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "GetFileLength", mrb_raylib_GetFileLength, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetFileExtension", mrb_raylib_GetFileExtension, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetFileName", mrb_raylib_GetFileName, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetFileNameWithoutExt", mrb_raylib_GetFileNameWithoutExt, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetDirectoryPath", mrb_raylib_GetDirectoryPath, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetPrevDirectoryPath", mrb_raylib_GetPrevDirectoryPath, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetWorkingDirectory", mrb_raylib_GetWorkingDirectory, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "GetApplicationDirectory", mrb_raylib_GetApplicationDirectory, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "ChangeDirectory", mrb_raylib_ChangeDirectory, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "IsPathFile", mrb_raylib_IsPathFile, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "LoadDirectoryFiles", mrb_raylib_LoadDirectoryFiles, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "LoadDirectoryFilesEx", mrb_raylib_LoadDirectoryFilesEx, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "UnloadDirectoryFiles", mrb_raylib_UnloadDirectoryFiles, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "IsFileDropped", mrb_raylib_IsFileDropped, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "LoadDroppedFiles", mrb_raylib_LoadDroppedFiles, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "UnloadDroppedFiles", mrb_raylib_UnloadDroppedFiles, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetFileModTime", mrb_raylib_GetFileModTime, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "CompressData", mrb_raylib_CompressData, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "DecompressData", mrb_raylib_DecompressData, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "EncodeDataBase64", mrb_raylib_EncodeDataBase64, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "DecodeDataBase64", mrb_raylib_DecodeDataBase64, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "LoadAutomationEventList", mrb_raylib_LoadAutomationEventList, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "UnloadAutomationEventList", mrb_raylib_UnloadAutomationEventList, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "ExportAutomationEventList", mrb_raylib_ExportAutomationEventList, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "SetAutomationEventList", mrb_raylib_SetAutomationEventList, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "SetAutomationEventBaseFrame", mrb_raylib_SetAutomationEventBaseFrame, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "StartAutomationEventRecording", mrb_raylib_StartAutomationEventRecording, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "StopAutomationEventRecording", mrb_raylib_StopAutomationEventRecording, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "PlayAutomationEvent", mrb_raylib_PlayAutomationEvent, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "IsKeyPressed", mrb_raylib_IsKeyPressed, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "IsKeyPressedRepeat", mrb_raylib_IsKeyPressedRepeat, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "IsKeyDown", mrb_raylib_IsKeyDown, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "IsKeyReleased", mrb_raylib_IsKeyReleased, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "IsKeyUp", mrb_raylib_IsKeyUp, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetKeyPressed", mrb_raylib_GetKeyPressed, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "GetCharPressed", mrb_raylib_GetCharPressed, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "SetExitKey", mrb_raylib_SetExitKey, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "IsGamepadAvailable", mrb_raylib_IsGamepadAvailable, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetGamepadName", mrb_raylib_GetGamepadName, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "IsGamepadButtonPressed", mrb_raylib_IsGamepadButtonPressed, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "IsGamepadButtonDown", mrb_raylib_IsGamepadButtonDown, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "IsGamepadButtonReleased", mrb_raylib_IsGamepadButtonReleased, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "IsGamepadButtonUp", mrb_raylib_IsGamepadButtonUp, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "GetGamepadButtonPressed", mrb_raylib_GetGamepadButtonPressed, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "GetGamepadAxisCount", mrb_raylib_GetGamepadAxisCount, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetGamepadAxisMovement", mrb_raylib_GetGamepadAxisMovement, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "SetGamepadMappings", mrb_raylib_SetGamepadMappings, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "IsMouseButtonPressed", mrb_raylib_IsMouseButtonPressed, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "IsMouseButtonDown", mrb_raylib_IsMouseButtonDown, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "IsMouseButtonReleased", mrb_raylib_IsMouseButtonReleased, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "IsMouseButtonUp", mrb_raylib_IsMouseButtonUp, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetMouseX", mrb_raylib_GetMouseX, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "GetMouseY", mrb_raylib_GetMouseY, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "GetMousePosition", mrb_raylib_GetMousePosition, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "GetMouseDelta", mrb_raylib_GetMouseDelta, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "SetMousePosition", mrb_raylib_SetMousePosition, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "SetMouseOffset", mrb_raylib_SetMouseOffset, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "SetMouseScale", mrb_raylib_SetMouseScale, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "GetMouseWheelMove", mrb_raylib_GetMouseWheelMove, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "GetMouseWheelMoveV", mrb_raylib_GetMouseWheelMoveV, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "SetMouseCursor", mrb_raylib_SetMouseCursor, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetTouchX", mrb_raylib_GetTouchX, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "GetTouchY", mrb_raylib_GetTouchY, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "GetTouchPosition", mrb_raylib_GetTouchPosition, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetTouchPointId", mrb_raylib_GetTouchPointId, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetTouchPointCount", mrb_raylib_GetTouchPointCount, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "SetGesturesEnabled", mrb_raylib_SetGesturesEnabled, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "IsGestureDetected", mrb_raylib_IsGestureDetected, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetGestureDetected", mrb_raylib_GetGestureDetected, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "GetGestureHoldDuration", mrb_raylib_GetGestureHoldDuration, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "GetGestureDragVector", mrb_raylib_GetGestureDragVector, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "GetGestureDragAngle", mrb_raylib_GetGestureDragAngle, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "GetGesturePinchVector", mrb_raylib_GetGesturePinchVector, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "GetGesturePinchAngle", mrb_raylib_GetGesturePinchAngle, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "UpdateCamera", mrb_raylib_UpdateCamera, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "UpdateCameraPro", mrb_raylib_UpdateCameraPro, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "SetShapesTexture", mrb_raylib_SetShapesTexture, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "DrawPixel", mrb_raylib_DrawPixel, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "DrawPixelV", mrb_raylib_DrawPixelV, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "DrawLine", mrb_raylib_DrawLine, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "DrawLineV", mrb_raylib_DrawLineV, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "DrawLineEx", mrb_raylib_DrawLineEx, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "DrawLineBezier", mrb_raylib_DrawLineBezier, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "DrawLineBezierQuad", mrb_raylib_DrawLineBezierQuad, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "DrawLineBezierCubic", mrb_raylib_DrawLineBezierCubic, MRB_ARGS_REQ(6));
    mrb_define_module_function(mrb, mRaylib, "DrawLineBSpline", mrb_raylib_DrawLineBSpline, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "DrawLineCatmullRom", mrb_raylib_DrawLineCatmullRom, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "DrawLineStrip", mrb_raylib_DrawLineStrip, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "DrawCircle", mrb_raylib_DrawCircle, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "DrawCircleSector", mrb_raylib_DrawCircleSector, MRB_ARGS_REQ(6));
    mrb_define_module_function(mrb, mRaylib, "DrawCircleSectorLines", mrb_raylib_DrawCircleSectorLines, MRB_ARGS_REQ(6));
    mrb_define_module_function(mrb, mRaylib, "DrawCircleGradient", mrb_raylib_DrawCircleGradient, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "DrawCircleV", mrb_raylib_DrawCircleV, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "DrawCircleLines", mrb_raylib_DrawCircleLines, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "DrawCircleLinesV", mrb_raylib_DrawCircleLinesV, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "DrawEllipse", mrb_raylib_DrawEllipse, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "DrawEllipseLines", mrb_raylib_DrawEllipseLines, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "DrawRing", mrb_raylib_DrawRing, MRB_ARGS_REQ(7));
    mrb_define_module_function(mrb, mRaylib, "DrawRingLines", mrb_raylib_DrawRingLines, MRB_ARGS_REQ(7));
    mrb_define_module_function(mrb, mRaylib, "DrawRectangle", mrb_raylib_DrawRectangle, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "DrawRectangleV", mrb_raylib_DrawRectangleV, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "DrawRectangleRec", mrb_raylib_DrawRectangleRec, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "DrawRectanglePro", mrb_raylib_DrawRectanglePro, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "DrawRectangleGradientV", mrb_raylib_DrawRectangleGradientV, MRB_ARGS_REQ(6));
    mrb_define_module_function(mrb, mRaylib, "DrawRectangleGradientH", mrb_raylib_DrawRectangleGradientH, MRB_ARGS_REQ(6));
    mrb_define_module_function(mrb, mRaylib, "DrawRectangleGradientEx", mrb_raylib_DrawRectangleGradientEx, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "DrawRectangleLines", mrb_raylib_DrawRectangleLines, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "DrawRectangleLinesEx", mrb_raylib_DrawRectangleLinesEx, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "DrawRectangleRounded", mrb_raylib_DrawRectangleRounded, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "DrawRectangleRoundedLines", mrb_raylib_DrawRectangleRoundedLines, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "DrawTriangle", mrb_raylib_DrawTriangle, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "DrawTriangleLines", mrb_raylib_DrawTriangleLines, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "DrawTriangleFan", mrb_raylib_DrawTriangleFan, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "DrawTriangleStrip", mrb_raylib_DrawTriangleStrip, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "DrawPoly", mrb_raylib_DrawPoly, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "DrawPolyLines", mrb_raylib_DrawPolyLines, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "DrawPolyLinesEx", mrb_raylib_DrawPolyLinesEx, MRB_ARGS_REQ(6));
    mrb_define_module_function(mrb, mRaylib, "CheckCollisionRecs", mrb_raylib_CheckCollisionRecs, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "CheckCollisionCircles", mrb_raylib_CheckCollisionCircles, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "CheckCollisionCircleRec", mrb_raylib_CheckCollisionCircleRec, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "CheckCollisionPointRec", mrb_raylib_CheckCollisionPointRec, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "CheckCollisionPointCircle", mrb_raylib_CheckCollisionPointCircle, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "CheckCollisionPointTriangle", mrb_raylib_CheckCollisionPointTriangle, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "CheckCollisionPointPoly", mrb_raylib_CheckCollisionPointPoly, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "CheckCollisionLines", mrb_raylib_CheckCollisionLines, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "CheckCollisionPointLine", mrb_raylib_CheckCollisionPointLine, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "GetCollisionRec", mrb_raylib_GetCollisionRec, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "LoadImage", mrb_raylib_LoadImage, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "LoadImageRaw", mrb_raylib_LoadImageRaw, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "LoadImageSvg", mrb_raylib_LoadImageSvg, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "LoadImageAnim", mrb_raylib_LoadImageAnim, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "LoadImageFromMemory", mrb_raylib_LoadImageFromMemory, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "LoadImageFromTexture", mrb_raylib_LoadImageFromTexture, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "LoadImageFromScreen", mrb_raylib_LoadImageFromScreen, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "IsImageReady", mrb_raylib_IsImageReady, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "UnloadImage", mrb_raylib_UnloadImage, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "ExportImage", mrb_raylib_ExportImage, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "ExportImageToMemory", mrb_raylib_ExportImageToMemory, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "ExportImageAsCode", mrb_raylib_ExportImageAsCode, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "GenImageColor", mrb_raylib_GenImageColor, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "GenImageGradientLinear", mrb_raylib_GenImageGradientLinear, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "GenImageGradientRadial", mrb_raylib_GenImageGradientRadial, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "GenImageGradientSquare", mrb_raylib_GenImageGradientSquare, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "GenImageChecked", mrb_raylib_GenImageChecked, MRB_ARGS_REQ(6));
    mrb_define_module_function(mrb, mRaylib, "GenImageWhiteNoise", mrb_raylib_GenImageWhiteNoise, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "GenImagePerlinNoise", mrb_raylib_GenImagePerlinNoise, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "GenImageCellular", mrb_raylib_GenImageCellular, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "GenImageText", mrb_raylib_GenImageText, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "ImageCopy", mrb_raylib_ImageCopy, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "ImageFromImage", mrb_raylib_ImageFromImage, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "ImageText", mrb_raylib_ImageText, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "ImageTextEx", mrb_raylib_ImageTextEx, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "ImageFormat", mrb_raylib_ImageFormat, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "ImageToPOT", mrb_raylib_ImageToPOT, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "ImageCrop", mrb_raylib_ImageCrop, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "ImageAlphaCrop", mrb_raylib_ImageAlphaCrop, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "ImageAlphaClear", mrb_raylib_ImageAlphaClear, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "ImageAlphaMask", mrb_raylib_ImageAlphaMask, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "ImageAlphaPremultiply", mrb_raylib_ImageAlphaPremultiply, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "ImageBlurGaussian", mrb_raylib_ImageBlurGaussian, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "ImageResize", mrb_raylib_ImageResize, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "ImageResizeNN", mrb_raylib_ImageResizeNN, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "ImageResizeCanvas", mrb_raylib_ImageResizeCanvas, MRB_ARGS_REQ(6));
    mrb_define_module_function(mrb, mRaylib, "ImageMipmaps", mrb_raylib_ImageMipmaps, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "ImageDither", mrb_raylib_ImageDither, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "ImageFlipVertical", mrb_raylib_ImageFlipVertical, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "ImageFlipHorizontal", mrb_raylib_ImageFlipHorizontal, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "ImageRotate", mrb_raylib_ImageRotate, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "ImageRotateCW", mrb_raylib_ImageRotateCW, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "ImageRotateCCW", mrb_raylib_ImageRotateCCW, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "ImageColorTint", mrb_raylib_ImageColorTint, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "ImageColorInvert", mrb_raylib_ImageColorInvert, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "ImageColorGrayscale", mrb_raylib_ImageColorGrayscale, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "ImageColorContrast", mrb_raylib_ImageColorContrast, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "ImageColorBrightness", mrb_raylib_ImageColorBrightness, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "ImageColorReplace", mrb_raylib_ImageColorReplace, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "LoadImageColors", mrb_raylib_LoadImageColors, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "LoadImagePalette", mrb_raylib_LoadImagePalette, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "UnloadImageColors", mrb_raylib_UnloadImageColors, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "UnloadImagePalette", mrb_raylib_UnloadImagePalette, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetImageAlphaBorder", mrb_raylib_GetImageAlphaBorder, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "GetImageColor", mrb_raylib_GetImageColor, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "ImageClearBackground", mrb_raylib_ImageClearBackground, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "ImageDrawPixel", mrb_raylib_ImageDrawPixel, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "ImageDrawPixelV", mrb_raylib_ImageDrawPixelV, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "ImageDrawLine", mrb_raylib_ImageDrawLine, MRB_ARGS_REQ(6));
    mrb_define_module_function(mrb, mRaylib, "ImageDrawLineV", mrb_raylib_ImageDrawLineV, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "ImageDrawCircle", mrb_raylib_ImageDrawCircle, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "ImageDrawCircleV", mrb_raylib_ImageDrawCircleV, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "ImageDrawCircleLines", mrb_raylib_ImageDrawCircleLines, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "ImageDrawCircleLinesV", mrb_raylib_ImageDrawCircleLinesV, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "ImageDrawRectangle", mrb_raylib_ImageDrawRectangle, MRB_ARGS_REQ(6));
    mrb_define_module_function(mrb, mRaylib, "ImageDrawRectangleV", mrb_raylib_ImageDrawRectangleV, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "ImageDrawRectangleRec", mrb_raylib_ImageDrawRectangleRec, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "ImageDrawRectangleLines", mrb_raylib_ImageDrawRectangleLines, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "ImageDraw", mrb_raylib_ImageDraw, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "ImageDrawText", mrb_raylib_ImageDrawText, MRB_ARGS_REQ(6));
    mrb_define_module_function(mrb, mRaylib, "ImageDrawTextEx", mrb_raylib_ImageDrawTextEx, MRB_ARGS_REQ(7));
    mrb_define_module_function(mrb, mRaylib, "LoadTexture", mrb_raylib_LoadTexture, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "LoadTextureFromImage", mrb_raylib_LoadTextureFromImage, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "LoadTextureCubemap", mrb_raylib_LoadTextureCubemap, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "LoadRenderTexture", mrb_raylib_LoadRenderTexture, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "IsTextureReady", mrb_raylib_IsTextureReady, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "UnloadTexture", mrb_raylib_UnloadTexture, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "IsRenderTextureReady", mrb_raylib_IsRenderTextureReady, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "UnloadRenderTexture", mrb_raylib_UnloadRenderTexture, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "UpdateTexture", mrb_raylib_UpdateTexture, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "UpdateTextureRec", mrb_raylib_UpdateTextureRec, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "GenTextureMipmaps", mrb_raylib_GenTextureMipmaps, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "SetTextureFilter", mrb_raylib_SetTextureFilter, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "SetTextureWrap", mrb_raylib_SetTextureWrap, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "DrawTexture", mrb_raylib_DrawTexture, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "DrawTextureV", mrb_raylib_DrawTextureV, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "DrawTextureEx", mrb_raylib_DrawTextureEx, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "DrawTextureRec", mrb_raylib_DrawTextureRec, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "DrawTexturePro", mrb_raylib_DrawTexturePro, MRB_ARGS_REQ(6));
    mrb_define_module_function(mrb, mRaylib, "DrawTextureNPatch", mrb_raylib_DrawTextureNPatch, MRB_ARGS_REQ(6));
    mrb_define_module_function(mrb, mRaylib, "Fade", mrb_raylib_Fade, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "ColorToInt", mrb_raylib_ColorToInt, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "ColorNormalize", mrb_raylib_ColorNormalize, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "ColorFromNormalized", mrb_raylib_ColorFromNormalized, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "ColorToHSV", mrb_raylib_ColorToHSV, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "ColorFromHSV", mrb_raylib_ColorFromHSV, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "ColorTint", mrb_raylib_ColorTint, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "ColorBrightness", mrb_raylib_ColorBrightness, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "ColorContrast", mrb_raylib_ColorContrast, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "ColorAlpha", mrb_raylib_ColorAlpha, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "ColorAlphaBlend", mrb_raylib_ColorAlphaBlend, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "GetColor", mrb_raylib_GetColor, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetPixelColor", mrb_raylib_GetPixelColor, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "SetPixelColor", mrb_raylib_SetPixelColor, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "GetPixelDataSize", mrb_raylib_GetPixelDataSize, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "GetFontDefault", mrb_raylib_GetFontDefault, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "LoadFont", mrb_raylib_LoadFont, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "LoadFontEx", mrb_raylib_LoadFontEx, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "LoadFontFromImage", mrb_raylib_LoadFontFromImage, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "LoadFontFromMemory", mrb_raylib_LoadFontFromMemory, MRB_ARGS_REQ(6));
    mrb_define_module_function(mrb, mRaylib, "IsFontReady", mrb_raylib_IsFontReady, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "LoadFontData", mrb_raylib_LoadFontData, MRB_ARGS_REQ(6));
    mrb_define_module_function(mrb, mRaylib, "GenImageFontAtlas", mrb_raylib_GenImageFontAtlas, MRB_ARGS_REQ(6));
    mrb_define_module_function(mrb, mRaylib, "UnloadFontData", mrb_raylib_UnloadFontData, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "UnloadFont", mrb_raylib_UnloadFont, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "ExportFontAsCode", mrb_raylib_ExportFontAsCode, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "DrawFPS", mrb_raylib_DrawFPS, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "DrawText", mrb_raylib_DrawText, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "DrawTextEx", mrb_raylib_DrawTextEx, MRB_ARGS_REQ(6));
    mrb_define_module_function(mrb, mRaylib, "DrawTextPro", mrb_raylib_DrawTextPro, MRB_ARGS_REQ(8));
    mrb_define_module_function(mrb, mRaylib, "DrawTextCodepoint", mrb_raylib_DrawTextCodepoint, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "DrawTextCodepoints", mrb_raylib_DrawTextCodepoints, MRB_ARGS_REQ(7));
    mrb_define_module_function(mrb, mRaylib, "SetTextLineSpacing", mrb_raylib_SetTextLineSpacing, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "MeasureText", mrb_raylib_MeasureText, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "MeasureTextEx", mrb_raylib_MeasureTextEx, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "GetGlyphIndex", mrb_raylib_GetGlyphIndex, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "GetGlyphInfo", mrb_raylib_GetGlyphInfo, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "GetGlyphAtlasRec", mrb_raylib_GetGlyphAtlasRec, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "LoadUTF8", mrb_raylib_LoadUTF8, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "UnloadUTF8", mrb_raylib_UnloadUTF8, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "LoadCodepoints", mrb_raylib_LoadCodepoints, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "UnloadCodepoints", mrb_raylib_UnloadCodepoints, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetCodepointCount", mrb_raylib_GetCodepointCount, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetCodepoint", mrb_raylib_GetCodepoint, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "GetCodepointNext", mrb_raylib_GetCodepointNext, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "GetCodepointPrevious", mrb_raylib_GetCodepointPrevious, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "CodepointToUTF8", mrb_raylib_CodepointToUTF8, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "TextCopy", mrb_raylib_TextCopy, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "TextIsEqual", mrb_raylib_TextIsEqual, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "TextLength", mrb_raylib_TextLength, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "TextSubtext", mrb_raylib_TextSubtext, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "TextReplace", mrb_raylib_TextReplace, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "TextInsert", mrb_raylib_TextInsert, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "TextJoin", mrb_raylib_TextJoin, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "TextSplit", mrb_raylib_TextSplit, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "TextAppend", mrb_raylib_TextAppend, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "TextFindIndex", mrb_raylib_TextFindIndex, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "TextToUpper", mrb_raylib_TextToUpper, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "TextToLower", mrb_raylib_TextToLower, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "TextToPascal", mrb_raylib_TextToPascal, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "TextToInteger", mrb_raylib_TextToInteger, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "DrawLine3D", mrb_raylib_DrawLine3D, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "DrawPoint3D", mrb_raylib_DrawPoint3D, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "DrawCircle3D", mrb_raylib_DrawCircle3D, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "DrawTriangle3D", mrb_raylib_DrawTriangle3D, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "DrawTriangleStrip3D", mrb_raylib_DrawTriangleStrip3D, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "DrawCube", mrb_raylib_DrawCube, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "DrawCubeV", mrb_raylib_DrawCubeV, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "DrawCubeWires", mrb_raylib_DrawCubeWires, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "DrawCubeWiresV", mrb_raylib_DrawCubeWiresV, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "DrawSphere", mrb_raylib_DrawSphere, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "DrawSphereEx", mrb_raylib_DrawSphereEx, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "DrawSphereWires", mrb_raylib_DrawSphereWires, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "DrawCylinder", mrb_raylib_DrawCylinder, MRB_ARGS_REQ(6));
    mrb_define_module_function(mrb, mRaylib, "DrawCylinderEx", mrb_raylib_DrawCylinderEx, MRB_ARGS_REQ(6));
    mrb_define_module_function(mrb, mRaylib, "DrawCylinderWires", mrb_raylib_DrawCylinderWires, MRB_ARGS_REQ(6));
    mrb_define_module_function(mrb, mRaylib, "DrawCylinderWiresEx", mrb_raylib_DrawCylinderWiresEx, MRB_ARGS_REQ(6));
    mrb_define_module_function(mrb, mRaylib, "DrawCapsule", mrb_raylib_DrawCapsule, MRB_ARGS_REQ(6));
    mrb_define_module_function(mrb, mRaylib, "DrawCapsuleWires", mrb_raylib_DrawCapsuleWires, MRB_ARGS_REQ(6));
    mrb_define_module_function(mrb, mRaylib, "DrawPlane", mrb_raylib_DrawPlane, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "DrawRay", mrb_raylib_DrawRay, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "DrawGrid", mrb_raylib_DrawGrid, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "LoadModel", mrb_raylib_LoadModel, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "LoadModelFromMesh", mrb_raylib_LoadModelFromMesh, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "IsModelReady", mrb_raylib_IsModelReady, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "UnloadModel", mrb_raylib_UnloadModel, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetModelBoundingBox", mrb_raylib_GetModelBoundingBox, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "DrawModel", mrb_raylib_DrawModel, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "DrawModelEx", mrb_raylib_DrawModelEx, MRB_ARGS_REQ(6));
    mrb_define_module_function(mrb, mRaylib, "DrawModelWires", mrb_raylib_DrawModelWires, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "DrawModelWiresEx", mrb_raylib_DrawModelWiresEx, MRB_ARGS_REQ(6));
    mrb_define_module_function(mrb, mRaylib, "DrawBoundingBox", mrb_raylib_DrawBoundingBox, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "DrawBillboard", mrb_raylib_DrawBillboard, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "DrawBillboardRec", mrb_raylib_DrawBillboardRec, MRB_ARGS_REQ(6));
    mrb_define_module_function(mrb, mRaylib, "DrawBillboardPro", mrb_raylib_DrawBillboardPro, MRB_ARGS_REQ(9));
    mrb_define_module_function(mrb, mRaylib, "UploadMesh", mrb_raylib_UploadMesh, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "UpdateMeshBuffer", mrb_raylib_UpdateMeshBuffer, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "UnloadMesh", mrb_raylib_UnloadMesh, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "DrawMesh", mrb_raylib_DrawMesh, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "DrawMeshInstanced", mrb_raylib_DrawMeshInstanced, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "ExportMesh", mrb_raylib_ExportMesh, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "GetMeshBoundingBox", mrb_raylib_GetMeshBoundingBox, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GenMeshTangents", mrb_raylib_GenMeshTangents, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GenMeshPoly", mrb_raylib_GenMeshPoly, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "GenMeshPlane", mrb_raylib_GenMeshPlane, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "GenMeshCube", mrb_raylib_GenMeshCube, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "GenMeshSphere", mrb_raylib_GenMeshSphere, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "GenMeshHemiSphere", mrb_raylib_GenMeshHemiSphere, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "GenMeshCylinder", mrb_raylib_GenMeshCylinder, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "GenMeshCone", mrb_raylib_GenMeshCone, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "GenMeshTorus", mrb_raylib_GenMeshTorus, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "GenMeshKnot", mrb_raylib_GenMeshKnot, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "GenMeshHeightmap", mrb_raylib_GenMeshHeightmap, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "GenMeshCubicmap", mrb_raylib_GenMeshCubicmap, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "LoadMaterials", mrb_raylib_LoadMaterials, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "LoadMaterialDefault", mrb_raylib_LoadMaterialDefault, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "IsMaterialReady", mrb_raylib_IsMaterialReady, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "UnloadMaterial", mrb_raylib_UnloadMaterial, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "SetMaterialTexture", mrb_raylib_SetMaterialTexture, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "SetModelMeshMaterial", mrb_raylib_SetModelMeshMaterial, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "LoadModelAnimations", mrb_raylib_LoadModelAnimations, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "UpdateModelAnimation", mrb_raylib_UpdateModelAnimation, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "UnloadModelAnimation", mrb_raylib_UnloadModelAnimation, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "UnloadModelAnimations", mrb_raylib_UnloadModelAnimations, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "IsModelAnimationValid", mrb_raylib_IsModelAnimationValid, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "CheckCollisionSpheres", mrb_raylib_CheckCollisionSpheres, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "CheckCollisionBoxes", mrb_raylib_CheckCollisionBoxes, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "CheckCollisionBoxSphere", mrb_raylib_CheckCollisionBoxSphere, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "GetRayCollisionSphere", mrb_raylib_GetRayCollisionSphere, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "GetRayCollisionBox", mrb_raylib_GetRayCollisionBox, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "GetRayCollisionMesh", mrb_raylib_GetRayCollisionMesh, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "GetRayCollisionTriangle", mrb_raylib_GetRayCollisionTriangle, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "GetRayCollisionQuad", mrb_raylib_GetRayCollisionQuad, MRB_ARGS_REQ(5));
    mrb_define_module_function(mrb, mRaylib, "InitAudioDevice", mrb_raylib_InitAudioDevice, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "CloseAudioDevice", mrb_raylib_CloseAudioDevice, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "IsAudioDeviceReady", mrb_raylib_IsAudioDeviceReady, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "SetMasterVolume", mrb_raylib_SetMasterVolume, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetMasterVolume", mrb_raylib_GetMasterVolume, MRB_ARGS_NONE());
    mrb_define_module_function(mrb, mRaylib, "LoadWave", mrb_raylib_LoadWave, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "LoadWaveFromMemory", mrb_raylib_LoadWaveFromMemory, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "IsWaveReady", mrb_raylib_IsWaveReady, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "LoadSound", mrb_raylib_LoadSound, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "LoadSoundFromWave", mrb_raylib_LoadSoundFromWave, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "LoadSoundAlias", mrb_raylib_LoadSoundAlias, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "IsSoundReady", mrb_raylib_IsSoundReady, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "UpdateSound", mrb_raylib_UpdateSound, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "UnloadWave", mrb_raylib_UnloadWave, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "UnloadSound", mrb_raylib_UnloadSound, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "UnloadSoundAlias", mrb_raylib_UnloadSoundAlias, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "ExportWave", mrb_raylib_ExportWave, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "ExportWaveAsCode", mrb_raylib_ExportWaveAsCode, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "PlaySound", mrb_raylib_PlaySound, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "StopSound", mrb_raylib_StopSound, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "PauseSound", mrb_raylib_PauseSound, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "ResumeSound", mrb_raylib_ResumeSound, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "IsSoundPlaying", mrb_raylib_IsSoundPlaying, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "SetSoundVolume", mrb_raylib_SetSoundVolume, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "SetSoundPitch", mrb_raylib_SetSoundPitch, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "SetSoundPan", mrb_raylib_SetSoundPan, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "WaveCopy", mrb_raylib_WaveCopy, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "WaveCrop", mrb_raylib_WaveCrop, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "WaveFormat", mrb_raylib_WaveFormat, MRB_ARGS_REQ(4));
    mrb_define_module_function(mrb, mRaylib, "LoadWaveSamples", mrb_raylib_LoadWaveSamples, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "UnloadWaveSamples", mrb_raylib_UnloadWaveSamples, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "LoadMusicStream", mrb_raylib_LoadMusicStream, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "LoadMusicStreamFromMemory", mrb_raylib_LoadMusicStreamFromMemory, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "IsMusicReady", mrb_raylib_IsMusicReady, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "UnloadMusicStream", mrb_raylib_UnloadMusicStream, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "PlayMusicStream", mrb_raylib_PlayMusicStream, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "IsMusicStreamPlaying", mrb_raylib_IsMusicStreamPlaying, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "UpdateMusicStream", mrb_raylib_UpdateMusicStream, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "StopMusicStream", mrb_raylib_StopMusicStream, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "PauseMusicStream", mrb_raylib_PauseMusicStream, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "ResumeMusicStream", mrb_raylib_ResumeMusicStream, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "SeekMusicStream", mrb_raylib_SeekMusicStream, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "SetMusicVolume", mrb_raylib_SetMusicVolume, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "SetMusicPitch", mrb_raylib_SetMusicPitch, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "SetMusicPan", mrb_raylib_SetMusicPan, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "GetMusicTimeLength", mrb_raylib_GetMusicTimeLength, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "GetMusicTimePlayed", mrb_raylib_GetMusicTimePlayed, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "LoadAudioStream", mrb_raylib_LoadAudioStream, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "IsAudioStreamReady", mrb_raylib_IsAudioStreamReady, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "UnloadAudioStream", mrb_raylib_UnloadAudioStream, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "UpdateAudioStream", mrb_raylib_UpdateAudioStream, MRB_ARGS_REQ(3));
    mrb_define_module_function(mrb, mRaylib, "IsAudioStreamProcessed", mrb_raylib_IsAudioStreamProcessed, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "PlayAudioStream", mrb_raylib_PlayAudioStream, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "PauseAudioStream", mrb_raylib_PauseAudioStream, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "ResumeAudioStream", mrb_raylib_ResumeAudioStream, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "IsAudioStreamPlaying", mrb_raylib_IsAudioStreamPlaying, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "StopAudioStream", mrb_raylib_StopAudioStream, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "SetAudioStreamVolume", mrb_raylib_SetAudioStreamVolume, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "SetAudioStreamPitch", mrb_raylib_SetAudioStreamPitch, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "SetAudioStreamPan", mrb_raylib_SetAudioStreamPan, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "SetAudioStreamBufferSizeDefault", mrb_raylib_SetAudioStreamBufferSizeDefault, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "SetAudioStreamCallback", mrb_raylib_SetAudioStreamCallback, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "AttachAudioStreamProcessor", mrb_raylib_AttachAudioStreamProcessor, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "DetachAudioStreamProcessor", mrb_raylib_DetachAudioStreamProcessor, MRB_ARGS_REQ(2));
    mrb_define_module_function(mrb, mRaylib, "AttachAudioMixedProcessor", mrb_raylib_AttachAudioMixedProcessor, MRB_ARGS_REQ(1));
    mrb_define_module_function(mrb, mRaylib, "DetachAudioMixedProcessor", mrb_raylib_DetachAudioMixedProcessor, MRB_ARGS_REQ(1));
}
